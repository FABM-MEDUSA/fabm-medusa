{\rtf1\ansi\deff0{\fonttbl{\f0\fnil\fcharset0 Courier New;}}
{\*\generator Msftedit 5.41.21.2510;}\viewkind4\uc1\pard\lang2057\f0\fs16 MODULE trcbio_medusa\par
   !!======================================================================\par
   !!                         ***  MODULE trcbio  ***\par
   !! TOP :   MEDUSA\par
   !!======================================================================\par
   !! History :\par
   !!  -   !  1999-07  (M. Levy)              original code\par
   !!  -   !  2000-12  (E. Kestenare)         assign parameters to name individual tracers\par
   !!  -   !  2001-03  (M. Levy)              LNO3 + dia2d \par
   !! 2.0  !  2007-12  (C. Deltel, G. Madec)  F90\par
   !!  -   !  2008-08  (K. Popova)            adaptation for MEDUSA\par
   !!  -   !  2008-11  (A. Yool)              continuing adaptation for MEDUSA\par
   !!  -   !  2010-03  (A. Yool)              updated for branch inclusion\par
   !!  -   !  2011-08  (A. Yool)              updated for ROAM (see below)\par
   !!  -   !  2013-03  (A. Yool)              updated for iMARNET\par
   !!  -   !  2013-05  (A. Yool)              updated for v3.5\par
   !!  -   !  2014-08  (A. Yool, J. Palm)     Add DMS module for UKESM1 model\par
   !!  -   !  2015-06  (A. Yool)              Update to include MOCSY\par
   !!  -   !  2015-07  (A. Yool)              Update for rolling averages\par
   !!  -   !  2015-10  (J. Palm)              Update for diag outputs through iom_use  \par
   !!  -   !  2016-11  (A. Yool)              Updated diags for CMIP6\par
   !!  -   !  2017-05  (A. Yool)              Added extra DMS calculation\par
   !!----------------------------------------------------------------------\par
   !!\par
#if defined key_roam\par
   !!----------------------------------------------------------------------\par
   !! Updates for the ROAM project include:\par
   !!   - addition of DIC, alkalinity, detrital carbon and oxygen tracers\par
   !!   - addition of air-sea fluxes of CO2 and oxygen\par
   !!   - periodic (monthly) calculation of full 3D carbonate chemistry \par
   !!   - detrital C:N ratio now free to evolve dynamically\par
   !!   - benthic storage pools\par
   !! \par
   !! Opportunity also taken to add functionality:\par
   !!   - switch for Liebig Law (= most-limiting) nutrient uptake\par
   !!   - switch for accelerated seafloor detritus remineralisation\par
   !!   - switch for fast -> slow detritus transfer at seafloor\par
   !!   - switch for ballast vs. Martin vs. Henson fast detritus remin.\par
   !!   - per GMD referee remarks, xfdfrac3 introduced for grazed PDS\par
   !!----------------------------------------------------------------------\par
#endif\par
   !!\par
#if defined key_mocsy\par
   !!----------------------------------------------------------------------\par
   !! Updates with the addition of MOCSY include:\par
   !!   - option to use PML or MOCSY carbonate chemistry (the latter is \par
   !!     preferred)\par
   !!   - central calculation of gas transfer velocity, f_kw660; previously\par
   !!     this was done separately for CO2 and O2 with predictable results\par
   !!   - distribution of f_kw660 to both PML and MOCSY CO2 air-sea flux \par
   !!     calculations and to those for O2 air-sea flux\par
   !!   - extra diagnostics included for MOCSY\par
   !!----------------------------------------------------------------------\par
#endif\par
   !!\par
#if defined key_medusa\par
   !!----------------------------------------------------------------------\par
   !!                                        MEDUSA bio-model\par
   !!----------------------------------------------------------------------\par
   !!   trc_bio_medusa        :  \par
   !!----------------------------------------------------------------------\par
      USE oce_trc\par
      USE trc\par
      USE sms_medusa\par
      USE lbclnk\par
      USE prtctl_trc      ! Print control for debugging\par
      USE trcsed_medusa\par
      USE sbc_oce         ! surface forcing\par
      USE sbcrnf          ! surface boundary condition: runoff variables\par
      USE in_out_manager  ! I/O manager\par
# if defined key_iomput\par
      USE iom\par
      USE trcnam_medusa         ! JPALM 13-11-2015 -- if iom_use for diag\par
      !!USE trc_nam_iom_medusa  ! JPALM 13-11-2015 -- if iom_use for diag\par
# endif\par
# if defined key_roam\par
      USE gastransfer\par
#  if defined key_mocsy\par
      USE mocsy_wrapper\par
#  else\par
      USE trcco2_medusa\par
#  if defined key_foam_medusa\par
      USE mocsy_mainmod\par
#  endif\par
#  endif\par
      USE trcoxy_medusa\par
      !! Jpalm (08/08/2014)\par
      USE trcdms_medusa\par
# endif\par
      !! AXY (18/01/12): brought in for benthic timestepping\par
      USE trcnam_trp      ! AXY (24/05/2013)\par
      USE trdmxl_trc\par
      USE trdtrc_oce  ! AXY (24/05/2013)\par
\par
      !! AXY (30/01/14): necessary to find NaNs on HECTOR\par
      USE, INTRINSIC :: ieee_arithmetic \par
\par
      !! JPALM (27-06-2016): add lk_oasis for CO2 and DMS coupling with atm\par
      USE sbc_oce, ONLY: lk_oasis\par
      USE oce,     ONLY: CO2Flux_out_cpl, DMS_out_cpl, PCO2a_in_cpl, chloro_out_cpl\par
\par
      IMPLICIT NONE\par
      PRIVATE\par
      \par
      PUBLIC   trc_bio_medusa    ! called in ???\par
\par
   !!* Substitution\par
#  include "domzgr_substitute.h90"\par
   !!----------------------------------------------------------------------\par
   !! NEMO/TOP 2.0 , LOCEAN-IPSL (2007) \par
   !! $Id$\par
   !! Software governed by the CeCILL licence (modipsl/doc/NEMO_CeCILL.txt)\par
   !!----------------------------------------------------------------------\par
\par
CONTAINS\par
\par
   SUBROUTINE trc_bio_medusa( kt )\par
      !!---------------------------------------------------------------------\par
      !!                     ***  ROUTINE trc_bio  ***\par
      !!\par
      !! ** Purpose :   compute the now trend due to biogeochemical processes\par
      !!              and add it to the general trend of passive tracers equations\par
      !!\par
      !! ** Method  :   each now biological flux is calculated in function of now\par
      !!              concentrations of tracers.\par
      !!              depending on the tracer, these fluxes are sources or sinks.\par
      !!              the total of the sources and sinks for each tracer\par
      !!              is added to the general trend.\par
      !!        \par
      !!                      tra = tra + zf...tra - zftra...\par
      !!                                     |         |\par
      !!                                     |         |\par
      !!                                  source      sink\par
      !!        \par
      !!              IF 'key_trc_diabio' defined , the biogeochemical trends\par
      !!              for passive tracers are saved for futher diagnostics.\par
      !!---------------------------------------------------------------------\par
      !!\par
      !!\par
      !!----------------------------------------------------------------------            \par
      !! Variable conventions\par
      !!----------------------------------------------------------------------\par
      !!\par
      !! names: z*** - state variable \par
      !!        f*** - function (or temporary variable used in part of a function)\par
      !!        x*** - parameter\par
      !!        b*** - right-hand part (sources and sinks)\par
      !!        i*** - integer variable (usually used in yes/no flags)\par
      !!\par
      !! time (integer timestep)\par
      INTEGER, INTENT( in ) ::    kt\par
      !!\par
      !! spatial array indices\par
      INTEGER  ::    ji,jj,jk,jn\par
      !!\par
      !! AXY (27/07/10): add in indices for depth horizons (for sinking flux\par
      !!                 and seafloor iron inputs)\par
      !! INTEGER  ::    i0100, i0200, i0500, i1000, i1100\par
      !!\par
      !! model state variables\par
      REAL(wp) ::    zchn,zchd,zphn,zphd,zpds,zzmi\par
      REAL(wp) ::    zzme,zdet,zdtc,zdin,zsil,zfer\par
      REAL(wp) ::    zage\par
# if defined key_roam\par
      REAL(wp) ::    zdic, zalk, zoxy\par
      REAL(wp) ::    ztmp, zsal\par
# endif\par
# if defined key_mocsy\par
      REAL(wp) ::    zpho\par
# endif\par
      !!\par
      !! integrated source and sink terms\par
      REAL(wp) ::    b0\par
      !! AXY (23/08/13): changed from individual variables for each flux to\par
      !!                 an array that holds all fluxes\par
      REAL(wp), DIMENSION(jp_medusa) ::    btra\par
      !!\par
      !! primary production and chl related quantities      \par
      REAL(wp)                     ::    fthetan,faln,fchn1,fchn,fjln,fprn,frn\par
      REAL(wp)                     ::    fthetad,fald,fchd1,fchd,fjld,fprd,frd\par
      !! AXY (23/11/16): add in light-only limitation term (normalised 0-1 range)\par
      REAL(wp)                     ::    fjlim_pn, fjlim_pd\par
      !! AXY (03/02/11): add in Liebig terms\par
      REAL(wp) ::    fpnlim, fpdlim\par
      !! AXY (16/07/09): add in Eppley curve functionality\par
      REAL(wp) ::    loc_T,fun_T,xvpnT,xvpdT\par
      INTEGER  ::    ieppley\par
      !! AXY (16/05/11): per Katya's prompting, add in new T-dependence\par
      !!                 for phytoplankton growth only (i.e. no change\par
      !!                 for remineralisation)\par
      REAL(wp) ::    fun_Q10\par
      !! AXY (01/03/10): add in mixed layer PP diagnostics\par
      REAL(wp), DIMENSION(jpi,jpj) ::  fprn_ml,fprd_ml\par
      !!\par
      !! nutrient limiting factors\par
      REAL(wp) ::    fnln,ffln            !! N and Fe\par
      REAL(wp) ::    fnld,ffld,fsld,fsld2 !! N, Fe and Si\par
      !!\par
      !! silicon cycle\par
      REAL(wp) ::    fsin,fnsi,fsin1,fnsi1,fnsi2,fprds,fsdiss\par
      !!\par
      !! iron cycle; includes parameters for Parekh et al. (2005) iron scheme\par
      REAL(wp) ::    ffetop,ffebot,ffescav\par
      REAL(wp) ::    xLgF, xFeT, xFeF, xFeL         !! state variables for iron-ligand system\par
      REAL(wp), DIMENSION(jpi,jpj) ::  xFree        !! state variables for iron-ligand system\par
      REAL(wp) ::    xb_coef_tmp, xb2M4ac           !! iron-ligand parameters\par
      REAL(wp) ::    xmaxFeF,fdeltaFe               !! max Fe' parameters\par
      !!\par
      !! local parameters for Moore et al. (2004) alternative scavenging scheme\par
      REAL(wp) ::    fbase_scav,fscal_sink,fscal_part,fscal_scav\par
      !!\par
      !! local parameters for Moore et al. (2008) alternative scavenging scheme\par
      REAL(wp) ::    fscal_csink,fscal_sisink,fscal_casink\par
      !!\par
      !! local parameters for Galbraith et al. (2010) alternative scavenging scheme\par
      REAL(wp) ::    xCscav1, xCscav2, xk_org, xORGscav  !! organic portion of scavenging\par
      REAL(wp) ::    xk_inorg, xINORGscav                !! inorganic portion of scavenging\par
      !!\par
      !! microzooplankton grazing\par
      REAL(wp) ::    fmi1,fmi,fgmipn,fgmid,fgmidc\par
      REAL(wp) ::    finmi,ficmi,fstarmi,fmith,fmigrow,fmiexcr,fmiresp\par
      !!\par
      !! mesozooplankton grazing\par
      REAL(wp) ::    fme1,fme,fgmepn,fgmepd,fgmepds,fgmezmi,fgmed,fgmedc\par
      REAL(wp) ::    finme,ficme,fstarme,fmeth,fmegrow,fmeexcr,fmeresp\par
      !!\par
      !! mortality/Remineralisation (defunct parameter "fz" removed)\par
      REAL(wp) ::    fdpn,fdpd,fdpds,fdzmi,fdzme,fdd\par
# if defined key_roam\par
      REAL(wp) ::    fddc\par
# endif\par
      REAL(wp) ::    fdpn2,fdpd2,fdpds2,fdzmi2,fdzme2\par
      REAL(wp) ::    fslown, fslowc\par
      REAL(wp), DIMENSION(jpi,jpj) ::    fslownflux, fslowcflux\par
      REAL(wp) ::    fregen,fregensi\par
      REAL(wp), DIMENSION(jpi,jpj) ::    fregenfast,fregenfastsi\par
# if defined key_roam\par
      REAL(wp) ::    fregenc\par
      REAL(wp), DIMENSION(jpi,jpj) ::    fregenfastc\par
# endif\par
      !!\par
      !! particle flux\par
      REAL(WP) ::    fthk,fdep,fdep1,fdep2,flat,fcaco3\par
      REAL(WP) ::    ftempn,ftempsi,ftempfe,ftempc,ftempca\par
      REAL(wp) ::    freminn,freminsi,freminfe,freminc,freminca\par
      REAL(wp), DIMENSION(jpi,jpj) ::    ffastn,ffastsi,ffastfe,ffastc,ffastca\par
      REAL(wp) ::    fleftn,fleftsi,fleftfe,fleftc,fleftca\par
      REAL(wp) ::    fheren,fheresi,fherefe,fherec,fhereca\par
      REAL(wp) ::    fprotf\par
      REAL(wp), DIMENSION(jpi,jpj) ::    fsedn,fsedsi,fsedfe,fsedc,fsedca\par
      REAL(wp), DIMENSION(jpi,jpj) ::    fccd\par
      REAL(wp) ::    fccd_dep\par
      !! AXY (28/11/16): fix mbathy bug\par
      INTEGER  ::    jmbathy\par
      !!\par
      !! AXY (06/07/11): alternative fast detritus schemes\par
      REAL(wp) ::    fb_val, fl_sst\par
      !!\par
      !! AXY (08/07/11): fate of fast detritus reaching the seafloor\par
      REAL(wp) ::    ffast2slown,ffast2slowfe,ffast2slowc\par
      !!\par
      !! conservation law\par
      REAL(wp) ::    fnit0,fsil0,ffer0 \par
# if defined key_roam\par
      REAL(wp) ::    fcar0,falk0,foxy0 \par
# endif      \par
      !! \par
      !! temporary variables\par
      REAL(wp) ::    fq0,fq1,fq2,fq3,fq4,fq5,fq6,fq7,fq8,fq9\par
      !!\par
      !! water column nutrient and flux integrals\par
      REAL(wp), DIMENSION(jpi,jpj) ::    ftot_n,ftot_si,ftot_fe\par
      REAL(wp), DIMENSION(jpi,jpj) ::    fflx_n,fflx_si,fflx_fe\par
      REAL(wp), DIMENSION(jpi,jpj) ::    fifd_n,fifd_si,fifd_fe\par
      REAL(wp), DIMENSION(jpi,jpj) ::    fofd_n,fofd_si,fofd_fe\par
# if defined key_roam\par
      REAL(wp), DIMENSION(jpi,jpj) ::    ftot_c,ftot_a,ftot_o2\par
      REAL(wp), DIMENSION(jpi,jpj) ::    fflx_c,fflx_a,fflx_o2\par
      REAL(wp), DIMENSION(jpi,jpj) ::    fifd_c,fifd_a,fifd_o2\par
      REAL(wp), DIMENSION(jpi,jpj) ::    fofd_c,fofd_a,fofd_o2\par
# endif\par
      !!\par
      !! zooplankton grazing integrals\par
      REAL(wp), DIMENSION(jpi,jpj) ::    fzmi_i,fzmi_o,fzme_i,fzme_o\par
      !!\par
      !! limitation term temporary variables\par
      REAL(wp), DIMENSION(jpi,jpj) ::    ftot_pn,ftot_pd\par
      REAL(wp), DIMENSION(jpi,jpj) ::    ftot_zmi,ftot_zme,ftot_det,ftot_dtc\par
      !! use ballast scheme (1) or simple exponential scheme (0; a conservation test)\par
      INTEGER  ::    iball\par
      !! use biological fluxes (1) or not (0)\par
      INTEGER  ::    ibio_switch\par
      !!\par
      !! diagnose fluxes (should only be used in 1D runs)\par
      INTEGER  ::    idf, idfval\par
      !!\par
      !! nitrogen and silicon production and consumption\par
      REAL(wp) ::    fn_prod, fn_cons, fs_prod, fs_cons\par
      REAL(wp), DIMENSION(jpi,jpj) ::    fnit_prod, fnit_cons, fsil_prod, fsil_cons\par
# if defined key_roam\par
      !!\par
      !! flags to help with calculating the position of the CCD\par
      INTEGER, DIMENSION(jpi,jpj) ::     i2_omcal,i2_omarg\par
      !!\par
      !! ROAM air-sea flux and diagnostic parameters\par
      REAL(wp) ::    f_wind\par
      !! AXY (24/11/16): add xCO2 variable for atmosphere (what we actually have)\par
      REAL(wp) ::    f_xco2a\par
      REAL(wp) ::    f_ph, f_pco2w, f_h2co3, f_hco3, f_co3, f_co2flux\par
      REAL(wp) ::    f_TDIC, f_TALK, f_dcf, f_henry\par
      REAL(wp) ::    f_uwind, f_vwind, f_pp0\par
      REAL(wp) ::    f_kw660, f_o2flux, f_o2sat, f_o2sat3\par
      REAL(wp), DIMENSION(jpi,jpj) ::    f_omcal, f_omarg\par
      !!\par
      !! AXY (23/06/15): additional diagnostics for MOCSY and oxygen\par
      REAL(wp) ::    f_fco2w, f_BetaD, f_rhosw, f_opres, f_insitut, f_pco2atm, f_fco2atm\par
      REAL(wp) ::    f_schmidtco2, f_kwco2, f_K0, f_co2starair, f_dpco2, f_kwo2\par
      !! jpalm 14-07-2016: convert CO2flux diag from mmol/m2/d to kg/m2/s\par
      REAL, PARAMETER :: weight_CO2_mol = 44.0095  !! g / mol\par
      REAL, PARAMETER :: secs_in_day    = 86400.0  !! s / d\par
      REAL, PARAMETER :: CO2flux_conv   = (1.e-6 * weight_CO2_mol) / secs_in_day\par
\par
      !!\par
      INTEGER  ::    iters\par
      REAL(wp) ::    f_year\par
      INTEGER  ::    i_year\par
      INTEGER  ::    iyr1, iyr2\par
      !!\par
      !! carbon, alkalinity production and consumption\par
      REAL(wp) ::    fc_prod, fc_cons, fa_prod, fa_cons\par
      REAL(wp), DIMENSION(jpi,jpj) ::    fcomm_resp\par
      REAL(wp), DIMENSION(jpi,jpj) ::    fcar_prod, fcar_cons\par
      !!\par
      !! oxygen production and consumption (and non-consumption)\par
      REAL(wp) ::    fo2_prod, fo2_cons, fo2_ncons, fo2_ccons\par
      REAL(wp), DIMENSION(jpi,jpj) ::    foxy_prod, foxy_cons, foxy_anox\par
      !! Jpalm (11-08-2014)\par
      !! add DMS in MEDUSA for UKESM1 model\par
      REAL(wp) ::    dms_surf\par
      !! AXY (13/03/15): add in other DMS calculations\par
      REAL(wp) ::    dms_andr, dms_simo, dms_aran, dms_hall, dms_andm, dms_nlim, dms_wtkn\par
\par
# endif\par
      !! \par
      !! benthic fluxes\par
      INTEGER  ::    ibenthic\par
      REAL(wp), DIMENSION(jpi,jpj) :: f_sbenin_n, f_sbenin_fe,              f_sbenin_c\par
      REAL(wp), DIMENSION(jpi,jpj) :: f_fbenin_n, f_fbenin_fe, f_fbenin_si, f_fbenin_c, f_fbenin_ca\par
      REAL(wp), DIMENSION(jpi,jpj) :: f_benout_n, f_benout_fe, f_benout_si, f_benout_c, f_benout_ca\par
      REAL(wp) ::    zfact\par
      !! \par
      !! benthic fluxes of CaCO3 that shouldn't happen because of lysocline\par
      REAL(wp), DIMENSION(jpi,jpj) :: f_benout_lyso_ca\par
      !!\par
      !! riverine fluxes\par
      REAL(wp), DIMENSION(jpi,jpj) :: f_runoff, f_riv_n, f_riv_si, f_riv_c, f_riv_alk\par
      !! AXY (19/07/12): variables for local riverine fluxes to handle inputs below surface\par
      REAL(wp) ::    f_riv_loc_n, f_riv_loc_si, f_riv_loc_c, f_riv_loc_alk\par
      !!\par
      !! Jpalm -- 11-10-2015 -- adapt diag to iom_use\par
      !! 2D var for diagnostics.\par
      REAL(wp), POINTER, DIMENSION(:,:  ) :: fprn2d, fdpn2d, fprd2d, fdpd2d, fprds2d, fsdiss2d, fgmipn2d\par
      REAL(wp), POINTER, DIMENSION(:,:  ) :: fgmid2d, fdzmi2d, fgmepn2d, fgmepd2d, fgmezmi2d, fgmed2d\par
      REAL(wp), POINTER, DIMENSION(:,:  ) :: fdzme2d, fslown2d, fdd2d, ffetop2d, ffebot2d, ffescav2d\par
      REAL(wp), POINTER, DIMENSION(:,:  ) :: fjln2d, fnln2d, ffln2d, fjld2d, fnld2d, ffld2d, fsld2d2\par
      REAL(wp), POINTER, DIMENSION(:,:  ) :: fsld2d, fregen2d, fregensi2d, ftempn2d, ftempsi2d, ftempfe2d\par
      REAL(wp), POINTER, DIMENSION(:,:  ) :: ftempc2d, ftempca2d, freminn2d, freminsi2d, freminfe2d\par
      REAL(wp), POINTER, DIMENSION(:,:  ) :: freminc2d, freminca2d\par
      REAL(wp), POINTER, DIMENSION(:,:  ) :: zw2d\par
# if defined key_roam\par
      REAL(wp), POINTER, DIMENSION(:,:  ) :: ffastca2d, rivn2d, rivsi2d, rivc2d, rivalk2d, fslowc2d\par
      REAL(wp), POINTER, DIMENSION(:,:  ) :: fdpn22d, fdpd22d, fdzmi22d, fdzme22d, zimesn2d, zimesd2d\par
      REAL(wp), POINTER, DIMENSION(:,:  ) :: zimesc2d, zimesdc2d, ziexcr2d, ziresp2d, zigrow2d, zemesn2d\par
      REAL(wp), POINTER, DIMENSION(:,:  ) :: zemesd2d, zemesc2d, zemesdc2d, zeexcr2d, zeresp2d, zegrow2d\par
      REAL(wp), POINTER, DIMENSION(:,:  ) :: mdetc2d, gmidc2d, gmedc2d, f_pco2a2d, f_pco2w2d, f_co2flux2d\par
      REAL(wp), POINTER, DIMENSION(:,:  ) :: f_TDIC2d, f_TALK2d, f_kw6602d, f_pp02d, f_o2flux2d, f_o2sat2d\par
      REAL(wp), POINTER, DIMENSION(:,:  ) :: dms_andr2d, dms_simo2d, dms_aran2d, dms_hall2d, dms_andm2d, dms_surf2d\par
      REAL(wp), POINTER, DIMENSION(:,:  ) :: iben_n2d, iben_fe2d, iben_c2d, iben_si2d, iben_ca2d, oben_n2d\par
      REAL(wp), POINTER, DIMENSION(:,:  ) :: oben_fe2d, oben_c2d, oben_si2d, oben_ca2d, sfr_ocal2d\par
      REAL(wp), POINTER, DIMENSION(:,:  ) :: sfr_oarg2d, lyso_ca2d \par
      !! AXY (23/11/16): extra MOCSY diagnostics\par
      REAL(wp), POINTER, DIMENSION(:,:  ) :: f_xco2a_2d, f_fco2w_2d, f_fco2a_2d\par
      REAL(wp), POINTER, DIMENSION(:,:  ) :: f_ocnrhosw_2d, f_ocnschco2_2d, f_ocnkwco2_2d\par
      REAL(wp), POINTER, DIMENSION(:,:  ) :: f_ocnk0_2d, f_co2starair_2d, f_ocndpco2_2d\par
# endif\par
      !!\par
      !! 3D var for diagnostics.\par
      REAL(wp), POINTER, DIMENSION(:,:,:) :: tpp3d, detflux3d, remin3dn\par
      !!\par
# if defined key_roam\par
      !! AXY (04/11/16)\par
      !! 2D var for new CMIP6 diagnostics (behind a key_roam ifdef for simplicity)\par
      REAL(wp), POINTER, DIMENSION(:,:  ) :: fgco2, intdissic, intdissin, intdissisi, inttalk, o2min, zo2min\par
      REAL(wp), POINTER, DIMENSION(:,:  ) :: fbddtalk, fbddtdic, fbddtdife, fbddtdin, fbddtdisi\par
      !!\par
      !! 3D var for new CMIP6 diagnostics\par
      REAL(wp), POINTER, DIMENSION(:,:,:) :: tppd3\par
      REAL(wp), POINTER, DIMENSION(:,:,:) :: bddtalk3, bddtdic3, bddtdife3, bddtdin3, bddtdisi3\par
      REAL(wp), POINTER, DIMENSION(:,:,:) :: fd_nit3, fd_sil3, fd_car3, fd_cal3\par
      REAL(wp), POINTER, DIMENSION(:,:,:) :: co33, co3satarag3, co3satcalc3, dcalc3\par
      REAL(wp), POINTER, DIMENSION(:,:,:) :: expc3, expn3\par
      REAL(wp), POINTER, DIMENSION(:,:,:) :: fediss3, fescav3\par
      REAL(wp), POINTER, DIMENSION(:,:,:) :: migrazp3, migrazd3, megrazp3, megrazd3, megrazz3\par
      REAL(wp), POINTER, DIMENSION(:,:,:) :: o2sat3, pbsi3, pcal3, remoc3\par
      REAL(wp), POINTER, DIMENSION(:,:,:) :: pnlimj3, pnlimn3, pnlimfe3, pdlimj3, pdlimn3, pdlimfe3, pdlimsi3\par
# endif\par
      !!---------------------------------------------------------------------\par
\par
# if defined key_debug_medusa\par
      IF (lwp) write (numout,*) 'trc_bio_medusa: variables defined'\par
      CALL flush(numout)\par
# endif \par
\par
      !! AXY (20/11/14): alter this to report on first MEDUSA call\par
      !! IF( kt == nit000 ) THEN\par
      IF( kt == nittrc000 ) THEN\par
         IF(lwp) WRITE(numout,*)\par
         IF(lwp) WRITE(numout,*) ' trc_bio: MEDUSA bio-model'\par
         IF(lwp) WRITE(numout,*) ' ~~~~~~~'\par
\tab  IF(lwp) WRITE(numout,*) ' kt =',kt\par
      ENDIF\par
\par
      !! AXY (13/01/12): is benthic model properly interactive? 0 = no, 1 = yes\par
      ibenthic = 1\par
\par
      !! not sure what this is for; it's not used anywhere; commenting out\par
      !! fbodn(:,:) = 0.e0   \par
\par
      !!\par
      IF( ln_diatrc ) THEN\par
         !! blank 2D diagnostic array\par
         trc2d(:,:,:) = 0.e0\par
         !!\par
         !! blank 3D diagnostic array\par
         trc3d(:,:,:,:) = 0.e0\par
      ENDIF\par
\par
      !!----------------------------------------------------------------------\par
      !! b0 is present for debugging purposes; using b0 = 0 sets the tendency\par
      !! terms of all biological equations to 0.\par
      !!----------------------------------------------------------------------\par
      !!\par
      !! AXY (03/09/14): probably not the smartest move ever, but it'll fit\par
      !!                 the bill for now; another item on the things-to-sort-\par
      !!\tab\tab  out-in-the-future list ...\par
# if defined key_kill_medusa\par
      b0 = 0.\par
# else\par
      b0 = 1.\par
# endif\par
      !!----------------------------------------------------------------------\par
      !! fast detritus ballast scheme (0 = no; 1 = yes)\par
      !! alternative to ballast scheme is same scheme but with no ballast\par
      !! protection (not dissimilar to Martin et al., 1987)\par
      !!----------------------------------------------------------------------\par
      !!\par
      iball = 1\par
\par
      !!----------------------------------------------------------------------\par
      !! full flux diagnostics (0 = no; 1 = yes); appear in ocean.output\par
      !! these should *only* be used in 1D since they give comprehensive\par
      !! output for ecological functions in the model; primarily used in\par
      !! debugging\par
      !!----------------------------------------------------------------------\par
      !!\par
      idf    = 0\par
      !!\par
      !! timer mechanism\par
      if (kt/120*120.eq.kt) then\par
         idfval = 1\par
      else\par
         idfval = 0\par
      endif\par
\par
      !!----------------------------------------------------------------------\par
      !! blank fast-sinking detritus 2D fields\par
      !!----------------------------------------------------------------------\par
      !!\par
      ffastn(:,:)  = 0.0        !! organic nitrogen\par
      ffastsi(:,:) = 0.0        !! biogenic silicon\par
      ffastfe(:,:) = 0.0        !! organic iron\par
      ffastc(:,:)  = 0.0        !! organic carbon\par
      ffastca(:,:) = 0.0        !! biogenic calcium carbonate\par
      !!\par
      fsedn(:,:)   = 0.0        !! Seafloor flux of N \par
      fsedsi(:,:)  = 0.0        !! Seafloor flux of Si\par
      fsedfe(:,:)  = 0.0        !! Seafloor flux of Fe\par
      fsedc(:,:)   = 0.0        !! Seafloor flux of C\par
      fsedca(:,:)  = 0.0        !! Seafloor flux of CaCO3\par
      !!\par
      fregenfast(:,:)   = 0.0   !! integrated  N regeneration (fast detritus)\par
      fregenfastsi(:,:) = 0.0   !! integrated Si regeneration (fast detritus)\par
# if defined key_roam\par
      fregenfastc(:,:)  = 0.0   !! integrated  C regeneration (fast detritus)\par
# endif\par
      !!\par
      fccd(:,:)    = 0.0        !! last depth level before CCD\par
\par
      !!----------------------------------------------------------------------\par
      !! blank nutrient/flux inventories\par
      !!----------------------------------------------------------------------\par
      !!\par
      fflx_n(:,:)  = 0.0        !! nitrogen flux total\par
      fflx_si(:,:) = 0.0        !! silicon  flux total\par
      fflx_fe(:,:) = 0.0        !! iron     flux total\par
      fifd_n(:,:)  = 0.0        !! nitrogen fast detritus production\par
      fifd_si(:,:) = 0.0        !! silicon  fast detritus production\par
      fifd_fe(:,:) = 0.0        !! iron     fast detritus production\par
      fofd_n(:,:)  = 0.0        !! nitrogen fast detritus remineralisation\par
      fofd_si(:,:) = 0.0        !! silicon  fast detritus remineralisation\par
      fofd_fe(:,:) = 0.0        !! iron     fast detritus remineralisation\par
# if defined key_roam\par
      fflx_c(:,:)  = 0.0        !! carbon     flux total\par
      fflx_a(:,:)  = 0.0        !! alkalinity flux total\par
      fflx_o2(:,:) = 0.0        !! oxygen     flux total\par
      ftot_c(:,:)  = 0.0        !! carbon     inventory\par
      ftot_a(:,:)  = 0.0        !! alkalinity inventory\par
      ftot_o2(:,:) = 0.0        !! oxygen     inventory\par
      fifd_c(:,:)  = 0.0        !! carbon     fast detritus production\par
      fifd_a(:,:)  = 0.0        !! alkalinity fast detritus production\par
      fifd_o2(:,:) = 0.0        !! oxygen     fast detritus production\par
      fofd_c(:,:)  = 0.0        !! carbon     fast detritus remineralisation\par
      fofd_a(:,:)  = 0.0        !! alkalinity fast detritus remineralisation\par
      fofd_o2(:,:) = 0.0        !! oxygen     fast detritus remineralisation\par
      !!\par
      fnit_prod(:,:) = 0.0      !! (organic)   nitrogen production\par
      fnit_cons(:,:) = 0.0      !! (organic)   nitrogen consumption\par
      fsil_prod(:,:) = 0.0      !! (inorganic) silicon production\par
      fsil_cons(:,:) = 0.0      !! (inorganic) silicon consumption\par
      fcar_prod(:,:) = 0.0      !! (organic)   carbon production\par
      fcar_cons(:,:) = 0.0      !! (organic)   carbon consumption\par
      !!\par
      foxy_prod(:,:) = 0.0      !! oxygen production\par
      foxy_cons(:,:) = 0.0      !! oxygen consumption\par
      foxy_anox(:,:) = 0.0      !! unrealised oxygen consumption\par
      !!\par
# endif\par
      ftot_n(:,:)   = 0.0       !! N inventory \par
      ftot_si(:,:)  = 0.0       !! Si inventory\par
      ftot_fe(:,:)  = 0.0       !! Fe inventory\par
      ftot_pn(:,:)  = 0.0       !! integrated non-diatom phytoplankton\par
      ftot_pd(:,:)  = 0.0       !! integrated diatom     phytoplankton\par
      ftot_zmi(:,:) = 0.0       !! integrated microzooplankton\par
      ftot_zme(:,:) = 0.0       !! integrated mesozooplankton\par
      ftot_det(:,:) = 0.0       !! integrated slow detritus, nitrogen\par
      ftot_dtc(:,:) = 0.0       !! integrated slow detritus, carbon\par
      !!\par
      fzmi_i(:,:)  = 0.0        !! material grazed by microzooplankton\par
      fzmi_o(:,:)  = 0.0        !! ... sum of fate of this material\par
      fzme_i(:,:)  = 0.0        !! material grazed by  mesozooplankton\par
      fzme_o(:,:)  = 0.0        !! ... sum of fate of this material\par
      !!\par
      f_sbenin_n(:,:)  = 0.0    !! slow detritus N  -> benthic pool\par
      f_sbenin_fe(:,:) = 0.0    !! slow detritus Fe -> benthic pool\par
      f_sbenin_c(:,:)  = 0.0    !! slow detritus C  -> benthic pool\par
      f_fbenin_n(:,:)  = 0.0    !! fast detritus N  -> benthic pool\par
      f_fbenin_fe(:,:) = 0.0    !! fast detritus Fe -> benthic pool\par
      f_fbenin_si(:,:) = 0.0    !! fast detritus Si -> benthic pool\par
      f_fbenin_c(:,:)  = 0.0    !! fast detritus C  -> benthic pool\par
      f_fbenin_ca(:,:) = 0.0    !! fast detritus Ca -> benthic pool\par
      !!\par
      f_benout_n(:,:)  = 0.0    !! benthic N  pool  -> dissolved\par
      f_benout_fe(:,:) = 0.0    !! benthic Fe pool  -> dissolved\par
      f_benout_si(:,:) = 0.0    !! benthic Si pool  -> dissolved\par
      f_benout_c(:,:)  = 0.0    !! benthic C  pool  -> dissolved\par
      f_benout_ca(:,:) = 0.0    !! benthic Ca pool  -> dissolved\par
      !!\par
      f_benout_lyso_ca(:,:) = 0.0 !! benthic Ca pool  -> dissolved (when it shouldn't!)\par
      !!\par
      f_runoff(:,:)  = 0.0      !! riverine runoff\par
      f_riv_n(:,:)   = 0.0      !! riverine N   input \par
      f_riv_si(:,:)  = 0.0      !! riverine Si  input \par
      f_riv_c(:,:)   = 0.0      !! riverine C   input \par
      f_riv_alk(:,:) = 0.0      !! riverine alk input \par
      !! \par
      !! Jpalm -- 06-03-2017 -- Forgotten var to init\par
      f_omarg(:,:) = 0.0        !!\par
      f_omcal(:,:) = 0.0 \par
      xFree(:,:) = 0.0          !! state variables for iron-ligand system\par
      fcomm_resp(:,:) = 0.0 \par
      fprn_ml(:,:) = 0.0        !! mixed layer PP diagnostics\par
      fprd_ml(:,:) = 0.0        !! mixed layer PP diagnostics\par
      !!\par
      fslownflux(:,:) = 0.0\par
      fslowcflux(:,:) = 0.0\par
\par
# if defined key_foam_medusa\par
      pgrow_avg(:,:) = 0.0\par
      ploss_avg(:,:) = 0.0\par
      phyt_avg(:,:)  = 0.0\par
      IF( kt == nittrc000 ) THEN\par
         mld_max(:,:) = 0.0\par
      ENDIF\par
# endif\par
\par
      !!\par
      !! allocate and initiate 2D diag\par
      !! -----------------------------\par
      !! Juju :: add kt condition !!\par
      IF ( lk_iomput .AND. .NOT.  ln_diatrc ) THEN \par
         !!\par
         if ( kt == nittrc000 )   CALL trc_nam_iom_medusa !! initialise iom_use test\par
         !!\par
         CALL wrk_alloc( jpi, jpj,      zw2d )\par
         zw2d(:,:)      = 0.0   !!\par
         IF ( med_diag%PRN%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,   fprn2d    )\par
            fprn2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF ( med_diag%MPN%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,   fdpn2d    )\par
            fdpn2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF ( med_diag%PRD%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,   fprd2d    )\par
            fprd2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%MPD%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,   fdpd2d    )\par
            fdpd2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%OPAL%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,   fprds2d    )\par
            fprds2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%OPALDISS%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,   fsdiss2d    )\par
            fsdiss2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%GMIPn%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,   fgmipn2d    )\par
            fgmipn2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%GMID%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,   fgmid2d    )\par
            fgmid2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%MZMI%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,   fdzmi2d    )\par
            fdzmi2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%GMEPN%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,   fgmepn2d    )\par
            fgmepn2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%GMEPD%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,   fgmepd2d    )\par
            fgmepd2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%GMEZMI%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,   fgmezmi2d    )\par
            fgmezmi2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%GMED%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,   fgmed2d    )\par
            fgmed2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%MZME%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,   fdzme2d    )\par
            fdzme2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%DETN%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,   fslown2d    )\par
            fslown2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%MDET%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,   fdd2d    )\par
            fdd2d(:,:)      = 0.0 !!\par
         ENDIF      \par
         IF( med_diag%AEOLIAN%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,   ffetop2d    )\par
            ffetop2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%BENTHIC%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,    ffebot2d   )\par
            ffebot2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%SCAVENGE%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,   ffescav2d    )\par
            ffescav2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%PN_JLIM%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,   fjln2d    )\par
            fjln2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%PN_NLIM%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,   fnln2d    )\par
            fnln2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%PN_FELIM%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,   ffln2d    )\par
            ffln2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%PD_JLIM%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,   fjld2d    )\par
            fjld2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%PD_NLIM%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,   fnld2d    )\par
            fnld2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%PD_FELIM%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,   ffld2d    )\par
            ffld2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%PD_SILIM%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,   fsld2d2    )\par
            fsld2d2(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%PDSILIM2%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,   fsld2d    )\par
            fsld2d(:,:)      = 0.0 !!\par
         ENDIF\par
!!\par
!! skip SDT_XXXX diagnostics here\par
!!\par
         IF( med_diag%TOTREG_N%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,   fregen2d    )\par
            fregen2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%TOTRG_SI%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,   fregensi2d    )\par
            fregensi2d(:,:)      = 0.0 !!\par
         ENDIF\par
!!\par
!! skip REG_XXXX diagnostics here\par
!!\par
         IF( med_diag%FASTN%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,   ftempn2d    )\par
            ftempn2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%FASTSI%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,   ftempsi2d    )\par
            ftempsi2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%FASTFE%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,  ftempfe2d     )\par
            ftempfe2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%FASTC%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,  ftempc2d     )\par
            ftempc2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%FASTCA%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,   ftempca2d    )\par
            ftempca2d(:,:)      = 0.0 !!\par
         ENDIF     \par
!!\par
!! skip FDT_XXXX, RG_XXXXF, FDS_XXXX, RGS_XXXXF diagnostics here\par
!!\par
         IF( med_diag%REMINN%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,    freminn2d   )\par
            freminn2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%REMINSI%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,    freminsi2d   )\par
            freminsi2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%REMINFE%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,    freminfe2d   )\par
            freminfe2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%REMINC%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,   freminc2d    )\par
            freminc2d(:,:)      = 0.0 !! \par
         ENDIF\par
         IF( med_diag%REMINCA%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,   freminca2d    )\par
            freminca2d(:,:)      = 0.0 !!\par
         ENDIF\par
# if defined key_roam\par
!!\par
!! skip SEAFLRXX, MED_XXXX, INTFLX_XX, INT_XX, ML_XXX, OCAL_XXX, FE_XXXX, MED_XZE, WIND diagnostics here\par
!!\par
         IF( med_diag%RR_0100%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,    ffastca2d   )\par
            ffastca2d(:,:)      = 0.0 !!\par
         ENDIF\par
\par
         IF( med_diag%ATM_PCO2%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,    f_pco2a2d   )\par
            f_pco2a2d(:,:)      = 0.0 !!\par
         ENDIF\par
!!\par
!! skip OCN_PH diagnostic here\par
!!\par
         IF( med_diag%OCN_PCO2%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,    f_pco2w2d   )\par
            f_pco2w2d(:,:)      = 0.0 !!\par
         ENDIF\par
!!\par
!! skip OCNH2CO3, OCN_HCO3, OCN_CO3 diagnostics here\par
!!\par
         IF( med_diag%CO2FLUX%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,   f_co2flux2d    )\par
            f_co2flux2d(:,:)      = 0.0 !!\par
         ENDIF\par
!!\par
!! skip OM_XXX diagnostics here\par
!!\par
         IF( med_diag%TCO2%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,   f_TDIC2d    )\par
            f_TDIC2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%TALK%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,    f_TALK2d   )\par
            f_TALK2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%KW660%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,    f_kw6602d   )\par
            f_kw6602d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%ATM_PP0%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,    f_pp02d   )\par
            f_pp02d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%O2FLUX%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,   f_o2flux2d    )\par
            f_o2flux2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%O2SAT%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,    f_o2sat2d   )\par
            f_o2sat2d(:,:)      = 0.0 !!\par
         ENDIF \par
!!\par
!! skip XXX_CCD diagnostics here\par
!! \par
         IF( med_diag%SFR_OCAL%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,    sfr_ocal2d  )\par
            sfr_ocal2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%SFR_OARG%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,    sfr_oarg2d  )\par
            sfr_oarg2d(:,:)      = 0.0 !!\par
         ENDIF\par
!!\par
!! skip XX_PROD, XX_CONS, O2_ANOX, RR_XXXX diagnostics here\par
!! \par
         IF( med_diag%IBEN_N%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,    iben_n2d  )\par
            iben_n2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%IBEN_FE%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,   iben_fe2d   )\par
            iben_fe2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%IBEN_C%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,   iben_c2d   )\par
            iben_c2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%IBEN_SI%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,   iben_si2d   )\par
            iben_si2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%IBEN_CA%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,   iben_ca2d   )\par
            iben_ca2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%OBEN_N%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,    oben_n2d  )\par
            oben_n2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%OBEN_FE%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,    oben_fe2d  )\par
            oben_fe2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%OBEN_C%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,    oben_c2d  )\par
            oben_c2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%OBEN_SI%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,    oben_si2d  )\par
            oben_si2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%OBEN_CA%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,    oben_ca2d  )\par
            oben_ca2d(:,:)      = 0.0 !!\par
         ENDIF\par
!!\par
!! skip BEN_XX diagnostics here\par
!!\par
         IF( med_diag%RIV_N%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,    rivn2d   )\par
            rivn2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%RIV_SI%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,    rivsi2d   )\par
            rivsi2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%RIV_C%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,   rivc2d    )\par
            rivc2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%RIV_ALK%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,    rivalk2d   )\par
            rivalk2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%DETC%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,    fslowc2d   )\par
            fslowc2d(:,:)      = 0.0 !!\par
         ENDIF \par
!!\par
!! skip SDC_XXXX, INVTXXX diagnostics here\par
!!\par
         IF( med_diag%LYSO_CA%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,    lyso_ca2d  )\par
            lyso_ca2d(:,:)      = 0.0 !!\par
         ENDIF\par
!!\par
!! skip COM_RESP diagnostic here\par
!!\par
         IF( med_diag%PN_LLOSS%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,    fdpn22d   )\par
            fdpn22d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%PD_LLOSS%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,    fdpd22d   )\par
            fdpd22d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%ZI_LLOSS%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,    fdzmi22d   )\par
            fdzmi22d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%ZE_LLOSS%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,   fdzme22d    )\par
            fdzme22d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%ZI_MES_N%dgsave ) THEN   \par
            CALL wrk_alloc( jpi, jpj,   zimesn2d    )\par
            zimesn2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%ZI_MES_D%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,    zimesd2d   )\par
            zimesd2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%ZI_MES_C%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,    zimesc2d   )\par
            zimesc2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%ZI_MESDC%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,    zimesdc2d   )\par
            zimesdc2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%ZI_EXCR%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,     ziexcr2d  )\par
            ziexcr2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%ZI_RESP%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,    ziresp2d   )\par
            ziresp2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%ZI_GROW%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,    zigrow2d   )\par
            zigrow2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%ZE_MES_N%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,   zemesn2d    )\par
            zemesn2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%ZE_MES_D%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,    zemesd2d   )\par
            zemesd2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%ZE_MES_C%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,    zemesc2d   )\par
            zemesc2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%ZE_MESDC%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,    zemesdc2d   )\par
            zemesdc2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%ZE_EXCR%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,    zeexcr2d   )\par
            zeexcr2d(:,:)      = 0.0 !!\par
         ENDIF                  \par
         IF( med_diag%ZE_RESP%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,    zeresp2d   )\par
            zeresp2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%ZE_GROW%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,    zegrow2d   )\par
            zegrow2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%MDETC%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,   mdetc2d    )\par
            mdetc2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%GMIDC%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,    gmidc2d   )\par
            gmidc2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%GMEDC%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj,    gmedc2d   )\par
            gmedc2d(:,:)      = 0.0 !!\par
         ENDIF\par
!!\par
!! skip INT_XXX diagnostics here\par
!!\par
         IF (jdms .eq. 1) THEN\par
            IF( med_diag%DMS_SURF%dgsave ) THEN\par
               CALL wrk_alloc( jpi, jpj,   dms_surf2d    )\par
               dms_surf2d(:,:)      = 0.0 !!\par
            ENDIF\par
            IF( med_diag%DMS_ANDR%dgsave ) THEN\par
               CALL wrk_alloc( jpi, jpj,   dms_andr2d    )\par
               dms_andr2d(:,:)      = 0.0 !!\par
            ENDIF\par
            IF( med_diag%DMS_SIMO%dgsave ) THEN\par
               CALL wrk_alloc( jpi, jpj,  dms_simo2d     )\par
               dms_simo2d(:,:)      = 0.0 !!\par
            ENDIF\par
            IF( med_diag%DMS_ARAN%dgsave ) THEN\par
               CALL wrk_alloc( jpi, jpj,   dms_aran2d    )\par
               dms_aran2d(:,:)      = 0.0 !!\par
            ENDIF\par
            IF( med_diag%DMS_HALL%dgsave ) THEN\par
               CALL wrk_alloc( jpi, jpj,   dms_hall2d    )\par
               dms_hall2d(:,:)      = 0.0 !!\par
            ENDIF\par
            IF( med_diag%DMS_ANDM%dgsave ) THEN\par
               CALL wrk_alloc( jpi, jpj,   dms_andm2d    )\par
               dms_andm2d(:,:)      = 0.0 !!\par
            ENDIF\par
         ENDIF   \par
         !!\par
         !! AXY (24/11/16): extra MOCSY diagnostics, 2D\par
         IF( med_diag%ATM_XCO2%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj, f_xco2a_2d      )\par
            f_xco2a_2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%OCN_FCO2%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj, f_fco2w_2d      )\par
            f_fco2w_2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%ATM_FCO2%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj, f_fco2a_2d      )\par
            f_fco2a_2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%OCN_RHOSW%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj, f_ocnrhosw_2d   )\par
            f_ocnrhosw_2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%OCN_SCHCO2%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj, f_ocnschco2_2d  )\par
            f_ocnschco2_2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%OCN_KWCO2%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj, f_ocnkwco2_2d   )\par
            f_ocnkwco2_2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%OCN_K0%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj, f_ocnk0_2d      )\par
            f_ocnk0_2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%CO2STARAIR%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj, f_co2starair_2d )\par
            f_co2starair_2d(:,:)      = 0.0 !!\par
         ENDIF\par
         IF( med_diag%OCN_DPCO2%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj, f_ocndpco2_2d   )\par
            f_ocndpco2_2d(:,:)      = 0.0 !!\par
         ENDIF\par
# endif  \par
         IF( med_diag%TPP3%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj, jpk,       tpp3d )\par
            tpp3d(:,:,:)      = 0.0 !! \par
         ENDIF\par
         IF( med_diag%DETFLUX3%dgsave ) THEN\par
            CALL wrk_alloc( jpi, jpj, jpk,        detflux3d )\par
            detflux3d(:,:,:)      = 0.0 !! \par
         ENDIF\par
         IF( med_diag%REMIN3N%dgsave ) THEN\par
             CALL wrk_alloc( jpi, jpj, jpk,        remin3dn )\par
             remin3dn(:,:,:)      = 0.0 !! \par
          ENDIF\par
          !! \par
          !! AXY (10/11/16): CMIP6 diagnostics, 2D\par
          !! JPALM -- 17-11-16 -- put fgco2 alloc out of diag request\par
          !!                   needed for coupling/passed through restart\par
          !! IF( med_diag%FGCO2%dgsave ) THEN\par
             CALL wrk_alloc( jpi, jpj,   fgco2    )\par
             fgco2(:,:)      = 0.0 !!\par
          !! ENDIF\par
          IF( med_diag%INTDISSIC%dgsave ) THEN\par
             CALL wrk_alloc( jpi, jpj,   intdissic    )\par
             intdissic(:,:)  = 0.0 !!\par
          ENDIF          \par
          IF( med_diag%INTDISSIN%dgsave ) THEN\par
             CALL wrk_alloc( jpi, jpj,   intdissin    )\par
             intdissin(:,:)  = 0.0 !!\par
          ENDIF          \par
          IF( med_diag%INTDISSISI%dgsave ) THEN\par
             CALL wrk_alloc( jpi, jpj,   intdissisi    )\par
             intdissisi(:,:)  = 0.0 !!\par
          ENDIF          \par
          IF( med_diag%INTTALK%dgsave ) THEN\par
             CALL wrk_alloc( jpi, jpj,   inttalk    )\par
             inttalk(:,:)  = 0.0 !!\par
          ENDIF          \par
          IF( med_diag%O2min%dgsave ) THEN\par
             CALL wrk_alloc( jpi, jpj,   o2min    )\par
             o2min(:,:)  = 1.e3 !! set to high value as we're looking for min(o2)\par
          ENDIF          \par
          IF( med_diag%ZO2min%dgsave ) THEN\par
             CALL wrk_alloc( jpi, jpj,   zo2min    )\par
             zo2min(:,:)  = 0.0 !!\par
          ENDIF          \par
          IF( med_diag%FBDDTALK%dgsave  ) THEN\par
             CALL wrk_alloc( jpi, jpj, fbddtalk  )\par
             fbddtalk(:,:)  = 0.0 !! \par
          ENDIF\par
          IF( med_diag%FBDDTDIC%dgsave  ) THEN\par
             CALL wrk_alloc( jpi, jpj, fbddtdic  )\par
             fbddtdic(:,:)  = 0.0 !! \par
          ENDIF\par
          IF( med_diag%FBDDTDIFE%dgsave ) THEN\par
             CALL wrk_alloc( jpi, jpj, fbddtdife )\par
             fbddtdife(:,:) = 0.0 !! \par
          ENDIF\par
          IF( med_diag%FBDDTDIN%dgsave  ) THEN\par
             CALL wrk_alloc( jpi, jpj, fbddtdin  )\par
             fbddtdin(:,:)  = 0.0 !! \par
          ENDIF\par
          IF( med_diag%FBDDTDISI%dgsave ) THEN\par
             CALL wrk_alloc( jpi, jpj, fbddtdisi )\par
             fbddtdisi(:,:) = 0.0 !! \par
          ENDIF\par
          !! \par
          !! AXY (10/11/16): CMIP6 diagnostics, 3D\par
          IF( med_diag%TPPD3%dgsave     ) THEN\par
             CALL wrk_alloc( jpi, jpj, jpk, tppd3     )\par
             tppd3(:,:,:)     = 0.0 !! \par
          ENDIF\par
          IF( med_diag%BDDTALK3%dgsave  ) THEN\par
             CALL wrk_alloc( jpi, jpj, jpk, bddtalk3  )\par
             bddtalk3(:,:,:)  = 0.0 !! \par
          ENDIF\par
          IF( med_diag%BDDTDIC3%dgsave  ) THEN\par
             CALL wrk_alloc( jpi, jpj, jpk, bddtdic3  )\par
             bddtdic3(:,:,:)  = 0.0 !! \par
          ENDIF\par
          IF( med_diag%BDDTDIFE3%dgsave ) THEN\par
             CALL wrk_alloc( jpi, jpj, jpk, bddtdife3 )\par
             bddtdife3(:,:,:) = 0.0 !! \par
          ENDIF\par
          IF( med_diag%BDDTDIN3%dgsave  ) THEN\par
             CALL wrk_alloc( jpi, jpj, jpk, bddtdin3  )\par
             bddtdin3(:,:,:)  = 0.0 !! \par
          ENDIF\par
          IF( med_diag%BDDTDISI3%dgsave ) THEN\par
             CALL wrk_alloc( jpi, jpj, jpk, bddtdisi3 )\par
             bddtdisi3(:,:,:) = 0.0 !! \par
          ENDIF\par
          IF( med_diag%FD_NIT3%dgsave   ) THEN\par
             CALL wrk_alloc( jpi, jpj, jpk, fd_nit3   )\par
             fd_nit3(:,:,:)   = 0.0 !! \par
          ENDIF\par
          IF( med_diag%FD_SIL3%dgsave   ) THEN\par
             CALL wrk_alloc( jpi, jpj, jpk, fd_sil3   )\par
             fd_sil3(:,:,:)   = 0.0 !! \par
          ENDIF\par
          IF( med_diag%FD_CAR3%dgsave   ) THEN\par
             CALL wrk_alloc( jpi, jpj, jpk, fd_car3   )\par
             fd_car3(:,:,:)   = 0.0 !! \par
          ENDIF\par
          IF( med_diag%FD_CAL3%dgsave   ) THEN\par
             CALL wrk_alloc( jpi, jpj, jpk, fd_cal3   )\par
             fd_cal3(:,:,:)   = 0.0 !! \par
          ENDIF\par
          IF( med_diag%DCALC3%dgsave    ) THEN\par
             CALL wrk_alloc( jpi, jpj, jpk, dcalc3    )\par
             dcalc3(:,:,: )   = 0.0 !! \par
          ENDIF\par
          IF( med_diag%EXPC3%dgsave     ) THEN\par
             CALL wrk_alloc( jpi, jpj, jpk, expc3   )\par
             expc3(:,:,: )    = 0.0 !! \par
          ENDIF\par
          IF( med_diag%EXPN3%dgsave     ) THEN\par
             CALL wrk_alloc( jpi, jpj, jpk, expn3   )\par
             expn3(:,:,: )    = 0.0 !! \par
          ENDIF\par
          IF( med_diag%FEDISS3%dgsave   ) THEN\par
             CALL wrk_alloc( jpi, jpj, jpk, fediss3   )\par
             fediss3(:,:,: )  = 0.0 !! \par
          ENDIF\par
          IF( med_diag%FESCAV3%dgsave   ) THEN\par
             CALL wrk_alloc( jpi, jpj, jpk, fescav3   )\par
             fescav3(:,:,: )  = 0.0 !! \par
          ENDIF\par
          IF( med_diag%MIGRAZP3%dgsave   ) THEN\par
             CALL wrk_alloc( jpi, jpj, jpk, migrazp3  )\par
             migrazp3(:,:,: )  = 0.0 !! \par
          ENDIF\par
          IF( med_diag%MIGRAZD3%dgsave   ) THEN\par
             CALL wrk_alloc( jpi, jpj, jpk, migrazd3  )\par
             migrazd3(:,:,: )  = 0.0 !! \par
          ENDIF\par
          IF( med_diag%MEGRAZP3%dgsave   ) THEN\par
             CALL wrk_alloc( jpi, jpj, jpk, megrazp3  )\par
             megrazp3(:,:,: )  = 0.0 !! \par
          ENDIF\par
          IF( med_diag%MEGRAZD3%dgsave   ) THEN\par
             CALL wrk_alloc( jpi, jpj, jpk, megrazd3  )\par
             megrazd3(:,:,: )  = 0.0 !! \par
          ENDIF\par
          IF( med_diag%MEGRAZZ3%dgsave   ) THEN\par
             CALL wrk_alloc( jpi, jpj, jpk, megrazz3  )\par
             megrazz3(:,:,: )  = 0.0 !! \par
          ENDIF\par
          IF( med_diag%O2SAT3%dgsave     ) THEN\par
             CALL wrk_alloc( jpi, jpj, jpk, o2sat3    )\par
             o2sat3(:,:,: )    = 0.0 !! \par
          ENDIF\par
          IF( med_diag%PBSI3%dgsave      ) THEN\par
             CALL wrk_alloc( jpi, jpj, jpk, pbsi3     )\par
             pbsi3(:,:,: )     = 0.0 !! \par
          ENDIF\par
          IF( med_diag%PCAL3%dgsave      ) THEN\par
             CALL wrk_alloc( jpi, jpj, jpk, pcal3     )\par
             pcal3(:,:,: )     = 0.0 !! \par
          ENDIF\par
          IF( med_diag%REMOC3%dgsave     ) THEN\par
             CALL wrk_alloc( jpi, jpj, jpk, remoc3    )\par
             remoc3(:,:,: )    = 0.0 !! \par
          ENDIF\par
          IF( med_diag%PNLIMJ3%dgsave    ) THEN\par
             CALL wrk_alloc( jpi, jpj, jpk, pnlimj3   )\par
             pnlimj3(:,:,: )   = 0.0 !! \par
          ENDIF\par
          IF( med_diag%PNLIMN3%dgsave    ) THEN\par
             CALL wrk_alloc( jpi, jpj, jpk, pnlimn3   )\par
             pnlimn3(:,:,: )   = 0.0 !! \par
          ENDIF\par
          IF( med_diag%PNLIMFE3%dgsave   ) THEN\par
             CALL wrk_alloc( jpi, jpj, jpk, pnlimfe3  )\par
             pnlimfe3(:,:,: )  = 0.0 !! \par
          ENDIF\par
          IF( med_diag%PDLIMJ3%dgsave    ) THEN\par
             CALL wrk_alloc( jpi, jpj, jpk, pdlimj3   )\par
             pdlimj3(:,:,: )   = 0.0 !! \par
          ENDIF\par
          IF( med_diag%PDLIMN3%dgsave    ) THEN\par
             CALL wrk_alloc( jpi, jpj, jpk, pdlimn3   )\par
             pdlimn3(:,:,: )   = 0.0 !! \par
          ENDIF\par
          IF( med_diag%PDLIMFE3%dgsave   ) THEN\par
             CALL wrk_alloc( jpi, jpj, jpk, pdlimfe3  )\par
             pdlimfe3(:,:,: )  = 0.0 !! \par
          ENDIF\par
          IF( med_diag%PDLIMSI3%dgsave   ) THEN\par
             CALL wrk_alloc( jpi, jpj, jpk, pdlimsi3  )\par
             pdlimsi3(:,:,: )  = 0.0 !! \par
          ENDIF\par
\par
       ENDIF\par
       !! lk_iomput                                   \par
       !!\par
# if defined key_axy_nancheck\par
       DO jn = 1,jptra\par
          !! fq0 = MINVAL(trn(:,:,:,jn))\par
          !! fq1 = MAXVAL(trn(:,:,:,jn))\par
          fq2 = SUM(trn(:,:,:,jn))\par
          !! if (lwp) write (numout,'(a,2i6,3(1x,1pe15.5))') 'NAN-CHECK', &\par
          !! &        kt, jn, fq0, fq1, fq2\par
          !! AXY (30/01/14): much to our surprise, the next line doesn't work on HECTOR\par
          !!                 and has been replaced here with a specialist routine\par
          !! if (fq2 /= fq2 ) then\par
          if ( ieee_is_nan( fq2 ) ) then\par
             !! there's a NaN here\par
             if (lwp) write(numout,*) 'NAN detected in field', jn, 'at time', kt, 'at position:'\par
             DO jk = 1,jpk\par
                DO jj = 1,jpj\par
                   DO ji = 1,jpi\par
                      !! AXY (30/01/14): "isnan" problem on HECTOR\par
                      !! if (trn(ji,jj,jk,jn) /= trn(ji,jj,jk,jn)) then\par
                      if ( ieee_is_nan( trn(ji,jj,jk,jn) ) ) then\par
                         if (lwp) write (numout,'(a,1pe12.2,4i6)') 'NAN-CHECK', &\par
                         &        tmask(ji,jj,jk), ji, jj, jk, jn\par
                      endif\par
                   enddo\par
                enddo\par
             enddo\par
             CALL ctl_stop( 'trcbio_medusa, NAN in incoming tracer field' )\par
          endif\par
       ENDDO\par
       CALL flush(numout)\par
# endif\par
\par
# if defined key_debug_medusa\par
      IF (lwp) write (numout,*) 'trc_bio_medusa: variables initialised and checked'\par
      CALL flush(numout)\par
# endif \par
\par
# if defined key_roam\par
      !!----------------------------------------------------------------------\par
      !! calculate atmospheric pCO2\par
      !!----------------------------------------------------------------------\par
      !!\par
      !! what's atmospheric pCO2 doing? (data start in 1859)\par
      iyr1  = nyear - 1859 + 1\par
      iyr2  = iyr1 + 1\par
      if (iyr1 .le. 1) then\par
         !! before 1860\par
         f_xco2a = hist_pco2(1)\par
      elseif (iyr2 .ge. 242) then\par
         !! after 2099\par
         f_xco2a = hist_pco2(242)\par
      else\par
         !! just right\par
         fq0 = hist_pco2(iyr1)\par
         fq1 = hist_pco2(iyr2)\par
         fq2 = real(nsec_day) / (60.0 * 60.0 * 24.0)\par
         !! AXY (14/06/12): tweaked to make more sense (and be correct)\par
#  if defined key_bs_axy_yrlen\par
         fq3 = (real(nday_year) - 1.0 + fq2) / 360.0  !! bugfix: for 360d year with HadGEM2-ES forcing\par
#  else\par
         fq3 = (real(nday_year) - 1.0 + fq2) / 365.0  !! original use of 365 days (not accounting for leap year or 360d year)\par
#  endif\par
         fq4 = (fq0 * (1.0 - fq3)) + (fq1 * fq3)\par
         f_xco2a = fq4\par
      endif\par
#  if defined key_axy_pi_co2\par
      !! f_xco2a = 284.725       !! CMIP5 pre-industrial pCO2\par
      f_xco2a = 284.317          !! CMIP6 pre-industrial pCO2\par
#  endif\par
      !! IF(lwp) WRITE(numout,*) ' MEDUSA nyear     =', nyear\par
      !! IF(lwp) WRITE(numout,*) ' MEDUSA nsec_day  =', real(nsec_day)\par
      !! IF(lwp) WRITE(numout,*) ' MEDUSA nday_year =', real(nday_year)\par
      !! AXY (29/01/14): remove surplus diagnostics\par
      !! IF(lwp) WRITE(numout,*) ' MEDUSA fq0       =', fq0\par
      !! IF(lwp) WRITE(numout,*) ' MEDUSA fq1       =', fq1\par
      !! IF(lwp) WRITE(numout,*) ' MEDUSA fq2       =', fq2\par
      !! IF(lwp) WRITE(numout,*) ' MEDUSA fq3       =', fq3\par
      IF(lwp) WRITE(numout,*) ' MEDUSA atm pCO2  =', f_xco2a\par
# endif\par
\par
# if defined key_debug_medusa\par
      IF (lwp) write (numout,*) 'trc_bio_medusa: ready for carbonate chemistry'\par
      IF (lwp) write (numout,*) 'trc_bio_medusa: kt = ', kt\par
      IF (lwp) write (numout,*) 'trc_bio_medusa: nittrc000 = ', nittrc000\par
      CALL flush(numout)\par
# endif \par
\par
# if defined key_roam\par
      !! AXY (20/11/14): alter to call on first MEDUSA timestep and then every\par
      !!                 month (this is hardwired as 960 timesteps but should\par
      !!                 be calculated and done properly\par
      !! IF( kt == nit000 .or. mod(kt,1920) == 0 ) THEN\par
      !! IF( kt == nittrc000 .or. mod(kt,960) == 0 ) THEN \par
      !!=============================\par
      !! Jpalm -- 07-10-2016 -- need to change carb-chem frequency call :\par
      !!          we don't want to call on the first time-step of all run submission, \par
      !!          but only on the very first time-step, and then every month\par
      !!          So we call on nittrc000 if not restarted run, \par
      !!          else if one month after last call.\par
      !!          assume one month is 30d --> 3600*24*30 : 2592000s\par
      !!          try to call carb-chem at 1st month's tm-stp : x * 30d + 1*rdt(i.e: mod = rdt)   \par
      !!          ++ need to pass carb-chem output var through restarts\par
      !! We want this to be start of month or if starting afresh from \par
      !! climatology - marc 20/6/17\par
#if defined key_foam_medusa\par
      !! DAF (Aug 2017): For FOAM we want to run daily\par
      If ( (kt == nittrc000 .AND. .NOT.ln_rsttr) .OR.                        &\par
           (mod(kt*rdt,86400.) == rdt) ) THEN\par
#else\par
      If ( (kt == nittrc000 .AND. .NOT.ln_rsttr) .OR.                        &\par
           ((86400*mod(nn_date0,100) + mod(kt*rdt,2592000.)) == rdt) ) THEN\par
#endif\par
         !!----------------------------------------------------------------------\par
         !! Calculate the carbonate chemistry for the whole ocean on the first\par
         !! simulation timestep and every month subsequently; the resulting 3D\par
         !! field of omega calcite is used to determine the depth of the CCD\par
         !!----------------------------------------------------------------------\par
         !!\par
         IF(lwp) WRITE(numout,*) ' MEDUSA calculating all carbonate chemistry at kt =', kt\par
         CALL flush(numout)\par
         !! blank flags\par
         i2_omcal(:,:) = 0\par
         i2_omarg(:,:) = 0\par
         !! loop over 3D space\par
         DO jk = 1,jpk\par
            DO jj = 2,jpjm1\par
               DO ji = 2,jpim1\par
                  !! OPEN wet point IF..THEN loop\par
                  if (tmask(ji,jj,jk).eq.1) then\par
                     IF (lk_oasis) THEN\par
                        f_xco2a = PCO2a_in_cpl(ji,jj)        !! use 2D atm xCO2 from atm coupling\par
                     ENDIF\par
                     !! do carbonate chemistry\par
                     !!\par
                     fdep2 = fsdept(ji,jj,jk)           !! set up level midpoint\par
                     !! AXY (28/11/16): local seafloor depth\par
                     !!                 previously mbathy(ji,jj) - 1, now mbathy(ji,jj)\par
                     jmbathy = mbathy(ji,jj)\par
                     !!\par
                     !! set up required state variables\par
                     zdic = max(0.,trn(ji,jj,jk,jpdic)) !! dissolved inorganic carbon\par
                     zalk = max(0.,trn(ji,jj,jk,jpalk)) !! alkalinity\par
                     ztmp = tsn(ji,jj,jk,jp_tem)        !! temperature\par
                     zsal = tsn(ji,jj,jk,jp_sal)        !! salinity\par
#  if defined key_mocsy\par
                     zsil = max(0.,trn(ji,jj,jk,jpsil))        !! silicic acid\par
                     zpho = max(0.,trn(ji,jj,jk,jpdin)) / 16.0 !! phosphate via DIN and Redfield\par
#  endif\par
\tab\tab      !!\par
\tab\tab      !! AXY (28/02/14): check input fields\par
\tab\tab      if (ztmp .lt. -3.0 .or. ztmp .gt. 40.0 ) then\par
                        IF(lwp) WRITE(numout,*) ' trc_bio_medusa: T WARNING 3D, ', &\par
                        tsb(ji,jj,jk,jp_tem), tsn(ji,jj,jk,jp_tem), ' at (',    &\par
                        ji, ',', jj, ',', jk, ') at time', kt\par
\tab\tab\tab IF(lwp) WRITE(numout,*) ' trc_bio_medusa: T SWITCHING 3D, ', &\par
\tab\tab\tab tsn(ji,jj,jk,jp_tem), ' -> ', tsb(ji,jj,jk,jp_tem)\par
                        ztmp = tsb(ji,jj,jk,jp_tem)     !! temperature\par
                     endif\par
\tab\tab      if (zsal .lt. 0.0 .or. zsal .gt. 45.0 ) then\par
                        IF(lwp) WRITE(numout,*) ' trc_bio_medusa: S WARNING 3D, ', &\par
                        tsb(ji,jj,jk,jp_sal), tsn(ji,jj,jk,jp_sal), ' at (',    &\par
                        ji, ',', jj, ',', jk, ') at time', kt\par
                     endif\par
                     !!\par
                     !! blank input variables not used at this stage (they relate to air-sea flux)\par
                     f_kw660 = 1.0\par
                     f_pp0   = 1.0\par
                     !!\par
                     !! calculate carbonate chemistry at grid cell midpoint\par
#  if defined key_mocsy\par
                     !! AXY (22/06/15): use Orr & Epitalon (2015) MOCSY-2 carbonate\par
                     !!                 chemistry package\par
                     CALL mocsy_interface( ztmp, zsal, zalk, zdic, zsil, zpho,         &    ! inputs\par
                     f_pp0, fdep2, gphit(ji,jj), f_kw660, f_xco2a, 1,                  &    ! inputs\par
                     f_ph, f_pco2w, f_fco2w, f_h2co3, f_hco3, f_co3, f_omarg(ji,jj),   &    ! outputs\par
                     f_omcal(ji,jj), f_BetaD, f_rhosw, f_opres, f_insitut,             &    ! outputs\par
                     f_pco2atm, f_fco2atm, f_schmidtco2, f_kwco2, f_K0,                &    ! outputs\par
                     f_co2starair, f_co2flux, f_dpco2 )                                     ! outputs\par
                     !!\par
                     f_TDIC = (zdic / f_rhosw) * 1000. ! mmol / m3 -> umol / kg\par
                     f_TALK = (zalk / f_rhosw) * 1000. !  meq / m3 ->  ueq / kg\par
                     f_dcf  = f_rhosw\par
#  else\par
                     !! AXY (22/06/15): use old PML carbonate chemistry package (the\par
                     !!                 MEDUSA-2 default)\par
                     CALL trc_co2_medusa( ztmp, zsal, zdic, zalk, fdep2, f_kw660,      &    ! inputs\par
                     f_xco2a, f_ph, f_pco2w, f_h2co3, f_hco3, f_co3, f_omcal(ji,jj),   &    ! outputs\par
                     f_omarg(ji,jj), f_co2flux, f_TDIC, f_TALK, f_dcf, f_henry, iters)      ! outputs\par
                     !! \par
                     !! AXY (28/02/14): check output fields\par
                     if (iters .eq. 25) then\par
                        IF(lwp) WRITE(numout,*) ' trc_bio_medusa: 3D ITERS WARNING, ', &\par
                        iters, ' AT (', ji, ', ', jj, ', ', jk, ') AT ', kt\par
                     endif\par
#  endif\par
                     !!\par
                     !! store 3D outputs\par
                     f3_pH(ji,jj,jk)    = f_ph\par
                     f3_h2co3(ji,jj,jk) = f_h2co3\par
                     f3_hco3(ji,jj,jk)  = f_hco3\par
                     f3_co3(ji,jj,jk)   = f_co3\par
                     f3_omcal(ji,jj,jk) = f_omcal(ji,jj)\par
                     f3_omarg(ji,jj,jk) = f_omarg(ji,jj)\par
                     !!\par
                     !! CCD calculation: calcite\par
                     if (i2_omcal(ji,jj) .eq. 0 .and. f_omcal(ji,jj) .lt. 1.0) then\par
                        if (jk .eq. 1) then\par
                           f2_ccd_cal(ji,jj) = fdep2\par
                        else\par
                           fq0 = f3_omcal(ji,jj,jk-1) - f_omcal(ji,jj)\par
                           fq1 = f3_omcal(ji,jj,jk-1) - 1.0\par
                           fq2 = fq1 / (fq0 + tiny(fq0))\par
                           fq3 = fdep2 - fsdept(ji,jj,jk-1)\par
                           fq4 = fq2 * fq3\par
                           f2_ccd_cal(ji,jj) = fsdept(ji,jj,jk-1) + fq4\par
                        endif\par
                        i2_omcal(ji,jj)   = 1\par
                     endif\par
                     if ( i2_omcal(ji,jj) .eq. 0 .and. jk .eq. jmbathy ) then\par
                        !! reached seafloor and still no dissolution; set to seafloor (W-point)\par
                        f2_ccd_cal(ji,jj) = fsdepw(ji,jj,jk+1)\par
                        i2_omcal(ji,jj)   = 1\par
                     endif\par
                     !!\par
                     !! CCD calculation: aragonite\par
                     if (i2_omarg(ji,jj) .eq. 0 .and. f_omarg(ji,jj) .lt. 1.0) then\par
                        if (jk .eq. 1) then\par
                           f2_ccd_arg(ji,jj) = fdep2\par
                        else\par
                           fq0 = f3_omarg(ji,jj,jk-1) - f_omarg(ji,jj)\par
                           fq1 = f3_omarg(ji,jj,jk-1) - 1.0\par
                           fq2 = fq1 / (fq0 + tiny(fq0))\par
                           fq3 = fdep2 - fsdept(ji,jj,jk-1)\par
                           fq4 = fq2 * fq3\par
                           f2_ccd_arg(ji,jj) = fsdept(ji,jj,jk-1) + fq4\par
                        endif\par
                        i2_omarg(ji,jj)   = 1\par
                     endif\par
                     if ( i2_omarg(ji,jj) .eq. 0 .and. jk .eq. jmbathy ) then\par
                        !! reached seafloor and still no dissolution; set to seafloor (W-point)\par
                        f2_ccd_arg(ji,jj) = fsdepw(ji,jj,jk+1)\par
                        i2_omarg(ji,jj)   = 1\par
                     endif\par
                  endif\par
               ENDDO\par
            ENDDO\par
         ENDDO\par
      ENDIF\par
# endif\par
\par
# if defined key_debug_medusa\par
      IF (lwp) write (numout,*) 'trc_bio_medusa: ready for full domain calculations'\par
      CALL flush(numout)\par
# endif \par
\par
      !!----------------------------------------------------------------------\par
      !! MEDUSA has unified equation through the water column\par
      !! (Diff. from LOBSTER which has two sets: bio- and non-bio layers) \par
      !! Statement below in LOBSTER is different: DO jk = 1, jpkbm1          \par
      !!----------------------------------------------------------------------\par
      !!\par
      !! NOTE: the ordering of the loops below differs from that of some other\par
      !! models; looping over the vertical dimension is the outermost loop and\par
      !! this complicates some calculations (e.g. storage of vertical fluxes\par
      !! that can otherwise be done via a singular variable require 2D fields\par
      !! here); however, these issues are relatively easily resolved, but the\par
      !! loops CANNOT be reordered without potentially causing code efficiency\par
      !! problems (e.g. array indexing means that reordering the loops would\par
      !! require skipping between widely-spaced memory location; potentially\par
      !! outside those immediately cached)\par
      !!\par
      !! OPEN vertical loop\par
      DO jk = 1,jpk\par
         !! OPEN horizontal loops\par
         DO jj = 2,jpjm1\par
         DO ji = 2,jpim1\par
            !! OPEN wet point IF..THEN loop\par
            if (tmask(ji,jj,jk).eq.1) then               \par
               !!======================================================================\par
               !! SETUP LOCAL GRID CELL\par
               !!======================================================================\par
               !!\par
               !!---------------------------------------------------------------------\par
               !! Some notes on grid vertical structure\par
               !! - fsdepw(ji,jj,jk) is the depth of the upper surface of level jk\par
               !! - fsde3w(ji,jj,jk) is *approximately* the midpoint of level jk\par
               !! - fse3t(ji,jj,jk)  is the thickness of level jk\par
               !!---------------------------------------------------------------------\par
               !!\par
               !! AXY (11/12/08): set up level thickness\par
               fthk  = fse3t(ji,jj,jk)\par
               !! AXY (25/02/10): set up level depth (top of level)\par
               fdep  = fsdepw(ji,jj,jk)\par
               !! AXY (01/03/10): set up level depth (bottom of level)\par
               fdep1 = fdep + fthk\par
               !! AXY (28/11/16): local seafloor depth\par
               !!                 previously mbathy(ji,jj) - 1, now mbathy(ji,jj)\par
               jmbathy = mbathy(ji,jj)\par
               !!\par
               !! set up model tracers\par
               !! negative values of state variables are not allowed to\par
               !! contribute to the calculated fluxes\par
               zchn = max(0.,trn(ji,jj,jk,jpchn)) !! non-diatom chlorophyll\par
               zchd = max(0.,trn(ji,jj,jk,jpchd)) !! diatom chlorophyll\par
               zphn = max(0.,trn(ji,jj,jk,jpphn)) !! non-diatoms\par
               zphd = max(0.,trn(ji,jj,jk,jpphd)) !! diatoms\par
               zpds = max(0.,trn(ji,jj,jk,jppds)) !! diatom silicon\par
               !! AXY (28/01/10): probably need to take account of chl/biomass connection\par
               if (zchn.eq.0.) zphn = 0.\par
               if (zchd.eq.0.) zphd = 0.\par
               if (zphn.eq.0.) zchn = 0.\par
               if (zphd.eq.0.) zchd = 0.\par
\tab        !! AXY (23/01/14): duh - why did I forget diatom silicon?\par
\tab        if (zpds.eq.0.) zphd = 0.\par
\tab        if (zphd.eq.0.) zpds = 0.\par
               zzmi = max(0.,trn(ji,jj,jk,jpzmi)) !! microzooplankton\par
               zzme = max(0.,trn(ji,jj,jk,jpzme)) !! mesozooplankton\par
               zdet = max(0.,trn(ji,jj,jk,jpdet)) !! detrital nitrogen\par
               zdin = max(0.,trn(ji,jj,jk,jpdin)) !! dissolved inorganic nitrogen\par
               zsil = max(0.,trn(ji,jj,jk,jpsil)) !! dissolved silicic acid\par
               zfer = max(0.,trn(ji,jj,jk,jpfer)) !! dissolved "iron"\par
# if defined key_roam\par
               zdtc = max(0.,trn(ji,jj,jk,jpdtc)) !! detrital carbon\par
               zdic = max(0.,trn(ji,jj,jk,jpdic)) !! dissolved inorganic carbon\par
               zalk = max(0.,trn(ji,jj,jk,jpalk)) !! alkalinity\par
               zoxy = max(0.,trn(ji,jj,jk,jpoxy)) !! oxygen\par
#  if defined key_axy_carbchem && defined key_mocsy\par
               zpho = max(0.,trn(ji,jj,jk,jpdin)) / 16.0 !! phosphate via DIN and Redfield\par
#  endif\par
               !!\par
               !! also need physical parameters for gas exchange calculations\par
               ztmp = tsn(ji,jj,jk,jp_tem)\par
               zsal = tsn(ji,jj,jk,jp_sal)\par
               !!\par
\tab        !! AXY (28/02/14): check input fields\par
               if (ztmp .lt. -3.0 .or. ztmp .gt. 40.0 ) then\par
                  IF(lwp) WRITE(numout,*) ' trc_bio_medusa: T WARNING 2D, ', &\par
                  tsb(ji,jj,jk,jp_tem), tsn(ji,jj,jk,jp_tem), ' at (',    &\par
                  ji, ',', jj, ',', jk, ') at time', kt\par
\tab\tab   IF(lwp) WRITE(numout,*) ' trc_bio_medusa: T SWITCHING 2D, ', &\par
                  tsn(ji,jj,jk,jp_tem), ' -> ', tsb(ji,jj,jk,jp_tem)\par
                  ztmp = tsb(ji,jj,jk,jp_tem) !! temperature\par
               endif\par
               if (zsal .lt. 0.0 .or. zsal .gt. 45.0 ) then\par
                  IF(lwp) WRITE(numout,*) ' trc_bio_medusa: S WARNING 2D, ', &\par
                  tsb(ji,jj,jk,jp_sal), tsn(ji,jj,jk,jp_sal), ' at (',    &\par
                  ji, ',', jj, ',', jk, ') at time', kt\par
               endif\par
# else\par
               zdtc = zdet * xthetad              !! implicit detrital carbon\par
# endif\par
# if defined key_debug_medusa\par
               if (idf.eq.1) then\par
               !! AXY (15/01/10)\par
                  if (trn(ji,jj,jk,jpdin).lt.0.) then\par
                     IF (lwp) write (numout,*) '------------------------------'\par
                     IF (lwp) write (numout,*) 'NEGATIVE DIN ERROR =', trn(ji,jj,jk,jpdin)\par
                     IF (lwp) write (numout,*) 'NEGATIVE DIN ERROR @', ji, jj, jk, kt\par
                  endif\par
                  if (trn(ji,jj,jk,jpsil).lt.0.) then\par
                     IF (lwp) write (numout,*) '------------------------------'\par
                     IF (lwp) write (numout,*) 'NEGATIVE SIL ERROR =', trn(ji,jj,jk,jpsil)\par
                     IF (lwp) write (numout,*) 'NEGATIVE SIL ERROR @', ji, jj, jk, kt\par
                  endif\par
#  if defined key_roam\par
                  if (trn(ji,jj,jk,jpdic).lt.0.) then\par
                     IF (lwp) write (numout,*) '------------------------------'\par
                     IF (lwp) write (numout,*) 'NEGATIVE DIC ERROR =', trn(ji,jj,jk,jpdic)\par
                     IF (lwp) write (numout,*) 'NEGATIVE DIC ERROR @', ji, jj, jk, kt\par
                  endif\par
                  if (trn(ji,jj,jk,jpalk).lt.0.) then\par
                     IF (lwp) write (numout,*) '------------------------------'\par
                     IF (lwp) write (numout,*) 'NEGATIVE ALK ERROR =', trn(ji,jj,jk,jpalk)\par
                     IF (lwp) write (numout,*) 'NEGATIVE ALK ERROR @', ji, jj, jk, kt\par
                  endif\par
                  if (trn(ji,jj,jk,jpoxy).lt.0.) then\par
                     IF (lwp) write (numout,*) '------------------------------'\par
                     IF (lwp) write (numout,*) 'NEGATIVE OXY ERROR =', trn(ji,jj,jk,jpoxy)\par
                     IF (lwp) write (numout,*) 'NEGATIVE OXY ERROR @', ji, jj, jk, kt\par
                  endif\par
#  endif\par
               endif\par
# endif\par
# if defined key_debug_medusa\par
               !! report state variable values\par
               if (idf.eq.1.AND.idfval.eq.1) then\par
                  IF (lwp) write (numout,*) '------------------------------'\par
                  IF (lwp) write (numout,*) 'fthk(',jk,') = ', fthk\par
                  IF (lwp) write (numout,*) 'zphn(',jk,') = ', zphn\par
                  IF (lwp) write (numout,*) 'zphd(',jk,') = ', zphd\par
                  IF (lwp) write (numout,*) 'zpds(',jk,') = ', zpds\par
                  IF (lwp) write (numout,*) 'zzmi(',jk,') = ', zzmi\par
                  IF (lwp) write (numout,*) 'zzme(',jk,') = ', zzme\par
                  IF (lwp) write (numout,*) 'zdet(',jk,') = ', zdet\par
                  IF (lwp) write (numout,*) 'zdin(',jk,') = ', zdin\par
                  IF (lwp) write (numout,*) 'zsil(',jk,') = ', zsil\par
                  IF (lwp) write (numout,*) 'zfer(',jk,') = ', zfer\par
#  if defined key_roam\par
                  IF (lwp) write (numout,*) 'zdtc(',jk,') = ', zdtc\par
                  IF (lwp) write (numout,*) 'zdic(',jk,') = ', zdic\par
                  IF (lwp) write (numout,*) 'zalk(',jk,') = ', zalk\par
                  IF (lwp) write (numout,*) 'zoxy(',jk,') = ', zoxy                  \par
#  endif\par
               endif\par
# endif\par
\par
# if defined key_debug_medusa\par
               if (idf.eq.1.AND.idfval.eq.1.AND.jk.eq.1) then\par
                  IF (lwp) write (numout,*) '------------------------------'\par
                  IF (lwp) write (numout,*) 'dust      = ', dust(ji,jj)\par
               endif\par
# endif\par
\par
               !! sum tracers for inventory checks\par
               IF( lk_iomput ) THEN\par
                  IF ( med_diag%INVTN%dgsave )   THEN\par
                     ftot_n(ji,jj)  = ftot_n(ji,jj) + &\par
                             (fthk * ( zphn + zphd + zzmi + zzme + zdet + zdin ) )\par
                  ENDIF\par
                  IF ( med_diag%INVTSI%dgsave )  THEN\par
                     ftot_si(ji,jj) = ftot_si(ji,jj) + & \par
                             (fthk * ( zpds + zsil ) )\par
                  ENDIF\par
                  IF ( med_diag%INVTFE%dgsave )  THEN\par
                     ftot_fe(ji,jj) = ftot_fe(ji,jj) + & \par
                             (fthk * ( xrfn * ( zphn + zphd + zzmi + zzme + zdet ) + zfer ) )\par
                  ENDIF\par
# if defined key_roam\par
                  IF ( med_diag%INVTC%dgsave )  THEN\par
                     ftot_c(ji,jj)  = ftot_c(ji,jj) + & \par
                             (fthk * ( (xthetapn * zphn) + (xthetapd * zphd) + &\par
                             (xthetazmi * zzmi) + (xthetazme * zzme) + zdtc +   &\par
                             zdic ) )\par
                  ENDIF\par
                  IF ( med_diag%INVTALK%dgsave ) THEN\par
                     ftot_a(ji,jj)  = ftot_a(ji,jj) + (fthk * ( zalk ) )\par
                  ENDIF\par
                  IF ( med_diag%INVTO2%dgsave )  THEN\par
                     ftot_o2(ji,jj) = ftot_o2(ji,jj) + (fthk * ( zoxy ) )\par
                  ENDIF\par
                  !!\par
                  !! AXY (10/11/16): CMIP6 diagnostics\par
                  IF ( med_diag%INTDISSIC%dgsave ) THEN\par
                     intdissic(ji,jj) = intdissic(ji,jj) + (fthk * zdic)\par
                  ENDIF\par
                  IF ( med_diag%INTDISSIN%dgsave ) THEN\par
                     intdissin(ji,jj) = intdissin(ji,jj) + (fthk * zdin)\par
                  ENDIF\par
                  IF ( med_diag%INTDISSISI%dgsave ) THEN\par
                     intdissisi(ji,jj) = intdissisi(ji,jj) + (fthk * zsil)\par
                  ENDIF\par
                  IF ( med_diag%INTTALK%dgsave ) THEN\par
                     inttalk(ji,jj) = inttalk(ji,jj) + (fthk * zalk)\par
                  ENDIF\par
                  IF ( med_diag%O2min%dgsave ) THEN\par
                     if ( zoxy < o2min(ji,jj) ) then\par
                        o2min(ji,jj)  = zoxy\par
                        IF ( med_diag%ZO2min%dgsave ) THEN\par
                           zo2min(ji,jj) = (fdep + fdep1) / 2. !! layer midpoint\par
                        ENDIF\par
                     endif\par
                  ENDIF\par
# endif\par
               ENDIF\par
\par
               CALL flush(numout)\par
\par
               !!======================================================================\par
               !! LOCAL GRID CELL CALCULATIONS\par
               !!======================================================================\par
               !!\par
# if defined key_roam\par
               if ( jk .eq. 1 ) then\par
                  !!----------------------------------------------------------------------\par
                  !! Air-sea gas exchange\par
                  !!----------------------------------------------------------------------\par
                  !!\par
                  !! AXY (17/07/14): zwind_i and zwind_j do not exist in this\par
                  !!                 version of NEMO because it does not include\par
                  !!                 the SBC changes that our local version has\par
                  !!                 for accessing the HadGEM2 forcing; they \par
                  !!                 could be added, but an alternative approach\par
                  !!                 is to make use of wndm from oce_trc.F90\par
                  !!                 which is wind speed at 10m (which is what\par
                  !!                 is required here; this may need to be\par
                  !!                 revisited when MEDUSA properly interacts\par
                  !!                 with UKESM1 physics\par
                  !!\par
                  f_wind  = wndm(ji,jj)\par
                  IF (lk_oasis) THEN\par
                     f_xco2a = PCO2a_in_cpl(ji,jj)        !! use 2D atm xCO2 from atm coupling\par
                  ENDIF\par
                  !!\par
                  !! AXY (23/06/15): as part of an effort to update the carbonate chemistry\par
                  !!                 in MEDUSA, the gas transfer velocity used in the carbon\par
                  !!                 and oxygen cycles has been harmonised and is calculated\par
                  !!                 by the same function here; this harmonisation includes\par
                  !!                 changes to the PML carbonate chemistry scheme so that\par
                  !!                 it too makes use of the same gas transfer velocity; the\par
                  !!                 preferred parameterisation of this is Wanninkhof (2014),\par
                  !!                 option 7\par
                  !!\par
#   if defined key_debug_medusa\par
                     IF (lwp) write (numout,*) 'trc_bio_medusa: entering gas_transfer'\par
                     CALL flush(numout)\par
#   endif\par
                  CALL gas_transfer( f_wind, 1, 7, &  ! inputs\par
                                     f_kw660 )        ! outputs\par
#   if defined key_debug_medusa\par
                     IF (lwp) write (numout,*) 'trc_bio_medusa: exiting gas_transfer'\par
                     CALL flush(numout)\par
#   endif\par
                  !!\par
                  !! air pressure (atm); ultimately this will use air pressure at the base\par
                  !! of the UKESM1 atmosphere \par
                  !!                                     \par
                  f_pp0   = 1.0\par
                  !!\par
                  !! IF(lwp) WRITE(numout,*) ' MEDUSA ztmp    =', ztmp\par
                  !! IF(lwp) WRITE(numout,*) ' MEDUSA zwind_i =', zwind_i(ji,jj)\par
                  !! IF(lwp) WRITE(numout,*) ' MEDUSA zwind_j =', zwind_j(ji,jj)\par
                  !! IF(lwp) WRITE(numout,*) ' MEDUSA f_wind  =', f_wind\par
                  !! IF(lwp) WRITE(numout,*) ' MEDUSA fr_i    =', fr_i(ji,jj)\par
                  !!\par
#  if defined key_axy_carbchem\par
#   if defined key_mocsy\par
                  !!\par
                  !! AXY (22/06/15): use Orr & Epitalon (2015) MOCSY-2 carbonate\par
                  !!                 chemistry package; note that depth is set to\par
                  !!                 zero in this call\par
                  CALL mocsy_interface( ztmp, zsal, zalk, zdic, zsil, zpho,        &  ! inputs\par
                  f_pp0, 0.0, gphit(ji,jj), f_kw660, f_xco2a, 1,                   &  ! inputs\par
                  f_ph, f_pco2w, f_fco2w, f_h2co3, f_hco3, f_co3, f_omarg(ji,jj),  &  ! outputs\par
                  f_omcal(ji,jj), f_BetaD, f_rhosw, f_opres, f_insitut,            &  ! outputs\par
                  f_pco2atm, f_fco2atm, f_schmidtco2, f_kwco2, f_K0,               &  ! outputs\par
                  f_co2starair, f_co2flux, f_dpco2 )                                  ! outputs\par
                  !!\par
                  f_TDIC = (zdic / f_rhosw) * 1000. ! mmol / m3 -> umol / kg\par
                  f_TALK = (zalk / f_rhosw) * 1000. !  meq / m3 ->  ueq / kg\par
                  f_dcf  = f_rhosw\par
#   else                  \par
                  iters = 0\par
                  !!\par
                  !! carbon dioxide (CO2); Jerry Blackford code (ostensibly OCMIP-2, but not)\par
                  CALL trc_co2_medusa( ztmp, zsal, zdic, zalk, 0.0, f_kw660, f_xco2a,  &  ! inputs\par
                  f_ph, f_pco2w, f_h2co3, f_hco3, f_co3, f_omcal(ji,jj),               &  ! outputs\par
                  f_omarg(ji,jj), f_co2flux, f_TDIC, f_TALK, f_dcf, f_henry, iters )      ! outputs\par
                  !!\par
                  !! AXY (09/01/14): removed iteration and NaN checks; these have\par
                  !!                 been moved to trc_co2_medusa together with a\par
                  !!                 fudge that amends erroneous values (this is\par
                  !!                 intended to be a temporary fudge!); the\par
                  !!                 output warnings are retained here so that\par
                  !!                 failure position can be determined\par
                  if (iters .eq. 25) then\par
                     IF(lwp) WRITE(numout,*) ' trc_bio_medusa: ITERS WARNING, ', &\par
                     iters, ' AT (', ji, ', ', jj, ', ', jk, ') AT ', kt\par
                  endif\par
#     if defined key_foam_medusa\par
                  !! DAF (Aug 2017): calculate fCO2 for observation operator\par
                  CALL p2fCO2( f_pco2w, ztmp, f_pp0, 0.0, 1, f_fco2w )\par
#     endif\par
#   endif\par
#  else\par
                  !! AXY (18/04/13): switch off carbonate chemistry calculations; provide\par
                  !!                 quasi-sensible alternatives\par
                  f_ph           = 8.1\par
                  f_pco2w        = f_xco2a\par
                  f_h2co3        = 0.005 * zdic\par
                  f_hco3         = 0.865 * zdic\par
                  f_co3          = 0.130 * zdic\par
                  f_omcal(ji,jj) = 4.\par
                  f_omarg(ji,jj) = 2.\par
                  f_co2flux      = 0.\par
                  f_TDIC         = zdic\par
                  f_TALK         = zalk\par
                  f_dcf          = 1.026\par
                  f_henry        = 1.\par
                  !! AXY (23/06/15): add in some extra MOCSY diagnostics\par
                  f_fco2w        = f_xco2a\par
                  f_BetaD        = 1.\par
                  f_rhosw        = 1.026\par
                  f_opres        = 0.\par
                  f_insitut      = ztmp\par
                  f_pco2atm      = f_xco2a\par
                  f_fco2atm      = f_xco2a\par
                  f_schmidtco2   = 660.\par
                  f_kwco2        = 0.\par
                  f_K0           = 0.\par
                  f_co2starair   = f_xco2a\par
                  f_dpco2        = 0.\par
#  endif\par
                  !!\par
                  !! mmol/m2/s -> mmol/m3/d; correct for sea-ice; divide through by layer thickness\par
                  f_co2flux = (1. - fr_i(ji,jj)) * f_co2flux * 86400. / fthk\par
                  !!\par
                  !! oxygen (O2); OCMIP-2 code\par
                  !! AXY (23/06/15): amend input list for oxygen to account for common gas\par
                  !!                 transfer velocity\par
                  !! CALL trc_oxy_medusa( ztmp, zsal, f_uwind, f_vwind, f_pp0, zoxy / 1000., fthk,  &  ! inputs\par
                  !! f_kw660, f_o2flux, f_o2sat )                                                      ! outputs\par
                  CALL trc_oxy_medusa( ztmp, zsal, f_kw660, f_pp0, zoxy,  &  ! inputs\par
                  f_kwo2, f_o2flux, f_o2sat )                                ! outputs\par
                  !!\par
                  !! mmol/m2/s -> mol/m3/d; correct for sea-ice; divide through by layer thickness\par
                  f_o2flux  = (1. - fr_i(ji,jj)) * f_o2flux * 86400. / fthk\par
                  !!\par
                  !! Jpalm (08-2014)\par
                  !! DMS surface concentration calculation\par
                  !! initialy added for UKESM1 model.\par
                  !! using MET-OFFICE subroutine.\par
                  !! DMS module only needs Chl concentration and MLD\par
                  !! to get an aproximate value of DMS concentration.\par
                  !! air-sea fluxes are calculated by atmospheric chemitry model\par
                  !! from atm and oc-surface concentrations.\par
                  !!\par
                  !! AXY (13/03/15): this is amended to calculate all of the DMS\par
                  !!                 estimates examined during UKESM1 (see comments\par
                  !!                 in trcdms_medusa.F90)\par
                  !!\par
                  !! AXY (25/05/17): amended to additionally pass DIN limitation as well as [DIN];\par
                  !!                 accounts for differences in nutrient half-saturations; changes\par
                  !!                 also made in trc_dms_medusa; this permits an additional DMS\par
                  !!                 calculation while retaining the existing Anderson one\par
                  !!\par
                  IF (jdms .eq. 1) THEN\par
                     !!\par
                     !! calculate weighted half-saturation for DIN uptake\par
                     dms_wtkn = ((zphn * xnln) + (zphd * xnld)) / (zphn + zphd)\par
                     !!\par
                     !! feed in correct inputs\par
                     if (jdms_input .eq. 0) then\par
                        !! use instantaneous inputs\par
                        dms_nlim = zdin / (zdin + dms_wtkn)\par
                        !!\par
                        CALL trc_dms_medusa( zchn, zchd,                           &  ! inputs\par
                        hmld(ji,jj), qsr(ji,jj),                                   &  ! inputs\par
                        zdin, dms_nlim,                                            &  ! inputs\par
                        dms_andr, dms_simo, dms_aran, dms_hall, dms_andm )            ! outputs\par
                     else\par
                        !! use diel-average inputs\par
                        dms_nlim = zn_dms_din(ji,jj) / (zn_dms_din(ji,jj) + dms_wtkn)\par
                        !!\par
                        CALL trc_dms_medusa( zn_dms_chn(ji,jj), zn_dms_chd(ji,jj), &  ! inputs\par
                        zn_dms_mld(ji,jj), zn_dms_qsr(ji,jj),                      &  ! inputs\par
                        zn_dms_din(ji,jj), dms_nlim,                               &  ! inputs\par
                        dms_andr, dms_simo, dms_aran, dms_hall, dms_andm )            ! outputs\par
                     endif\par
                     !!\par
                     !! assign correct output to variable passed to atmosphere\par
                     if     (jdms_model .eq. 1) then\par
                        dms_surf = dms_andr\par
                     elseif (jdms_model .eq. 2) then\par
                        dms_surf = dms_simo\par
                     elseif (jdms_model .eq. 3) then\par
                        dms_surf = dms_aran\par
                     elseif (jdms_model .eq. 4) then\par
                        dms_surf = dms_hall\par
                     elseif (jdms_model .eq. 5) then\par
                        dms_surf = dms_andm\par
                     endif\par
                     !!\par
                     !! 2D diag through iom_use\par
                     IF( lk_iomput ) THEN\par
                       IF( med_diag%DMS_SURF%dgsave ) THEN\par
                         dms_surf2d(ji,jj) = dms_surf\par
                       ENDIF\par
                       IF( med_diag%DMS_ANDR%dgsave ) THEN\par
                         dms_andr2d(ji,jj) = dms_andr\par
                       ENDIF\par
                       IF( med_diag%DMS_SIMO%dgsave ) THEN\par
                         dms_simo2d(ji,jj) = dms_simo\par
                       ENDIF\par
                       IF( med_diag%DMS_ARAN%dgsave ) THEN\par
                         dms_aran2d(ji,jj) = dms_aran\par
                       ENDIF\par
                       IF( med_diag%DMS_HALL%dgsave ) THEN\par
                         dms_hall2d(ji,jj) = dms_hall\par
                       ENDIF\par
                       IF( med_diag%DMS_ANDM%dgsave ) THEN\par
                         dms_andm2d(ji,jj) = dms_andm\par
                       ENDIF\par
#   if defined key_debug_medusa\par
                       IF (lwp) write (numout,*) 'trc_bio_medusa: finish calculating dms'\par
                     CALL flush(numout)\par
#   endif \par
                     ENDIF\par
                     !! End iom\par
                  ENDIF\par
                  !! End DMS Loop\par
                  !!\par
                  !! store 2D outputs\par
                  !!\par
                  !! JPALM -- 17-11-16 -- put fgco2 out of diag request\par
                  !!                    is needed for coupling; pass through restart\par
                  !! IF( med_diag%FGCO2%dgsave ) THEN\par
                     !! convert from  mol/m2/day to kg/m2/s\par
                     fgco2(ji,jj) = f_co2flux * fthk * CO2flux_conv  !! mmol-C/m3/d -> kg-CO2/m2/s\par
                  !! ENDIF\par
#   if defined key_foam_medusa\par
                  !! DAF (Aug 2017): Save pCO2 and fCO2 for observation operator\par
                  f2_pco2w(ji,jj) = f_pco2w\par
                  f2_fco2w(ji,jj) = f_pco2w\par
#   endif\par
                  IF ( lk_iomput ) THEN\par
                      IF( med_diag%ATM_PCO2%dgsave ) THEN\par
                         f_pco2a2d(ji,jj) = f_pco2atm\par
                      ENDIF\par
                      IF( med_diag%OCN_PCO2%dgsave ) THEN\par
                         f_pco2w2d(ji,jj) = f_pco2w\par
                      ENDIF\par
                      IF( med_diag%CO2FLUX%dgsave ) THEN\par
                         f_co2flux2d(ji,jj) = f_co2flux * fthk           !! mmol/m3/d -> mmol/m2/d\par
                      ENDIF\par
                      IF( med_diag%TCO2%dgsave ) THEN\par
                         f_TDIC2d(ji,jj) = f_TDIC\par
                      ENDIF\par
                      IF( med_diag%TALK%dgsave ) THEN\par
                         f_TALK2d(ji,jj) = f_TALK\par
                      ENDIF\par
                      IF( med_diag%KW660%dgsave ) THEN\par
                         f_kw6602d(ji,jj) = f_kw660\par
                      ENDIF\par
                      IF( med_diag%ATM_PP0%dgsave ) THEN\par
                         f_pp02d(ji,jj) = f_pp0\par
                      ENDIF\par
                      IF( med_diag%O2FLUX%dgsave ) THEN\par
                         f_o2flux2d(ji,jj) = f_o2flux\par
                      ENDIF\par
                      IF( med_diag%O2SAT%dgsave ) THEN\par
                         f_o2sat2d(ji,jj) = f_o2sat\par
                      ENDIF\par
                      !! AXY (24/11/16): add in extra MOCSY diagnostics\par
                      IF( med_diag%ATM_XCO2%dgsave ) THEN\par
                         f_xco2a_2d(ji,jj) = f_xco2a\par
                      ENDIF\par
                      IF( med_diag%OCN_FCO2%dgsave ) THEN\par
                         f_fco2w_2d(ji,jj) = f_fco2w\par
                      ENDIF\par
                      IF( med_diag%ATM_FCO2%dgsave ) THEN\par
                         f_fco2a_2d(ji,jj) = f_fco2atm\par
                      ENDIF\par
                      IF( med_diag%OCN_RHOSW%dgsave ) THEN\par
                         f_ocnrhosw_2d(ji,jj) = f_rhosw\par
                      ENDIF\par
                      IF( med_diag%OCN_SCHCO2%dgsave ) THEN\par
                         f_ocnschco2_2d(ji,jj) = f_schmidtco2\par
                      ENDIF\par
                      IF( med_diag%OCN_KWCO2%dgsave ) THEN\par
                         f_ocnkwco2_2d(ji,jj) = f_kwco2\par
                      ENDIF\par
                      IF( med_diag%OCN_K0%dgsave ) THEN\par
                         f_ocnk0_2d(ji,jj) = f_K0\par
                      ENDIF\par
                      IF( med_diag%CO2STARAIR%dgsave ) THEN\par
                         f_co2starair_2d(ji,jj) = f_co2starair\par
                      ENDIF\par
                      IF( med_diag%OCN_DPCO2%dgsave ) THEN\par
                         f_ocndpco2_2d(ji,jj) = f_dpco2\par
                      ENDIF\par
                  ENDIF\par
                  !! \par
               endif\par
               !! End jk = 1 loop within ROAM key \par
\par
               !! AXY (11/11/16): CMIP6 oxygen saturation 3D diagnostic\par
               IF ( med_diag%O2SAT3%dgsave ) THEN\par
                  call oxy_sato( ztmp, zsal, f_o2sat3 )\par
                  o2sat3(ji, jj, jk) = f_o2sat3\par
               ENDIF\par
\par
# endif\par
\par
               if ( jk .eq. 1 ) then\par
                  !!----------------------------------------------------------------------\par
                  !! River inputs\par
                  !!----------------------------------------------------------------------\par
                  !!\par
                  !! runoff comes in as        kg / m2 / s\par
                  !! used and written out as   m3 / m2 / d (= m / d)\par
                  !! where                     1000 kg / m2 / d = 1 m3 / m2 / d = 1 m / d\par
                  !!\par
                  !! AXY (17/07/14): the compiler doesn't like this line for some reason;\par
                  !!                 as MEDUSA doesn't even use runoff for riverine inputs,\par
                  !!                 a temporary solution is to switch off runoff entirely\par
                  !!                 here; again, this change is one of several that will \par
                  !!                 need revisiting once MEDUSA has bedded down in UKESM1;\par
                  !!                 particularly so if the land scheme provides information\par
                  !!                 concerning nutrient fluxes\par
                  !!\par
                  !! f_runoff(ji,jj) = sf_rnf(1)%fnow(ji,jj,1) / 1000. * 60. * 60. * 24.\par
                  f_runoff(ji,jj) = 0.0\par
                  !!\par
                  !! nutrients are added via rivers to the model in one of two ways:\par
                  !!   1. via river concentration; i.e. the average nutrient concentration\par
                  !!      of a river water is described by a spatial file, and this is\par
                  !!      multiplied by runoff to give a nutrient flux\par
                  !!   2. via direct river flux; i.e. the average nutrient flux due to\par
                  !!      rivers is described by a spatial file, and this is simply applied\par
                  !!      as a direct nutrient flux (i.e. it does not relate or respond to\par
                  !!      model runoff)\par
                  !! nutrient fields are derived from the GlobalNEWS 2 database; carbon and\par
                  !! alkalinity are derived from continent-scale DIC estimates (Huang et al., \par
                  !! 2012) and some Arctic river alkalinity estimates (Katya?)\par
                  !! \par
                  !! as of 19/07/12, riverine nutrients can now be spread vertically across \par
                  !! several grid cells rather than just poured into the surface box; this\par
                  !! block of code is still executed, however, to set up the total amounts\par
                  !! of nutrient entering via rivers\par
                  !!\par
                  !! nitrogen\par
                  if (jriver_n .eq. 1) then\par
                     !! river concentration specified; use runoff to calculate input\par
                     f_riv_n(ji,jj) = f_runoff(ji,jj) * riv_n(ji,jj)\par
                  elseif (jriver_n .eq. 2) then\par
                     !! river flux specified; independent of runoff\par
                     f_riv_n(ji,jj) = riv_n(ji,jj)\par
                  endif\par
                  !!\par
                  !! silicon\par
                  if (jriver_si .eq. 1) then\par
                     !! river concentration specified; use runoff to calculate input\par
                     f_riv_si(ji,jj) = f_runoff(ji,jj) * riv_si(ji,jj)\par
                  elseif (jriver_si .eq. 2) then\par
                     !! river flux specified; independent of runoff\par
                     f_riv_si(ji,jj) = riv_si(ji,jj)\par
                  endif\par
                  !!\par
                  !! carbon\par
                  if (jriver_c .eq. 1) then\par
                     !! river concentration specified; use runoff to calculate input\par
                     f_riv_c(ji,jj) = f_runoff(ji,jj) * riv_c(ji,jj)\par
                  elseif (jriver_c .eq. 2) then\par
                     !! river flux specified; independent of runoff\par
                     f_riv_c(ji,jj) = riv_c(ji,jj)\par
                  endif\par
                  !!\par
                  !! alkalinity\par
                  if (jriver_alk .eq. 1) then\par
                     !! river concentration specified; use runoff to calculate input\par
                     f_riv_alk(ji,jj) = f_runoff(ji,jj) * riv_alk(ji,jj)\par
                  elseif (jriver_alk .eq. 2) then\par
                     !! river flux specified; independent of runoff\par
                     f_riv_alk(ji,jj) = riv_alk(ji,jj)\par
                  endif\par
\par
               endif\par
\par
               !!----------------------------------------------------------------------\par
               !! Chlorophyll calculations\par
               !!----------------------------------------------------------------------\par
               !!\par
               !! non-diatoms\par
\tab        if (zphn.GT.rsmall) then\par
                  fthetan = max(tiny(zchn), (zchn * xxi) / (zphn + tiny(zphn)))\par
                  faln    = xaln * fthetan\par
               else\par
                  fthetan = 0.\par
                  faln    = 0.\par
               endif\par
               !!\par
               !! diatoms\par
\tab        if (zphd.GT.rsmall) then\par
                  fthetad = max(tiny(zchd), (zchd * xxi) / (zphd + tiny(zphd)))\par
                  fald    = xald * fthetad\par
               else\par
                  fthetad = 0.\par
                  fald    = 0.\par
               endif\par
\par
# if defined key_debug_medusa\par
               !! report biological calculations\par
               if (idf.eq.1.AND.idfval.eq.1) then\par
                  IF (lwp) write (numout,*) '------------------------------'\par
                  IF (lwp) write (numout,*) 'faln(',jk,') = ', faln\par
                  IF (lwp) write (numout,*) 'fald(',jk,') = ', fald\par
               endif\par
# endif\par
\par
               !!----------------------------------------------------------------------\par
               !! Phytoplankton light limitation\par
               !!----------------------------------------------------------------------\par
               !!\par
               !! It is assumed xpar is the depth-averaged (vertical layer) PAR \par
               !! Light limitation (check self-shading) in W/m2\par
               !!\par
               !! Note that there is no temperature dependence in phytoplankton\par
               !! growth rate or any other function. \par
               !! In calculation of Chl/Phy ratio tiny(phyto) is introduced to avoid\par
               !! NaNs in case of Phy==0.  \par
               !!\par
               !! fthetad and fthetan are Chl:C ratio (gChl/gC) in diat and non-diat: \par
               !! for 1:1 Chl:P ratio (mgChl/mmolN) theta=0.012\par
               !!\par
               !! AXY (16/07/09)\par
               !! temperature for new Eppley style phytoplankton growth\par
               loc_T   = tsn(ji,jj,jk,jp_tem)\par
               fun_T   = 1.066**(1.0 * loc_T)\par
               !! AXY (16/05/11): add in new Q10 (1.5, not 2.0) for\par
               !phytoplankton\par
               !!                 growth; remin. unaffected\par
               fun_Q10 = jq10**((loc_T - 0.0) / 10.0)\par
               if (jphy.eq.1) then\par
                  xvpnT = xvpn * fun_T\par
                  xvpdT = xvpd * fun_T\par
               elseif (jphy.eq.2) then\par
                  xvpnT = xvpn * fun_Q10\par
                  xvpdT = xvpd * fun_Q10\par
               else\par
                  xvpnT = xvpn\par
                  xvpdT = xvpd\par
               endif\par
               !!\par
               !! non-diatoms\par
               fchn1   = (xvpnT * xvpnT) + (faln * faln * xpar(ji,jj,jk) * xpar(ji,jj,jk))\par
               if (fchn1.GT.rsmall) then\par
                  fchn    = xvpnT / (sqrt(fchn1) + tiny(fchn1))\par
               else\par
                  fchn    = 0.\par
               endif\par
               fjln    = fchn * faln * xpar(ji,jj,jk) !! non-diatom J term\par
               fjlim_pn = fjln / xvpnT\par
               !!\par
               !! diatoms\par
               fchd1   = (xvpdT * xvpdT) + (fald * fald * xpar(ji,jj,jk) * xpar(ji,jj,jk))\par
               if (fchd1.GT.rsmall) then\par
                  fchd    = xvpdT / (sqrt(fchd1) + tiny(fchd1))\par
               else\par
                  fchd    = 0.\par
               endif\par
               fjld    = fchd * fald * xpar(ji,jj,jk) !! diatom J term\par
               fjlim_pd = fjld / xvpdT\par
      \par
# if defined key_debug_medusa\par
               !! report phytoplankton light limitation\par
               if (idf.eq.1.AND.idfval.eq.1) then\par
                  IF (lwp) write (numout,*) '------------------------------'\par
                  IF (lwp) write (numout,*) 'fchn(',jk,') = ', fchn\par
                  IF (lwp) write (numout,*) 'fchd(',jk,') = ', fchd\par
                  IF (lwp) write (numout,*) 'fjln(',jk,') = ', fjln\par
                  IF (lwp) write (numout,*) 'fjld(',jk,') = ', fjld\par
               endif\par
# endif\par
\par
               !!----------------------------------------------------------------------\par
               !! Phytoplankton nutrient limitation\par
               !!----------------------------------------------------------------------\par
               !!\par
               !! non-diatoms (N, Fe)\par
               fnln = zdin / (zdin + xnln) !! non-diatom Qn term\par
               ffln = zfer / (zfer + xfln) !! non-diatom Qf term\par
               !!\par
               !! diatoms (N, Si, Fe)\par
               fnld = zdin / (zdin + xnld) !! diatom Qn term\par
               fsld = zsil / (zsil + xsld) !! diatom Qs term\par
               ffld = zfer / (zfer + xfld) !! diatom Qf term\par
\par
# if defined key_debug_medusa\par
               !! report phytoplankton nutrient limitation\par
               if (idf.eq.1.AND.idfval.eq.1) then\par
                  IF (lwp) write (numout,*) '------------------------------'\par
                  IF (lwp) write (numout,*) 'fnln(',jk,') = ', fnln\par
                  IF (lwp) write (numout,*) 'fnld(',jk,') = ', fnld\par
                  IF (lwp) write (numout,*) 'ffln(',jk,') = ', ffln\par
                  IF (lwp) write (numout,*) 'ffld(',jk,') = ', ffld\par
                  IF (lwp) write (numout,*) 'fsld(',jk,') = ', fsld\par
               endif\par
# endif\par
\par
               !!----------------------------------------------------------------------\par
               !! Primary production (non-diatoms)\par
               !! (note: still needs multiplying by phytoplankton concentration)\par
               !!----------------------------------------------------------------------\par
               !!\par
               if (jliebig .eq. 0) then\par
                  !! multiplicative nutrient limitation\par
                  fpnlim = fnln * ffln\par
               elseif (jliebig .eq. 1) then\par
                  !! Liebig Law (= most limiting) nutrient limitation\par
                  fpnlim = min(fnln, ffln)\par
               endif\par
               fprn = fjln * fpnlim\par
\par
               !!----------------------------------------------------------------------\par
               !! Primary production (diatoms)\par
               !! (note: still needs multiplying by phytoplankton concentration)\par
               !!\par
               !! production here is split between nitrogen production and that of\par
               !! silicon; depending upon the "intracellular" ratio of Si:N, model\par
               !! diatoms will uptake nitrogen/silicon differentially; this borrows\par
               !! from the diatom model of Mongin et al. (2006)\par
               !!----------------------------------------------------------------------\par
               !!\par
               if (jliebig .eq. 0) then\par
                  !! multiplicative nutrient limitation\par
                  fpdlim = fnld * ffld\par
               elseif (jliebig .eq. 1) then\par
                  !! Liebig Law (= most limiting) nutrient limitation\par
                  fpdlim = min(fnld, ffld)\par
               endif\par
               !!\par
\tab        if (zphd.GT.rsmall .AND. zpds.GT.rsmall) then\par
                  !! "intracellular" elemental ratios\par
                  ! fsin  = zpds / (zphd + tiny(zphd))\par
                  ! fnsi  = zphd / (zpds + tiny(zpds))\par
                  fsin = 0.0\par
                  IF( zphd .GT. rsmall) fsin  = zpds / zphd\par
                  fnsi = 0.0\par
                  IF( zpds .GT. rsmall) fnsi  = zphd / zpds\par
                  !! AXY (23/02/10): these next variables derive from Mongin et al. (2003)\par
                  fsin1 = 3.0 * xsin0 !! = 0.6\par
                  fnsi1 = 1.0 / fsin1 !! = 1.667\par
                  fnsi2 = 1.0 / xsin0 !! = 5.0\par
                  !!\par
                  !! conditionalities based on ratios\par
                  !! nitrogen (and iron and carbon)\par
                  if (fsin.le.xsin0) then\par
                     fprd  = 0.0\par
                     fsld2 = 0.0\par
                  elseif (fsin.lt.fsin1) then\par
                     fprd  = xuif * ((fsin - xsin0) / (fsin + tiny(fsin))) * (fjld * fpdlim)\par
                     fsld2 = xuif * ((fsin - xsin0) / (fsin + tiny(fsin)))\par
                  elseif (fsin.ge.fsin1) then\par
                     fprd  = (fjld * fpdlim)\par
                     fsld2 = 1.0\par
                  endif\par
                  !!\par
                  !! silicon\par
                  if (fsin.lt.fnsi1) then\par
                     fprds = (fjld * fsld)\par
                  elseif (fsin.lt.fnsi2) then\par
                     fprds = xuif * ((fnsi - xnsi0) / (fnsi + tiny(fnsi))) * (fjld * fsld)\par
                  else\par
                     fprds = 0.0\par
                  endif     \par
               else\par
                  fsin  = 0.0\par
                  fnsi  = 0.0\par
                  fprd  = 0.0\par
                  fsld2 = 0.0\par
                  fprds = 0.0\par
               endif\par
\par
# if defined key_debug_medusa\par
               !! report phytoplankton growth (including diatom silicon submodel)\par
               if (idf.eq.1.AND.idfval.eq.1) then\par
                  IF (lwp) write (numout,*) '------------------------------'\par
                  IF (lwp) write (numout,*) 'fsin(',jk,')   = ', fsin\par
                  IF (lwp) write (numout,*) 'fnsi(',jk,')   = ', fnsi\par
                  IF (lwp) write (numout,*) 'fsld2(',jk,')  = ', fsld2\par
                  IF (lwp) write (numout,*) 'fprn(',jk,')   = ', fprn\par
                  IF (lwp) write (numout,*) 'fprd(',jk,')   = ', fprd\par
                  IF (lwp) write (numout,*) 'fprds(',jk,')  = ', fprds\par
               endif\par
# endif\par
\par
               !!----------------------------------------------------------------------\par
               !! Mixed layer primary production\par
               !! this block calculates the amount of primary production that occurs\par
               !! within the upper mixed layer; this allows the separate diagnosis\par
               !! of "sub-surface" primary production; it does assume that short-\par
               !! term variability in mixed layer depth doesn't mess with things\par
               !! though\par
               !!----------------------------------------------------------------------\par
               !!\par
               if (fdep1.le.hmld(ji,jj)) then\par
                  !! this level is entirely in the mixed layer\par
                  fq0 = 1.0\par
               elseif (fdep.ge.hmld(ji,jj)) then\par
                  !! this level is entirely below the mixed layer\par
                  fq0 = 0.0\par
               else\par
                  !! this level straddles the mixed layer\par
                  fq0 = (hmld(ji,jj) - fdep) / fthk\par
               endif\par
               !!\par
               fprn_ml(ji,jj) = fprn_ml(ji,jj) + (fprn * zphn * fthk * fq0)\par
               fprd_ml(ji,jj) = fprd_ml(ji,jj) + (fprd * zphd * fthk * fq0)\par
               \par
               !!----------------------------------------------------------------------\par
               !! Vertical Integral --\par
               !!----------------------------------------------------------------------\par
               ftot_pn(ji,jj)  = ftot_pn(ji,jj)  + (zphn * fthk)   !! vertical integral non-diatom phytoplankton\par
               ftot_pd(ji,jj)  = ftot_pd(ji,jj)  + (zphd * fthk)   !! vertical integral diatom phytoplankton\par
               ftot_zmi(ji,jj) = ftot_zmi(ji,jj) + (zzmi * fthk)   !! vertical integral microzooplankton\par
               ftot_zme(ji,jj) = ftot_zme(ji,jj) + (zzme * fthk)   !! vertical integral mesozooplankton\par
               ftot_det(ji,jj) = ftot_det(ji,jj) + (zdet * fthk)   !! vertical integral slow detritus, nitrogen\par
               ftot_dtc(ji,jj) = ftot_dtc(ji,jj) + (zdtc * fthk)   !! vertical integral slow detritus, carbon\par
               \par
               !!----------------------------------------------------------------------\par
               !! More chlorophyll calculations\par
               !!----------------------------------------------------------------------\par
               !!\par
               !! frn = (xthetam / fthetan) * (fprn / (fthetan * xpar(ji,jj,jk)))\par
               !! frd = (xthetam / fthetad) * (fprd / (fthetad * xpar(ji,jj,jk)))\par
               frn = (xthetam * fchn * fnln * ffln       ) / (fthetan + tiny(fthetan))\par
               !! AXY (12/05/09): there's potentially a problem here; fsld, silicic acid \par
               !!   limitation, is used in the following line to regulate chlorophyll \par
               !!   growth in a manner that is inconsistent with its use in the regulation \par
               !!   of biomass growth; the Mongin term term used in growth is more complex\par
               !!   than the simple multiplicative function used below\par
               !! frd = (xthetam * fchd * fnld * ffld * fsld) / (fthetad + tiny(fthetad))\par
               !! AXY (12/05/09): this replacement line uses the new variable, fsld2, to\par
               !!   regulate chlorophyll growth\par
               frd = (xthetamd * fchd * fnld * ffld * fsld2) / (fthetad + tiny(fthetad))\par
\par
# if defined key_debug_medusa\par
               !! report chlorophyll calculations\par
               if (idf.eq.1.AND.idfval.eq.1) then\par
                  IF (lwp) write (numout,*) '------------------------------'\par
                  IF (lwp) write (numout,*) 'fthetan(',jk,') = ', fthetan\par
                  IF (lwp) write (numout,*) 'fthetad(',jk,') = ', fthetad\par
                  IF (lwp) write (numout,*) 'frn(',jk,')     = ', frn\par
                  IF (lwp) write (numout,*) 'frd(',jk,')     = ', frd\par
               endif\par
# endif\par
\par
               !!----------------------------------------------------------------------\par
               !! Zooplankton Grazing \par
               !! this code supplements the base grazing model with one that\par
               !! considers the C:N ratio of grazed food and balances this against\par
               !! the requirements of zooplankton growth; this model is derived \par
               !! from that of Anderson & Pondaven (2003)\par
               !!\par
               !! the current version of the code assumes a fixed C:N ratio for\par
               !! detritus (in contrast to Anderson & Pondaven, 2003), though the\par
               !! full equations are retained for future extension\par
               !!----------------------------------------------------------------------\par
               !!\par
               !!----------------------------------------------------------------------\par
               !! Microzooplankton first\par
               !!----------------------------------------------------------------------\par
               !!\par
               fmi1    = (xkmi * xkmi) + (xpmipn * zphn * zphn) + (xpmid * zdet * zdet)\par
               fmi     = xgmi * zzmi / fmi1\par
               fgmipn  = fmi * xpmipn * zphn * zphn   !! grazing on non-diatoms\par
               fgmid   = fmi * xpmid  * zdet * zdet   !! grazing on detrital nitrogen\par
# if defined key_roam\par
               fgmidc  = rsmall !acc\par
               IF ( zdet .GT. rsmall ) fgmidc  = (zdtc / (zdet + tiny(zdet))) * fgmid  !! grazing on detrital carbon\par
# else\par
               !! AXY (26/11/08): implicit detrital carbon change\par
               fgmidc  = xthetad * fgmid              !! grazing on detrital carbon\par
# endif\par
               !!\par
               !! which translates to these incoming N and C fluxes\par
               finmi   = (1.0 - xphi) * (fgmipn + fgmid)\par
               ficmi   = (1.0 - xphi) * ((xthetapn * fgmipn) + fgmidc)\par
               !!\par
               !! the ideal food C:N ratio for microzooplankton\par
               !! xbetan = 0.77; xthetaz = 5.625; xbetac = 0.64; xkc = 0.80\par
               fstarmi = (xbetan * xthetazmi) / (xbetac * xkc)\par
               !!\par
               !! process these to determine proportioning of grazed N and C\par
               !! (since there is no explicit consideration of respiration,\par
               !! only growth and excretion are calculated here)\par
               fmith   = (ficmi / (finmi + tiny(finmi)))\par
               if (fmith.ge.fstarmi) then\par
                  fmigrow = xbetan * finmi\par
                  fmiexcr = 0.0\par
               else\par
                  fmigrow = (xbetac * xkc * ficmi) / xthetazmi\par
                  fmiexcr = ficmi * ((xbetan / (fmith + tiny(fmith))) - ((xbetac * xkc) / xthetazmi))\par
               endif\par
# if defined key_roam\par
               fmiresp = (xbetac * ficmi) - (xthetazmi * fmigrow)\par
# endif\par
\par
# if defined key_debug_medusa\par
               !! report microzooplankton grazing\par
               if (idf.eq.1.AND.idfval.eq.1) then\par
                  IF (lwp) write (numout,*) '------------------------------'\par
                  IF (lwp) write (numout,*) 'fmi1(',jk,')    = ', fmi1\par
                  IF (lwp) write (numout,*) 'fmi(',jk,')     = ', fmi\par
                  IF (lwp) write (numout,*) 'fgmipn(',jk,')  = ', fgmipn\par
                  IF (lwp) write (numout,*) 'fgmid(',jk,')   = ', fgmid\par
                  IF (lwp) write (numout,*) 'fgmidc(',jk,')  = ', fgmidc\par
                  IF (lwp) write (numout,*) 'finmi(',jk,')   = ', finmi\par
                  IF (lwp) write (numout,*) 'ficmi(',jk,')   = ', ficmi\par
                  IF (lwp) write (numout,*) 'fstarmi(',jk,') = ', fstarmi\par
                  IF (lwp) write (numout,*) 'fmith(',jk,')   = ', fmith\par
                  IF (lwp) write (numout,*) 'fmigrow(',jk,') = ', fmigrow\par
                  IF (lwp) write (numout,*) 'fmiexcr(',jk,') = ', fmiexcr\par
#  if defined key_roam\par
                  IF (lwp) write (numout,*) 'fmiresp(',jk,') = ', fmiresp\par
#  endif\par
               endif\par
# endif\par
\par
               !!----------------------------------------------------------------------\par
               !! Mesozooplankton second\par
               !!----------------------------------------------------------------------\par
               !!\par
               fme1    = (xkme * xkme) + (xpmepn * zphn * zphn) + (xpmepd * zphd * zphd) + & \par
                         (xpmezmi * zzmi * zzmi) + (xpmed * zdet * zdet)\par
               fme     = xgme * zzme / fme1\par
               fgmepn  = fme * xpmepn  * zphn * zphn  !! grazing on non-diatoms\par
               fgmepd  = fme * xpmepd  * zphd * zphd  !! grazing on diatoms\par
               fgmepds = fsin * fgmepd                !! grazing on diatom silicon\par
               fgmezmi = fme * xpmezmi * zzmi * zzmi  !! grazing on microzooplankton\par
               fgmed   = fme * xpmed   * zdet * zdet  !! grazing on detrital nitrogen\par
# if defined key_roam\par
               fgmedc  = rsmall !acc\par
               IF ( zdet .GT. rsmall ) fgmedc  = (zdtc / (zdet + tiny(zdet))) * fgmed  !! grazing on detrital carbon\par
# else\par
               !! AXY (26/11/08): implicit detrital carbon change\par
               fgmedc  = xthetad * fgmed              !! grazing on detrital carbon\par
# endif\par
               !!\par
               !! which translates to these incoming N and C fluxes\par
               finme   = (1.0 - xphi) * (fgmepn + fgmepd + fgmezmi + fgmed)\par
               ficme   = (1.0 - xphi) * ((xthetapn * fgmepn) + (xthetapd * fgmepd) + &\par
                        (xthetazmi * fgmezmi) + fgmedc)\par
               !!\par
               !! the ideal food C:N ratio for mesozooplankton\par
               !! xbetan = 0.77; xthetaz = 5.625; xbetac = 0.64; xkc = 0.80\par
               fstarme = (xbetan * xthetazme) / (xbetac * xkc)\par
               !!\par
               !! process these to determine proportioning of grazed N and C\par
               !! (since there is no explicit consideration of respiration,\par
               !! only growth and excretion are calculated here)\par
               fmeth   = (ficme / (finme + tiny(finme)))\par
               if (fmeth.ge.fstarme) then\par
                  fmegrow = xbetan * finme\par
                  fmeexcr = 0.0\par
               else\par
                  fmegrow = (xbetac * xkc * ficme) / xthetazme\par
                  fmeexcr = ficme * ((xbetan / (fmeth + tiny(fmeth))) - ((xbetac * xkc) / xthetazme))\par
               endif\par
# if defined key_roam\par
               fmeresp = (xbetac * ficme) - (xthetazme * fmegrow)\par
# endif\par
\par
# if defined key_debug_medusa\par
               !! report mesozooplankton grazing\par
               if (idf.eq.1.AND.idfval.eq.1) then\par
                  IF (lwp) write (numout,*) '------------------------------'\par
                  IF (lwp) write (numout,*) 'fme1(',jk,')    = ', fme1\par
                  IF (lwp) write (numout,*) 'fme(',jk,')     = ', fme\par
                  IF (lwp) write (numout,*) 'fgmepn(',jk,')  = ', fgmepn\par
                  IF (lwp) write (numout,*) 'fgmepd(',jk,')  = ', fgmepd\par
                  IF (lwp) write (numout,*) 'fgmepds(',jk,') = ', fgmepds\par
                  IF (lwp) write (numout,*) 'fgmezmi(',jk,') = ', fgmezmi\par
                  IF (lwp) write (numout,*) 'fgmed(',jk,')   = ', fgmed\par
                  IF (lwp) write (numout,*) 'fgmedc(',jk,')  = ', fgmedc\par
                  IF (lwp) write (numout,*) 'finme(',jk,')   = ', finme\par
                  IF (lwp) write (numout,*) 'ficme(',jk,')   = ', ficme\par
                  IF (lwp) write (numout,*) 'fstarme(',jk,') = ', fstarme\par
                  IF (lwp) write (numout,*) 'fmeth(',jk,')   = ', fmeth\par
                  IF (lwp) write (numout,*) 'fmegrow(',jk,') = ', fmegrow\par
                  IF (lwp) write (numout,*) 'fmeexcr(',jk,') = ', fmeexcr\par
#  if defined key_roam\par
                  IF (lwp) write (numout,*) 'fmeresp(',jk,') = ', fmeresp\par
#  endif\par
               endif\par
# endif\par
\par
               fzmi_i(ji,jj)  = fzmi_i(ji,jj)  + fthk * (  &\par
                  fgmipn + fgmid )\par
               fzmi_o(ji,jj)  = fzmi_o(ji,jj)  + fthk * (  &\par
                  fmigrow + (xphi * (fgmipn + fgmid)) + fmiexcr + ((1.0 - xbetan) * finmi) )\par
               fzme_i(ji,jj)  = fzme_i(ji,jj)  + fthk * (  &\par
                  fgmepn + fgmepd + fgmezmi + fgmed )\par
               fzme_o(ji,jj)  = fzme_o(ji,jj)  + fthk * (  &\par
                  fmegrow + (xphi * (fgmepn + fgmepd + fgmezmi + fgmed)) + fmeexcr + ((1.0 - xbetan) * finme) )\par
\par
               !!----------------------------------------------------------------------\par
               !! Plankton metabolic losses\par
               !! Linear loss processes assumed to be metabolic in origin\par
               !!----------------------------------------------------------------------\par
               !!\par
               fdpn2  = xmetapn  * zphn\par
               fdpd2  = xmetapd  * zphd\par
               fdpds2 = xmetapd  * zpds\par
               fdzmi2 = xmetazmi * zzmi\par
               fdzme2 = xmetazme * zzme\par
\par
               !!----------------------------------------------------------------------\par
               !! Plankton mortality losses\par
               !! EKP (26/02/09): phytoplankton hyperbolic mortality term introduced \par
               !! to improve performance in gyres\par
               !!----------------------------------------------------------------------\par
               !!\par
               !! non-diatom phytoplankton\par
               if (jmpn.eq.1) fdpn = xmpn * zphn               !! linear\par
               if (jmpn.eq.2) fdpn = xmpn * zphn * zphn        !! quadratic\par
               if (jmpn.eq.3) fdpn = xmpn * zphn * &           !! hyperbolic\par
                  (zphn / (xkphn + zphn))\par
               if (jmpn.eq.4) fdpn = xmpn * zphn * &           !! sigmoid\par
                  ((zphn * zphn) / (xkphn + (zphn * zphn)))\par
               !!\par
               !! diatom phytoplankton\par
               if (jmpd.eq.1) fdpd = xmpd * zphd               !! linear\par
               if (jmpd.eq.2) fdpd = xmpd * zphd * zphd        !! quadratic\par
               if (jmpd.eq.3) fdpd = xmpd * zphd * &           !! hyperbolic\par
                  (zphd / (xkphd + zphd))\par
               if (jmpd.eq.4) fdpd = xmpd * zphd * &           !! sigmoid\par
                  ((zphd * zphd) / (xkphd + (zphd * zphd)))\par
               fdpds = fdpd * fsin\par
               !!\par
               !! microzooplankton\par
               if (jmzmi.eq.1) fdzmi = xmzmi * zzmi            !! linear\par
               if (jmzmi.eq.2) fdzmi = xmzmi * zzmi * zzmi     !! quadratic\par
               if (jmzmi.eq.3) fdzmi = xmzmi * zzmi * &        !! hyperbolic\par
                  (zzmi / (xkzmi + zzmi))\par
               if (jmzmi.eq.4) fdzmi = xmzmi * zzmi * &        !! sigmoid\par
                  ((zzmi * zzmi) / (xkzmi + (zzmi * zzmi)))\par
               !!\par
               !! mesozooplankton\par
               if (jmzme.eq.1) fdzme = xmzme * zzme            !! linear\par
               if (jmzme.eq.2) fdzme = xmzme * zzme * zzme     !! quadratic\par
               if (jmzme.eq.3) fdzme = xmzme * zzme * &        !! hyperbolic\par
                  (zzme / (xkzme + zzme))\par
               if (jmzme.eq.4) fdzme = xmzme * zzme * &        !! sigmoid\par
                  ((zzme * zzme) / (xkzme + (zzme * zzme)))\par
\par
               !!----------------------------------------------------------------------\par
               !! Detritus remineralisation\par
               !! Constant or temperature-dependent\par
               !!----------------------------------------------------------------------\par
               !!\par
               if (jmd.eq.1) then\par
                  !! temperature-dependent\par
                  fdd  = xmd  * fun_T * zdet\par
# if defined key_roam\par
                  fddc = xmdc * fun_T * zdtc\par
# endif\par
               elseif (jmd.eq.2) then\par
                  !! AXY (16/05/13): add in Q10-based parameterisation (def in nmlst)\par
                  !! temperature-dependent\par
                  fdd  = xmd  * fun_Q10 * zdet\par
# if defined key_roam\par
                  fddc = xmdc * fun_Q10 * zdtc\par
# endif\par
               else\par
                  !! temperature-independent\par
                  fdd  = xmd  * zdet\par
# if defined key_roam\par
                  fddc = xmdc * zdtc\par
# endif\par
               endif\par
               !!\par
               !! AXY (22/07/09): accelerate detrital remineralisation in the bottom box\par
               if ((jk.eq.jmbathy) .and. jsfd.eq.1) then\par
                  fdd  = 1.0  * zdet\par
# if defined key_roam\par
                  fddc = 1.0  * zdtc\par
# endif\par
               endif\par
               \par
# if defined key_debug_medusa\par
               !! report plankton mortality and remineralisation\par
               if (idf.eq.1.AND.idfval.eq.1) then\par
                  IF (lwp) write (numout,*) '------------------------------'\par
                  IF (lwp) write (numout,*) 'fdpn2(',jk,') = ', fdpn2\par
                  IF (lwp) write (numout,*) 'fdpd2(',jk,') = ', fdpd2\par
                  IF (lwp) write (numout,*) 'fdpds2(',jk,')= ', fdpds2\par
                  IF (lwp) write (numout,*) 'fdzmi2(',jk,')= ', fdzmi2\par
                  IF (lwp) write (numout,*) 'fdzme2(',jk,')= ', fdzme2\par
                  IF (lwp) write (numout,*) 'fdpn(',jk,')  = ', fdpn\par
                  IF (lwp) write (numout,*) 'fdpd(',jk,')  = ', fdpd\par
                  IF (lwp) write (numout,*) 'fdpds(',jk,') = ', fdpds\par
                  IF (lwp) write (numout,*) 'fdzmi(',jk,') = ', fdzmi\par
                  IF (lwp) write (numout,*) 'fdzme(',jk,') = ', fdzme\par
                  IF (lwp) write (numout,*) 'fdd(',jk,')   = ', fdd\par
#  if defined key_roam\par
                  IF (lwp) write (numout,*) 'fddc(',jk,')  = ', fddc\par
#  endif\par
               endif\par
# endif\par
\par
               !!----------------------------------------------------------------------\par
               !! Detritus addition to benthos\par
               !! If activated, slow detritus in the bottom box will enter the\par
               !! benthic pool\par
               !!----------------------------------------------------------------------\par
               !!\par
               if ((jk.eq.jmbathy) .and. jorgben.eq.1) then\par
                  !! this is the BOTTOM OCEAN BOX -> into the benthic pool!\par
                  !!\par
                  f_sbenin_n(ji,jj)  = (zdet * vsed * 86400.)\par
                  f_sbenin_fe(ji,jj) = (zdet * vsed * 86400. * xrfn)\par
# if defined key_roam\par
                  f_sbenin_c(ji,jj)  = (zdtc * vsed * 86400.)\par
# else\par
                  f_sbenin_c(ji,jj)  = (zdet * vsed * 86400. * xthetad)\par
# endif\par
               endif\par
\par
               !!----------------------------------------------------------------------\par
               !! Iron chemistry and fractionation\par
               !! following the Parekh et al. (2004) scheme adopted by the Met.\par
               !! Office, Medusa models total iron but considers "free" and\par
               !! ligand-bound forms for the purposes of scavenging (only "free"\par
               !! iron can be scavenged\par
               !!----------------------------------------------------------------------\par
               !!\par
               !! total iron concentration (mmol Fe / m3 -> umol Fe / m3)\par
               xFeT        = zfer * 1.e3\par
               !!\par
               !! calculate fractionation (based on Diat-HadOCC; in turn based on Parekh et al., 2004)\par
               xb_coef_tmp = xk_FeL * (xLgT - xFeT) - 1.0\par
               xb2M4ac     = max(((xb_coef_tmp * xb_coef_tmp) + (4.0 * xk_FeL * xLgT)), 0.0)\par
               !!\par
               !! "free" ligand concentration\par
               xLgF        = 0.5 * (xb_coef_tmp + (xb2M4ac**0.5)) / xk_FeL\par
               !!\par
               !! ligand-bound iron concentration\par
               xFeL        = xLgT - xLgF\par
               !!\par
               !! "free" iron concentration (and convert to mmol Fe / m3)\par
               xFeF        = (xFeT - xFeL) * 1.e-3\par
               xFree(ji,jj)= xFeF / (zfer + tiny(zfer))\par
               !!\par
               !! scavenging of iron (multiple schemes); I'm only really happy with the \par
               !! first one at the moment - the others involve assumptions (sometimes\par
               !! guessed at by me) that are potentially questionable\par
               !!\par
               if (jiron.eq.1) then\par
                  !!----------------------------------------------------------------------\par
                  !! Scheme 1: Dutkiewicz et al. (2005)\par
                  !! This scheme includes a single scavenging term based solely on a\par
                  !! fixed rate and the availablility of "free" iron\par
                  !!----------------------------------------------------------------------\par
                  !!\par
                  ffescav     = xk_sc_Fe * xFeF                     ! = mmol/m3/d\par
                  !!\par
                  !!----------------------------------------------------------------------\par
                  !!\par
                  !! Mick's code contains a further (optional) implicit "scavenging" of \par
                  !! iron that sets an upper bound on "free" iron concentration, and \par
                  !! essentially caps the concentration of total iron as xFeL + "free" \par
                  !! iron; since the former is constrained by a fixed total ligand \par
                  !! concentration (= 1.0 umol/m3), and the latter isn't allowed above \par
                  !! this upper bound, total iron is constrained to a maximum of ...\par
                  !!\par
                  !!    xFeL + min(xFeF, 0.3 umol/m3) = 1.0 + 0.3 = 1.3 umol / m3\par
                  !! \par
                  !! In Mick's code, the actual value of total iron is reset to this\par
                  !! sum (i.e. TFe = FeL + Fe'; but Fe' <= 0.3 umol/m3); this isn't\par
                  !! our favoured approach to tracer updating here (not least because\par
                  !! of the leapfrog), so here the amount scavenged is augmented by an\par
                  !! additional amount that serves to drag total iron back towards that\par
                  !! expected from this limitation on iron concentration ...\par
                  !!\par
                  xmaxFeF     = min((xFeF * 1.e3), 0.3)             ! = umol/m3\par
                  !!\par
                  !! Here, the difference between current total Fe and (FeL + Fe') is\par
                  !! calculated and added to the scavenging flux already calculated\par
                  !! above ...\par
                  !!\par
                  fdeltaFe    = (xFeT - (xFeL + xmaxFeF)) * 1.e-3   ! = mmol/m3\par
                  !!\par
                  !! This assumes that the "excess" iron is dissipated with a time-\par
                  !! scale of 1 day; seems reasonable to me ... (famous last words)\par
                  !!\par
                  ffescav     = ffescav + fdeltaFe                  ! = mmol/m3/d\par
                  !!\par
# if defined key_deep_fe_fix\par
                  !! AXY (17/01/13)\par
                  !! stop scavenging for iron concentrations below 0.5 umol / m3\par
                  !! at depths greater than 1000 m; this aims to end MEDUSA's\par
                  !! continual loss of iron at depth without impacting things\par
                  !! at the surface too much; the justification for this is that\par
                  !! it appears to be what Mick Follows et al. do in their work\par
                  !! (as evidenced by the iron initial condition they supplied\par
                  !! me with); to be honest, it looks like Follow et al. do this\par
                  !! at shallower depths than 1000 m, but I'll stick with this\par
                  !! for now; I suspect that this seemingly arbitrary approach\par
                  !! effectively "parameterises" the particle-based scavenging\par
                  !! rates that other models use (i.e. at depth there are no\par
                  !! sinking particles, so scavenging stops); it might be fun\par
                  !! justifying this in a paper though!\par
                  !!\par
                  if ((fdep.gt.1000.) .and. (xFeT.lt.0.5)) then\par
                     ffescav = 0.\par
                  endif\par
# endif\par
                  !!\par
               elseif (jiron.eq.2) then\par
                  !!----------------------------------------------------------------------\par
                  !! Scheme 2: Moore et al. (2004)\par
                  !! This scheme includes a single scavenging term that accounts for\par
                  !! both suspended and sinking particles in the water column; this\par
                  !! term scavenges total iron rather than "free" iron\par
                  !!----------------------------------------------------------------------\par
                  !!\par
                  !! total iron concentration (mmol Fe / m3 -> umol Fe / m3)\par
                  xFeT        = zfer * 1.e3\par
                  !!\par
                  !! this has a base scavenging rate (12% / y) which is modified by local\par
                  !! particle concentration and sinking flux (and dust - but I'm ignoring\par
                  !! that here for now) and which is accelerated when Fe concentration gets\par
                  !! 0.6 nM (= 0.6 umol/m3 = 0.0006 mmol/m3), and decreased as concentrations\par
                  !! below 0.4 nM (= 0.4 umol/m3 = 0.0004 mmol/m3)\par
                  !!\par
                  !! base scavenging rate (0.12 / y)\par
                  fbase_scav = 0.12 / 365.25\par
                  !!\par
                  !! calculate sinking particle part of scaling factor\par
                  !! this takes local fast sinking carbon (mmol C / m2 / d) and\par
                  !! gets it into nmol C / cm3 / s ("rdt" below is the number of seconds in\par
                  !! a model timestep)\par
                  !!\par
                  !! fscal_sink = ffastc(ji,jj) * 1.e2 / (86400.)\par
                  !!\par
                  !! ... actually, re-reading Moore et al.'s equations, it looks like he uses\par
                  !! his sinking flux directly, without scaling it by time-step or anything,\par
                  !! so I'll copy this here ...\par
                  !!\par
                  fscal_sink = ffastc(ji,jj) * 1.e2\par
                  !!\par
                  !! calculate particle part of scaling factor\par
                  !! this totals up the carbon in suspended particles (Pn, Pd, Zmi, Zme, D),\par
                  !! which comes out in mmol C / m3 (= nmol C / cm3), and then multiplies it\par
                  !! by a magic factor, 0.002, to get it into nmol C / cm2 / s\par
                  !!\par
                  fscal_part = ((xthetapn * zphn) + (xthetapd * zphd) + (xthetazmi * zzmi) + &\par
                  (xthetazme * zzme) + (xthetad * zdet)) * 0.002\par
                  !!\par
                  !! calculate scaling factor for base scavenging rate\par
                  !! this uses the (now correctly scaled) sinking flux and standing\par
                  !! particle concentration, divides through by some sort of reference\par
                  !! value (= 0.0066 nmol C / cm2 / s) and then uses this, or not if its\par
                  !! too high, to rescale the base scavenging rate\par
                  !!\par
                  fscal_scav = fbase_scav * min(((fscal_sink + fscal_part) / 0.0066), 4.0)\par
                  !!\par
                  !! the resulting scavenging rate is then scaled further according to the\par
                  !! local iron concentration (i.e. diminished in low iron regions; enhanced\par
                  !! in high iron regions; less alone in intermediate iron regions)\par
                  !!\par
                  if (xFeT.lt.0.4) then\par
                     !!\par
                     !! low iron region\par
                     !!\par
                     fscal_scav = fscal_scav * (xFeT / 0.4)\par
                     !!\par
                  elseif (xFeT.gt.0.6) then\par
                     !!\par
                     !! high iron region\par
                     !!\par
                     fscal_scav = fscal_scav + ((xFeT / 0.6) * (6.0 / 1.4))\par
                     !!\par
                  else\par
                     !!\par
                     !! intermediate iron region: do nothing\par
                     !!\par
                  endif\par
                  !! \par
                  !! apply the calculated scavenging rate ...\par
                  !!\par
                  ffescav = fscal_scav * zfer\par
                  !!\par
               elseif (jiron.eq.3) then\par
                  !!----------------------------------------------------------------------\par
                  !! Scheme 3: Moore et al. (2008)\par
                  !! This scheme includes a single scavenging term that accounts for\par
                  !! sinking particles in the water column, and includes organic C,\par
                  !! biogenic opal, calcium carbonate and dust in this (though the\par
                  !! latter is ignored here until I work out what units the incoming\par
                  !! "dust" flux is in); this term scavenges total iron rather than \par
                  !! "free" iron\par
                  !!----------------------------------------------------------------------\par
                  !!\par
                  !! total iron concentration (mmol Fe / m3 -> umol Fe / m3)\par
                  xFeT        = zfer * 1.e3\par
                  !!\par
                  !! this has a base scavenging rate which is modified by local\par
                  !! particle sinking flux (including dust - but I'm ignoring that \par
                  !! here for now) and which is accelerated when Fe concentration\par
                  !! is > 0.6 nM (= 0.6 umol/m3 = 0.0006 mmol/m3), and decreased as \par
                  !! concentrations < 0.5 nM (= 0.5 umol/m3 = 0.0005 mmol/m3)\par
                  !!\par
                  !! base scavenging rate (Fe_b in paper; units may be wrong there)\par
                  fbase_scav = 0.00384 ! (ng)^-1 cm\par
                  !!\par
                  !! calculate sinking particle part of scaling factor; this converts\par
                  !! mmol / m2 / d fluxes of organic carbon, silicon and calcium\par
                  !! carbonate into ng / cm2 / s fluxes; it is assumed here that the\par
                  !! mass conversions simply consider the mass of the main element\par
                  !! (C, Si and Ca) and *not* the mass of the molecules that they are\par
                  !! part of; Moore et al. (2008) is unclear on the conversion that\par
                  !! should be used\par
                  !!\par
                  !! milli -> nano; mol -> gram; /m2 -> /cm2; /d -> /s\par
                  fscal_csink  = (ffastc(ji,jj)  * 1.e6 * xmassc  * 1.e-4 / 86400.)      ! ng C  / cm2 / s\par
                  fscal_sisink = (ffastsi(ji,jj) * 1.e6 * xmasssi * 1.e-4 / 86400.)      ! ng Si / cm2 / s\par
                  fscal_casink = (ffastca(ji,jj) * 1.e6 * xmassca * 1.e-4 / 86400.)      ! ng Ca / cm2 / s\par
                  !! \par
                  !! sum up these sinking fluxes and convert to ng / cm by dividing\par
                  !! through by a sinking rate of 100 m / d = 1.157 cm / s\par
                  fscal_sink   = ((fscal_csink * 6.) + fscal_sisink + fscal_casink) / &\par
                  (100. * 1.e3 / 86400)                                                  ! ng / cm\par
                  !!\par
                  !! now calculate the scavenging rate based upon the base rate and\par
                  !! this particle flux scaling; according to the published units,\par
                  !! the result actually has *no* units, but as it must be expressed\par
                  !! per unit time for it to make any sense, I'm assuming a missing\par
                  !! "per second"\par
                  fscal_scav = fbase_scav * fscal_sink                                   ! / s\par
                  !!\par
                  !! the resulting scavenging rate is then scaled further according to the\par
                  !! local iron concentration (i.e. diminished in low iron regions; enhanced\par
                  !! in high iron regions; less alone in intermediate iron regions)\par
                  !!\par
                  if (xFeT.lt.0.5) then\par
                     !!\par
                     !! low iron region (0.5 instead of the 0.4 in Moore et al., 2004)\par
                     !!\par
                     fscal_scav = fscal_scav * (xFeT / 0.5)\par
                     !!\par
                  elseif (xFeT.gt.0.6) then\par
                     !!\par
                     !! high iron region (functional form different in Moore et al., 2004)\par
                     !!\par
                     fscal_scav = fscal_scav + ((xFeT - 0.6) * 0.00904)\par
                     !!\par
                  else\par
                     !!\par
                     !! intermediate iron region: do nothing\par
                     !!\par
                  endif\par
                  !! \par
                  !! apply the calculated scavenging rate ...\par
                  !!\par
                  ffescav = fscal_scav * zfer\par
                  !!\par
               elseif (jiron.eq.4) then\par
                  !!----------------------------------------------------------------------\par
                  !! Scheme 4: Galbraith et al. (2010)\par
                  !! This scheme includes two scavenging terms, one for organic,\par
                  !! particle-based scavenging, and another for inorganic scavenging;\par
                  !! both terms scavenge "free" iron only\par
                  !!----------------------------------------------------------------------\par
                  !!\par
                  !! Galbraith et al. (2010) present a more straightforward outline of \par
                  !! the scheme in Parekh et al. (2005) ...\par
                  !! \par
                  !! sinking particulate carbon available for scavenging\par
                  !! this assumes a sinking rate of 100 m / d (Moore & Braucher, 2008),\par
                  xCscav1     = (ffastc(ji,jj) * xmassc) / 100. ! = mg C / m3\par
                  !! \par
                  !! scale by Honeyman et al. (1981) exponent coefficient\par
                  !! multiply by 1.e-3 to express C flux in g C rather than mg C\par
                  xCscav2     = (xCscav1 * 1.e-3)**0.58\par
                  !!\par
                  !! multiply by Galbraith et al. (2010) scavenging rate\par
                  xk_org      = 0.5 ! ((g C m/3)^-1) / d\par
                  xORGscav    = xk_org * xCscav2 * xFeF\par
                  !!\par
                  !! Galbraith et al. (2010) also include an inorganic bit ...\par
                  !! \par
                  !! this occurs at a fixed rate, again based on the availability of\par
                  !! "free" iron\par
                  !!\par
                  !! k_inorg  = 1000 d**-1 nmol Fe**-0.5 kg**-0.5\par
                  !!\par
                  !! to implement this here, scale xFeF by 1026 to put in units of\par
                  !! umol/m3 which approximately equal nmol/kg\par
                  !!\par
                  xk_inorg    = 1000. ! ((nmol Fe / kg)^1.5)\par
                  xINORGscav  = (xk_inorg * (xFeF * 1026.)**1.5) * 1.e-3\par
                  !!\par
                  !! sum these two terms together\par
                  ffescav     = xORGscav + xINORGscav\par
               else\par
                  !!----------------------------------------------------------------------\par
                  !! No Scheme: you coward!\par
                  !! This scheme puts its head in the sand and eskews any decision about\par
                  !! how iron is removed from the ocean; prepare to get deluged in iron\par
                  !! you fool!\par
                  !!----------------------------------------------------------------------\par
                  ffescav     = 0.\par
               endif\par
\par
               !!----------------------------------------------------------------------\par
               !! Other iron cycle processes\par
               !!----------------------------------------------------------------------\par
               !!\par
               !! aeolian iron deposition\par
               if (jk.eq.1) then\par
                  !! zirondep   is in mmol-Fe / m2 / day\par
                  !! ffetop     is in mmol-dissolved-Fe / m3 / day\par
                  ffetop  = zirondep(ji,jj) * xfe_sol / fthk \par
               else\par
                  ffetop  = 0.0\par
               endif\par
               !!\par
               !! seafloor iron addition\par
               !! AXY (10/07/12): amended to only apply sedimentary flux up to ~500 m down\par
               !! if (jk.eq.(mbathy(ji,jj)-1).AND.jk.lt.i1100) then\par
               if ((jk.eq.jmbathy).AND.jk.le.i0500) then\par
                  !! Moore et al. (2004) cite a coastal California value of 5 umol/m2/d, but adopt a\par
                  !! global value of 2 umol/m2/d for all areas < 1100 m; here we use this latter value\par
                  !! but apply it everywhere\par
                  !! AXY (21/07/09): actually, let's just apply it below 1100 m (levels 1-37)\par
                  ffebot  = (xfe_sed / fthk)\par
               else\par
                  ffebot  = 0.0\par
               endif\par
\par
               !! AXY (16/12/09): remove iron addition/removal processes\par
               !! For the purposes of the quarter degree run, the iron cycle is being pegged to the\par
               !! initial condition supplied by Mick Follows via restoration with a 30 day period;\par
               !! iron addition at the seafloor is still permitted with the idea that this extra\par
               !! iron will be removed by the restoration away from the source\par
               !! ffescav = 0.0\par
               !! ffetop  = 0.0\par
               !! ffebot  = 0.0\par
\par
# if defined key_debug_medusa\par
               !! report miscellaneous calculations\par
               if (idf.eq.1.AND.idfval.eq.1) then\par
                  IF (lwp) write (numout,*) '------------------------------'\par
                  IF (lwp) write (numout,*) 'xfe_sol  = ', xfe_sol\par
                  IF (lwp) write (numout,*) 'xfe_mass = ', xfe_mass\par
                  IF (lwp) write (numout,*) 'ffetop(',jk,')  = ', ffetop\par
                  IF (lwp) write (numout,*) 'ffebot(',jk,')  = ', ffebot\par
                  IF (lwp) write (numout,*) 'xFree(',jk,')   = ', xFree(ji,jj)\par
                  IF (lwp) write (numout,*) 'ffescav(',jk,') = ', ffescav\par
               endif\par
# endif\par
\par
               !!----------------------------------------------------------------------\par
               !! Miscellaneous\par
               !!----------------------------------------------------------------------\par
               !!\par
               !! diatom frustule dissolution\par
               fsdiss  = xsdiss * zpds\par
\par
# if defined key_debug_medusa\par
               !! report miscellaneous calculations\par
               if (idf.eq.1.AND.idfval.eq.1) then\par
                  IF (lwp) write (numout,*) '------------------------------'\par
                  IF (lwp) write (numout,*) 'fsdiss(',jk,')  = ', fsdiss\par
               endif\par
# endif\par
\par
               !!----------------------------------------------------------------------\par
               !! Slow detritus creation\par
               !!----------------------------------------------------------------------\par
               !! this variable integrates the creation of slow sinking detritus\par
               !! to allow the split between fast and slow detritus to be \par
               !! diagnosed\par
               fslown  = fdpn + fdzmi + ((1.0 - xfdfrac1) * fdpd) + &\par
               ((1.0 - xfdfrac2) * fdzme) + ((1.0 - xbetan) * (finmi + finme))\par
               !!\par
               !! this variable records the slow detrital sinking flux at this\par
               !! particular depth; it is used in the output of this flux at\par
               !! standard depths in the diagnostic outputs; needs to be\par
               !! adjusted from per second to per day because of parameter vsed\par
               fslownflux(ji,jj) = zdet * vsed * 86400.\par
# if defined key_roam\par
               !!\par
               !! and the same for detrital carbon\par
               fslowc  = (xthetapn * fdpn) + (xthetazmi * fdzmi) + &\par
               (xthetapd * (1.0 - xfdfrac1) * fdpd) + &\par
               (xthetazme * (1.0 - xfdfrac2) * fdzme) + &\par
               ((1.0 - xbetac) * (ficmi + ficme))\par
               !!\par
               !! this variable records the slow detrital sinking flux at this\par
               !! particular depth; it is used in the output of this flux at\par
               !! standard depths in the diagnostic outputs; needs to be\par
               !! adjusted from per second to per day because of parameter vsed\par
               fslowcflux(ji,jj) = zdtc * vsed * 86400.\par
# endif\par
\par
               !!----------------------------------------------------------------------\par
               !! Nutrient regeneration\par
               !! this variable integrates total nitrogen regeneration down the\par
               !! watercolumn; its value is stored and output as a 2D diagnostic;\par
               !! the corresponding dissolution flux of silicon (from sources\par
               !! other than fast detritus) is also integrated; note that,\par
               !! confusingly, the linear loss terms from plankton compartments\par
               !! are labelled as fdX2 when one might have expected fdX or fdX1\par
               !!----------------------------------------------------------------------\par
               !!\par
               !! nitrogen\par
               fregen   = (( (xphi * (fgmipn + fgmid)) +                &  ! messy feeding\par
               (xphi * (fgmepn + fgmepd + fgmezmi + fgmed)) +           &  ! messy feeding\par
               fmiexcr + fmeexcr + fdd +                                &  ! excretion + D remin.\par
               fdpn2 + fdpd2 + fdzmi2 + fdzme2) * fthk)                    ! linear mortality\par
               !!\par
               !! silicon\par
               fregensi = (( fsdiss + ((1.0 - xfdfrac1) * fdpds) +      &  ! dissolution + non-lin. mortality\par
               ((1.0 - xfdfrac3) * fgmepds) +                           &  ! egestion by zooplankton\par
               fdpds2) * fthk)                                             ! linear mortality\par
# if defined key_roam\par
               !!\par
               !! carbon\par
               fregenc  = (( (xphi * ((xthetapn * fgmipn) + fgmidc)) +  &  ! messy feeding\par
               (xphi * ((xthetapn * fgmepn) + (xthetapd * fgmepd) +     &  ! messy feeding\par
               (xthetazmi * fgmezmi) + fgmedc)) +                       &  ! messy feeding\par
               fmiresp + fmeresp + fddc +                               &  ! respiration + D remin.\par
               (xthetapn * fdpn2) + (xthetapd * fdpd2) +                &  ! linear mortality\par
               (xthetazmi * fdzmi2) + (xthetazme * fdzme2)) * fthk)        ! linear mortality\par
# endif\par
\par
               !!----------------------------------------------------------------------\par
               !! Fast-sinking detritus terms\par
               !! "local" variables declared so that conservation can be checked;\par
               !! the calculated terms are added to the fast-sinking flux later on\par
               !! only after the flux entering this level has experienced some\par
               !! remineralisation\par
               !! note: these fluxes need to be scaled by the level thickness\par
               !!----------------------------------------------------------------------\par
               !!\par
               !! nitrogen:   diatom and mesozooplankton mortality\par
               ftempn         = b0 * ((xfdfrac1 * fdpd)  + (xfdfrac2 * fdzme))\par
               !!\par
               !! silicon:    diatom mortality and grazed diatoms\par
               ftempsi        = b0 * ((xfdfrac1 * fdpds) + (xfdfrac3 * fgmepds))\par
               !!\par
               !! iron:       diatom and mesozooplankton mortality\par
               ftempfe        = b0 * (((xfdfrac1 * fdpd) + (xfdfrac2 * fdzme)) * xrfn)\par
               !!\par
               !! carbon:     diatom and mesozooplankton mortality\par
               ftempc         = b0 * ((xfdfrac1 * xthetapd * fdpd) + & \par
                                (xfdfrac2 * xthetazme * fdzme))\par
               !!\par
# if defined key_roam\par
               if (jrratio.eq.0) then\par
                  !! CaCO3:      latitudinally-based fraction of total primary production\par
                  !!               absolute latitude of current grid cell\par
                  flat           = abs(gphit(ji,jj))\par
                  !!               0.10 at equator; 0.02 at pole\par
                  fcaco3         = xcaco3a + ((xcaco3b - xcaco3a) * ((90.0 - flat) / 90.0))\par
               elseif (jrratio.eq.1) then\par
                  !! CaCO3:      Ridgwell et al. (2007) submodel, version 1\par
                  !!             this uses SURFACE omega calcite to regulate rain ratio\par
                  if (f_omcal(ji,jj).ge.1.0) then\par
                     fq1 = (f_omcal(ji,jj) - 1.0)**0.81\par
                  else\par
                     fq1 = 0.\par
                  endif\par
                  fcaco3 = xridg_r0 * fq1\par
               elseif (jrratio.eq.2) then\par
                  !! CaCO3:      Ridgwell et al. (2007) submodel, version 2\par
                  !!             this uses FULL 3D omega calcite to regulate rain ratio\par
                  if (f3_omcal(ji,jj,jk).ge.1.0) then\par
                     fq1 = (f3_omcal(ji,jj,jk) - 1.0)**0.81\par
                  else\par
                     fq1 = 0.\par
                  endif\par
                  fcaco3 = xridg_r0 * fq1\par
               endif\par
# else\par
               !! CaCO3:      latitudinally-based fraction of total primary production\par
               !!               absolute latitude of current grid cell\par
               flat           = abs(gphit(ji,jj))\par
               !!               0.10 at equator; 0.02 at pole\par
               fcaco3         = xcaco3a + ((xcaco3b - xcaco3a) * ((90.0 - flat) / 90.0))\par
# endif\par
               !! AXY (09/03/09): convert CaCO3 production from function of \par
               !! primary production into a function of fast-sinking material; \par
               !! technically, this is what Dunne et al. (2007) do anyway; they \par
               !! convert total primary production estimated from surface \par
               !! chlorophyll to an export flux for which they apply conversion \par
               !! factors to estimate the various elemental fractions (Si, Ca)\par
               ftempca        = ftempc * fcaco3\par
\par
# if defined key_debug_medusa\par
               !! integrate total fast detritus production\par
               if (idf.eq.1) then\par
                  fifd_n(ji,jj)  = fifd_n(ji,jj)  + (ftempn  * fthk)\par
                  fifd_si(ji,jj) = fifd_si(ji,jj) + (ftempsi * fthk)\par
                  fifd_fe(ji,jj) = fifd_fe(ji,jj) + (ftempfe * fthk)\par
#  if defined key_roam\par
                  fifd_c(ji,jj)  = fifd_c(ji,jj)  + (ftempc  * fthk)\par
#  endif\par
               endif\par
\par
               !! report quantities of fast-sinking detritus for each component\par
               if (idf.eq.1.AND.idfval.eq.1) then\par
                  IF (lwp) write (numout,*) '------------------------------'\par
                  IF (lwp) write (numout,*) 'fdpd(',jk,')    = ', fdpd\par
                  IF (lwp) write (numout,*) 'fdzme(',jk,')   = ', fdzme\par
                  IF (lwp) write (numout,*) 'ftempn(',jk,')  = ', ftempn\par
                  IF (lwp) write (numout,*) 'ftempsi(',jk,') = ', ftempsi\par
                  IF (lwp) write (numout,*) 'ftempfe(',jk,') = ', ftempfe\par
                  IF (lwp) write (numout,*) 'ftempc(',jk,')  = ', ftempc\par
                  IF (lwp) write (numout,*) 'ftempca(',jk,') = ', ftempca\par
                  IF (lwp) write (numout,*) 'flat(',jk,')    = ', flat\par
                  IF (lwp) write (numout,*) 'fcaco3(',jk,')  = ', fcaco3\par
               endif\par
# endif\par
\par
               !!----------------------------------------------------------------------\par
               !! This version of MEDUSA offers a choice of three methods for\par
               !! handling the remineralisation of fast detritus.  All three\par
               !! do so in broadly the same way:\par
               !!\par
               !!   1.  Fast detritus is stored as a 2D array                   [ ffastX  ]\par
               !!   2.  Fast detritus is added level-by-level                   [ ftempX  ]\par
               !!   3.  Fast detritus is not remineralised in the top box       [ freminX ]\par
               !!   4.  Remaining fast detritus is remineralised in the bottom  [ fsedX   ]\par
               !!       box\par
               !!\par
               !! The three remineralisation methods are:\par
               !!   \par
               !!   1.  Ballast model (i.e. that published in Yool et al., 2011)\par
               !!  (1b. Ballast-sans-ballast model)\par
               !!   2.  Martin et al. (1987)\par
               !!   3.  Henson et al. (2011)\par
               !! \par
               !! The first of these couples C, N and Fe remineralisation to\par
               !! the remineralisation of particulate Si and CaCO3, but the \par
               !! latter two treat remineralisation of C, N, Fe, Si and CaCO3\par
               !! completely separately.  At present a switch within the code\par
               !! regulates which submodel is used, but this should be moved\par
               !! to the namelist file.\par
               !! \par
               !! The ballast-sans-ballast submodel is an original development\par
               !! feature of MEDUSA in which the ballast submodel's general\par
               !! framework and parameterisation is used, but in which there\par
               !! is no protection of organic material afforded by ballasting\par
               !! minerals.  While similar, it is not the same as the Martin \par
               !! et al. (1987) submodel.\par
               !!\par
               !! Since the three submodels behave the same in terms of\par
               !! accumulating sinking material and remineralising it all at\par
               !! the seafloor, these portions of the code below are common to\par
               !! all three.\par
               !!----------------------------------------------------------------------\par
\par
               if (jexport.eq.1) then\par
                  !!======================================================================\par
                  !! BALLAST SUBMODEL\par
                  !!======================================================================\par
                  !! \par
                  !!----------------------------------------------------------------------\par
                  !! Fast-sinking detritus fluxes, pt. 1: REMINERALISATION\par
                  !! aside from explicitly modelled, slow-sinking detritus, the\par
                  !! model includes an implicit representation of detrital\par
                  !! particles that sink too quickly to be modelled with\par
                  !! explicit state variables; this sinking flux is instead\par
                  !! instantaneously remineralised down the water column using\par
                  !! the version of Armstrong et al. (2002)'s ballast model\par
                  !! used by Dunne et al. (2007); the version of this model\par
                  !! here considers silicon and calcium carbonate ballast\par
                  !! minerals; this section of the code redistributes the fast\par
                  !! sinking material generated locally down the water column;\par
                  !! this differs from Dunne et al. (2007) in that fast sinking\par
                  !! material is distributed at *every* level below that it is\par
                  !! generated, rather than at every level below some fixed\par
                  !! depth; this scheme is also different in that sinking material \par
                  !! generated in one level is aggregated with that generated by\par
                  !! shallower levels; this should make the ballast model more\par
                  !! self-consistent (famous last words)\par
                  !!----------------------------------------------------------------------\par
                  !!\par
                  if (jk.eq.1) then\par
                     !! this is the SURFACE OCEAN BOX (no remineralisation)\par
                     !!\par
                     freminc  = 0.0\par
                     freminn  = 0.0\par
                     freminfe = 0.0\par
                     freminsi = 0.0\par
                     freminca = 0.0\par
                  elseif (jk.le.jmbathy) then\par
                     !! this is an OCEAN BOX (remineralise some material)\par
                     !!\par
                     !! set up CCD depth to be used depending on user choice\par
                     if (jocalccd.eq.0) then\par
                        !! use default CCD field\par
                        fccd_dep = ocal_ccd(ji,jj)\par
                     elseif (jocalccd.eq.1) then\par
                        !! use calculated CCD field\par
                        fccd_dep = f2_ccd_cal(ji,jj)\par
                     endif\par
                     !!\par
                     !! === organic carbon ===\par
                     fq0      = ffastc(ji,jj)                        !! how much organic C enters this box        (mol)\par
                     if (iball.eq.1) then\par
                        fq1      = (fq0 * xmassc)                    !! how much it weighs                        (mass)\par
                        fq2      = (ffastca(ji,jj) * xmassca)        !! how much CaCO3 enters this box            (mass)\par
                        fq3      = (ffastsi(ji,jj) * xmasssi)        !! how much  opal enters this box            (mass)\par
                        fq4      = (fq2 * xprotca) + (fq3 * xprotsi) !! total protected organic C                 (mass)\par
                        !! this next term is calculated for C but used for N and Fe as well\par
                        !! it needs to be protected in case ALL C is protected\par
                        if (fq4.lt.fq1) then\par
                           fprotf   = (fq4 / (fq1 + tiny(fq1)))      !! protected fraction of total organic C     (non-dim)\par
                        else\par
                           fprotf   = 1.0                            !! all organic C is protected                (non-dim)\par
                        endif\par
                        fq5      = (1.0 - fprotf)                    !! unprotected fraction of total organic C   (non-dim)\par
                        fq6      = (fq0 * fq5)                       !! how much organic C is unprotected         (mol)\par
                        fq7      = (fq6 * exp(-(fthk / xfastc)))     !! how much unprotected C leaves this box    (mol)\par
                        fq8      = (fq7 + (fq0 * fprotf))            !! how much total C leaves this box          (mol)\par
                        freminc  = (fq0 - fq8) / fthk                !! C remineralisation in this box            (mol)\par
                        ffastc(ji,jj) = fq8                          \par
# if defined key_debug_medusa\par
                        !! report in/out/remin fluxes of carbon for this level\par
                           if (idf.eq.1.AND.idfval.eq.1) then\par
                              IF (lwp) write (numout,*) '------------------------------'\par
                              IF (lwp) write (numout,*) 'totalC(',jk,')  = ', fq1\par
                              IF (lwp) write (numout,*) 'prtctC(',jk,')  = ', fq4\par
                              IF (lwp) write (numout,*) 'fprotf(',jk,')  = ', fprotf\par
                              IF (lwp) write (numout,*) '------------------------------'\par
                              IF (lwp) write (numout,*) 'IN   C(',jk,')  = ', fq0\par
                              IF (lwp) write (numout,*) 'LOST C(',jk,')  = ', freminc * fthk\par
                              IF (lwp) write (numout,*) 'OUT  C(',jk,')  = ', fq8\par
                              IF (lwp) write (numout,*) 'NEW  C(',jk,')  = ', ftempc * fthk\par
                           endif\par
# endif\par
                        else\par
                        fq1      = fq0 * exp(-(fthk / xfastc))       !! how much organic C leaves this box        (mol)\par
                        freminc  = (fq0 - fq1) / fthk                !! C remineralisation in this box            (mol)\par
                        ffastc(ji,jj)  = fq1\par
                     endif\par
                     !!\par
                     !! === organic nitrogen ===\par
                     fq0      = ffastn(ji,jj)                        !! how much organic N enters this box        (mol)\par
                     if (iball.eq.1) then\par
                        fq5      = (1.0 - fprotf)                    !! unprotected fraction of total organic N   (non-dim)\par
                        fq6      = (fq0 * fq5)                       !! how much organic N is unprotected         (mol)\par
                        fq7      = (fq6 * exp(-(fthk / xfastc)))     !! how much unprotected N leaves this box    (mol)\par
                        fq8      = (fq7 + (fq0 * fprotf))            !! how much total N leaves this box          (mol)\par
                        freminn  = (fq0 - fq8) / fthk                !! N remineralisation in this box            (mol)\par
                        ffastn(ji,jj)  = fq8\par
# if defined key_debug_medusa\par
                        !! report in/out/remin fluxes of carbon for this level\par
                        if (idf.eq.1.AND.idfval.eq.1) then\par
                           IF (lwp) write (numout,*) '------------------------------'\par
                           IF (lwp) write (numout,*) 'totalN(',jk,')  = ', fq1\par
                           IF (lwp) write (numout,*) 'prtctN(',jk,')  = ', fq4\par
                           IF (lwp) write (numout,*) 'fprotf(',jk,')  = ', fprotf\par
                           IF (lwp) write (numout,*) '------------------------------'\par
                           if (freminn < 0.0) then\par
                              IF (lwp) write (numout,*) '** FREMIN ERROR **'\par
                           endif\par
                           IF (lwp) write (numout,*) 'IN   N(',jk,')  = ', fq0\par
                           IF (lwp) write (numout,*) 'LOST N(',jk,')  = ', freminn * fthk\par
                           IF (lwp) write (numout,*) 'OUT  N(',jk,')  = ', fq8\par
                           IF (lwp) write (numout,*) 'NEW  N(',jk,')  = ', ftempn * fthk\par
                        endif\par
# endif\par
                     else\par
                        fq1      = fq0 * exp(-(fthk / xfastc))       !! how much organic N leaves this box        (mol)\par
                        freminn  = (fq0 - fq1) / fthk                !! N remineralisation in this box            (mol)\par
                        ffastn(ji,jj)  = fq1\par
                     endif\par
                     !!\par
                     !! === organic iron ===\par
                     fq0      = ffastfe(ji,jj)                       !! how much organic Fe enters this box       (mol)\par
                     if (iball.eq.1) then\par
                        fq5      = (1.0 - fprotf)                    !! unprotected fraction of total organic Fe  (non-dim)\par
                        fq6      = (fq0 * fq5)                       !! how much organic Fe is unprotected        (mol)\par
                        fq7      = (fq6 * exp(-(fthk / xfastc)))     !! how much unprotected Fe leaves this box   (mol)\par
                        fq8      = (fq7 + (fq0 * fprotf))            !! how much total Fe leaves this box         (mol)            \par
                        freminfe = (fq0 - fq8) / fthk                !! Fe remineralisation in this box           (mol)\par
                        ffastfe(ji,jj) = fq8\par
                     else\par
                        fq1      = fq0 * exp(-(fthk / xfastc))       !! how much total Fe leaves this box         (mol)      \par
                        freminfe = (fq0 - fq1) / fthk                !! Fe remineralisation in this box           (mol)\par
                        ffastfe(ji,jj) = fq1\par
                     endif\par
                     !!\par
                     !! === biogenic silicon ===\par
                     fq0      = ffastsi(ji,jj)                       !! how much  opal centers this box           (mol) \par
                     fq1      = fq0 * exp(-(fthk / xfastsi))         !! how much  opal leaves this box            (mol)\par
                     freminsi = (fq0 - fq1) / fthk                   !! Si remineralisation in this box           (mol)\par
                     ffastsi(ji,jj) = fq1\par
                     !!\par
                     !! === biogenic calcium carbonate ===\par
                     fq0      = ffastca(ji,jj)                       !! how much CaCO3 enters this box            (mol)\par
                     if (fdep.le.fccd_dep) then\par
                        !! whole grid cell above CCD\par
                        fq1      = fq0                               !! above lysocline, no Ca dissolves          (mol)\par
                        freminca = 0.0                               !! above lysocline, no Ca dissolves          (mol)\par
                        fccd(ji,jj) = real(jk)                       !! which is the last level above the CCD?    (#)\par
                     elseif (fdep.ge.fccd_dep) then\par
                        !! whole grid cell below CCD\par
                        fq1      = fq0 * exp(-(fthk / xfastca))      !! how much CaCO3 leaves this box            (mol)\par
                        freminca = (fq0 - fq1) / fthk                !! Ca remineralisation in this box           (mol)\par
                     else\par
                        !! partial grid cell below CCD\par
                        fq2      = fdep1 - fccd_dep                  !! amount of grid cell below CCD             (m)\par
                        fq1      = fq0 * exp(-(fq2 / xfastca))       !! how much CaCO3 leaves this box            (mol)\par
                        freminca = (fq0 - fq1) / fthk                !! Ca remineralisation in this box           (mol)\par
                     endif\par
                     ffastca(ji,jj) = fq1 \par
                  else\par
                     !! this is BELOW THE LAST OCEAN BOX (do nothing)\par
                     freminc  = 0.0\par
                     freminn  = 0.0\par
                     freminfe = 0.0\par
                     freminsi = 0.0\par
                     freminca = 0.0              \par
                  endif\par
\par
               elseif (jexport.eq.2.or.jexport.eq.3) then\par
                  if (jexport.eq.2) then\par
                     !!======================================================================\par
                     !! MARTIN ET AL. (1987) SUBMODEL\par
                     !!======================================================================\par
                     !! \par
                     !!----------------------------------------------------------------------\par
                     !! This submodel uses the classic Martin et al. (1987) curve\par
                     !! to determine the attenuation of fast-sinking detritus down\par
                     !! the water column.  All three organic elements, C, N and Fe,\par
                     !! are handled identically, and their quantities in sinking\par
                     !! particles attenuate according to a power relationship\par
                     !! governed by parameter "b".  This is assigned a canonical \par
                     !! value of -0.858.  Biogenic opal and calcium carbonate are\par
                     !! attentuated using the same function as in the ballast\par
                     !! submodel\par
                     !!----------------------------------------------------------------------\par
                     !!\par
                     fb_val = -0.858\par
                  elseif (jexport.eq.3) then\par
                     !!======================================================================\par
                     !! HENSON ET AL. (2011) SUBMODEL\par
                     !!======================================================================\par
                     !!\par
                     !!----------------------------------------------------------------------\par
                     !! This submodel reconfigures the Martin et al. (1987) curve by\par
                     !! allowing the "b" value to vary geographically.  Its value is\par
                     !! set, following Henson et al. (2011), as a function of local\par
                     !! sea surface temperature:\par
                     !!   b = -1.06 + (0.024 * SST)\par
                     !! This means that remineralisation length scales are longer in\par
                     !! warm, tropical areas and shorter in cold, polar areas.  This\par
                     !! does seem back-to-front (i.e. one would expect GREATER\par
                     !! remineralisation in warmer waters), but is an outcome of \par
                     !! analysis of sediment trap data, and it may reflect details\par
                     !! of ecosystem structure that pertain to particle production\par
                     !! rather than simply Q10.\par
                     !!----------------------------------------------------------------------\par
                     !!\par
                     fl_sst = tsn(ji,jj,1,jp_tem)\par
                     fb_val = -1.06 + (0.024 * fl_sst)\par
                  endif\par
                  !!   \par
                  if (jk.eq.1) then\par
                     !! this is the SURFACE OCEAN BOX (no remineralisation)\par
                     !!\par
                     freminc  = 0.0\par
                     freminn  = 0.0\par
                     freminfe = 0.0\par
                     freminsi = 0.0\par
                     freminca = 0.0\par
                  elseif (jk.le.jmbathy) then\par
                     !! this is an OCEAN BOX (remineralise some material)\par
                     !!\par
                     !! === organic carbon ===\par
                     fq0      = ffastc(ji,jj)                        !! how much organic C enters this box        (mol)\par
                     fq1      = fq0 * ((fdep1/fdep)**fb_val)         !! how much organic C leaves this box        (mol)\par
                     freminc  = (fq0 - fq1) / fthk                   !! C remineralisation in this box            (mol)\par
                     ffastc(ji,jj)  = fq1\par
                     !!\par
                     !! === organic nitrogen ===\par
                     fq0      = ffastn(ji,jj)                        !! how much organic N enters this box        (mol)\par
                     fq1      = fq0 * ((fdep1/fdep)**fb_val)         !! how much organic N leaves this box        (mol)\par
                     freminn  = (fq0 - fq1) / fthk                   !! N remineralisation in this box            (mol)\par
                     ffastn(ji,jj)  = fq1\par
                     !!\par
                     !! === organic iron ===\par
                     fq0      = ffastfe(ji,jj)                       !! how much organic Fe enters this box       (mol)\par
                     fq1      = fq0 * ((fdep1/fdep)**fb_val)         !! how much organic Fe leaves this box       (mol)\par
                     freminfe = (fq0 - fq1) / fthk                   !! Fe remineralisation in this box           (mol)\par
                     ffastfe(ji,jj) = fq1\par
                     !!\par
                     !! === biogenic silicon ===\par
                     fq0      = ffastsi(ji,jj)                       !! how much  opal centers this box           (mol) \par
                     fq1      = fq0 * exp(-(fthk / xfastsi))         !! how much  opal leaves this box            (mol)\par
                     freminsi = (fq0 - fq1) / fthk                   !! Si remineralisation in this box           (mol)\par
                     ffastsi(ji,jj) = fq1\par
                     !!\par
                     !! === biogenic calcium carbonate ===\par
                     fq0      = ffastca(ji,jj)                       !! how much CaCO3 enters this box            (mol)\par
                     if (fdep.le.ocal_ccd(ji,jj)) then\par
                        !! whole grid cell above CCD\par
                        fq1      = fq0                               !! above lysocline, no Ca dissolves          (mol)\par
                        freminca = 0.0                               !! above lysocline, no Ca dissolves          (mol)\par
                        fccd(ji,jj) = real(jk)                       !! which is the last level above the CCD?    (#)\par
                     elseif (fdep.ge.ocal_ccd(ji,jj)) then\par
                        !! whole grid cell below CCD\par
                        fq1      = fq0 * exp(-(fthk / xfastca))      !! how much CaCO3 leaves this box            (mol)\par
                        freminca = (fq0 - fq1) / fthk                !! Ca remineralisation in this box           (mol)\par
                     else\par
                        !! partial grid cell below CCD\par
                        fq2      = fdep1 - ocal_ccd(ji,jj)           !! amount of grid cell below CCD             (m)\par
                        fq1      = fq0 * exp(-(fq2 / xfastca))       !! how much CaCO3 leaves this box            (mol)\par
                        freminca = (fq0 - fq1) / fthk                !! Ca remineralisation in this box           (mol)\par
                     endif\par
                     ffastca(ji,jj) = fq1 \par
                  else\par
                     !! this is BELOW THE LAST OCEAN BOX (do nothing)\par
                     freminc  = 0.0\par
                     freminn  = 0.0\par
                     freminfe = 0.0\par
                     freminsi = 0.0\par
                     freminca = 0.0              \par
                  endif\par
\par
               endif\par
\par
               !!----------------------------------------------------------------------\par
               !! Fast-sinking detritus fluxes, pt. 2: UPDATE FAST FLUXES\par
               !! here locally calculated additions to the fast-sinking flux are added\par
               !! to the total fast-sinking flux; this is done here such that material\par
               !! produced in a particular layer is only remineralised below this\par
               !! layer\par
               !!----------------------------------------------------------------------\par
               !!\par
               !! add sinking material generated in this layer to running totals\par
               !!\par
               !! === organic carbon ===                          (diatom and mesozooplankton mortality)\par
               ffastc(ji,jj)  = ffastc(ji,jj)  + (ftempc  * fthk)\par
               !!\par
               !! === organic nitrogen ===                        (diatom and mesozooplankton mortality)\par
               ffastn(ji,jj)  = ffastn(ji,jj)  + (ftempn  * fthk)\par
               !!\par
               !! === organic iron ===                            (diatom and mesozooplankton mortality)\par
               ffastfe(ji,jj) = ffastfe(ji,jj) + (ftempfe * fthk)\par
               !!\par
               !! === biogenic silicon ===                        (diatom mortality and grazed diatoms)\par
               ffastsi(ji,jj) = ffastsi(ji,jj) + (ftempsi * fthk)\par
               !!\par
               !! === biogenic calcium carbonate ===              (latitudinally-based fraction of total primary production)\par
               ffastca(ji,jj) = ffastca(ji,jj) + (ftempca * fthk)\par
\par
               !!----------------------------------------------------------------------\par
               !! Fast-sinking detritus fluxes, pt. 3: SEAFLOOR\par
               !! remineralise all remaining fast-sinking detritus to dissolved\par
               !! nutrients; the sedimentation fluxes calculated here allow the\par
               !! separation of what's remineralised sinking through the final\par
               !! ocean box from that which is added to the final box by the\par
               !! remineralisation of material that reaches the seafloor (i.e.\par
               !! the model assumes that *all* material that hits the seafloor\par
               !! is remineralised and that none is permanently buried; hey,\par
               !! this is a giant GCM model that can't be run for long enough\par
               !! to deal with burial fluxes!)\par
               !!\par
               !! in a change to this process, in part so that MEDUSA behaves\par
               !! a little more like ERSEM et al., fast-sinking detritus (N, Fe\par
               !! and C) is converted to slow sinking detritus at the seafloor\par
               !! instead of being remineralised; the rationale is that in\par
               !! shallower shelf regions (... that are not fully mixed!) this\par
               !! allows the detrital material to return slowly to dissolved \par
               !! nutrient rather than instantaneously as now; the alternative\par
               !! would be to explicitly handle seafloor organic material - a\par
               !! headache I don't wish to experience at this point; note that\par
               !! fast-sinking Si and Ca detritus is just remineralised as \par
               !! per usual\par
               !! \par
               !! AXY (13/01/12)\par
               !! in a further change to this process, again so that MEDUSA is\par
               !! a little more like ERSEM et al., material that reaches the\par
               !! seafloor can now be added to sediment pools and stored for\par
               !! slow release; there are new 2D arrays for organic nitrogen,\par
               !! iron and carbon and inorganic silicon and carbon that allow\par
               !! fast and slow detritus that reaches the seafloor to be held\par
               !! and released back to the water column more slowly; these arrays\par
               !! are transferred via the tracer restart files between repeat\par
               !! submissions of the model\par
               !!----------------------------------------------------------------------\par
               !! \par
               ffast2slowc  = 0.0\par
               ffast2slown  = 0.0\par
               ffast2slowfe = 0.0\par
               !!\par
               if (jk.eq.jmbathy) then\par
                  !! this is the BOTTOM OCEAN BOX (remineralise everything)\par
                  !!\par
                  !! AXY (17/01/12): tweaked to include benthos pools\par
                  !! \par
                  !! === organic carbon ===\par
                  if (jfdfate.eq.0 .and. jorgben.eq.0) then\par
                     freminc  = freminc + (ffastc(ji,jj) / fthk)    !! C remineralisation in this box            (mol/m3)\par
                  elseif (jfdfate.eq.1 .and. jorgben.eq.0) then\par
                     ffast2slowc = ffastc(ji,jj) / fthk             !! fast C -> slow C                          (mol/m3)\par
                     fslowc      = fslowc + ffast2slowc\par
                  elseif (jfdfate.eq.0 .and. jorgben.eq.1) then\par
                     f_fbenin_c(ji,jj)  = ffastc(ji,jj)             !! fast C -> benthic C                       (mol/m2)\par
                  endif\par
                  fsedc(ji,jj)   = ffastc(ji,jj)                          !! record seafloor C                         (mol/m2)\par
                  ffastc(ji,jj)  = 0.0\par
                  !!\par
                  !! === organic nitrogen ===\par
                  if (jfdfate.eq.0 .and. jorgben.eq.0) then\par
                     freminn  = freminn + (ffastn(ji,jj) / fthk)    !! N remineralisation in this box            (mol/m3)\par
                  elseif (jfdfate.eq.1 .and. jorgben.eq.0) then\par
                     ffast2slown = ffastn(ji,jj) / fthk             !! fast N -> slow N                          (mol/m3)\par
                     fslown      = fslown + ffast2slown\par
                  elseif (jfdfate.eq.0 .and. jorgben.eq.1) then\par
                     f_fbenin_n(ji,jj)  = ffastn(ji,jj)             !! fast N -> benthic N                       (mol/m2)\par
                  endif\par
                  fsedn(ji,jj)   = ffastn(ji,jj)                          !! record seafloor N                         (mol/m2)\par
                  ffastn(ji,jj)  = 0.0\par
                  !!\par
                  !! === organic iron ===\par
                  if (jfdfate.eq.0 .and. jorgben.eq.0) then\par
                     freminfe = freminfe + (ffastfe(ji,jj) / fthk)  !! Fe remineralisation in this box           (mol/m3)\par
                  elseif (jfdfate.eq.1 .and. jorgben.eq.0) then\par
                     ffast2slowfe = ffastn(ji,jj) / fthk            !! fast Fe -> slow Fe                        (mol/m3)\par
                  elseif (jfdfate.eq.0 .and. jorgben.eq.1) then\par
                     f_fbenin_fe(ji,jj) = ffastfe(ji,jj)            !! fast Fe -> benthic Fe                     (mol/m2)\par
                  endif\par
                  fsedfe(ji,jj)  = ffastfe(ji,jj)                         !! record seafloor Fe                        (mol/m2)\par
                  ffastfe(ji,jj) = 0.0\par
                  !!\par
                  !! === biogenic silicon ===\par
                  if (jinorgben.eq.0) then\par
                     freminsi = freminsi + (ffastsi(ji,jj) / fthk)  !! Si remineralisation in this box           (mol/m3)\par
                  elseif (jinorgben.eq.1) then\par
                     f_fbenin_si(ji,jj) = ffastsi(ji,jj)            !! fast Si -> benthic Si                     (mol/m2)\par
                  endif\par
                  fsedsi(ji,jj)   = ffastsi(ji,jj)                         !! record seafloor Si                        (mol/m2)\par
                  ffastsi(ji,jj) = 0.0\par
                  !!\par
                  !! === biogenic calcium carbonate ===\par
                  if (jinorgben.eq.0) then\par
                     freminca = freminca + (ffastca(ji,jj) / fthk)  !! Ca remineralisation in this box           (mol/m3) \par
                  elseif (jinorgben.eq.1) then\par
                     f_fbenin_ca(ji,jj) = ffastca(ji,jj)            !! fast Ca -> benthic Ca                     (mol/m2)\par
                  endif\par
                  fsedca(ji,jj)   = ffastca(ji,jj)                         !! record seafloor Ca                        (mol/m2)\par
                  ffastca(ji,jj) = 0.0\par
               endif\par
\par
# if defined key_debug_medusa\par
               if (idf.eq.1) then\par
                  !!----------------------------------------------------------------------\par
                  !! Integrate total fast detritus remineralisation\par
                  !!----------------------------------------------------------------------\par
                  !!\par
                  fofd_n(ji,jj)  = fofd_n(ji,jj)  + (freminn  * fthk)\par
                  fofd_si(ji,jj) = fofd_si(ji,jj) + (freminsi * fthk)\par
                  fofd_fe(ji,jj) = fofd_fe(ji,jj) + (freminfe * fthk)\par
#  if defined key_roam\par
                  fofd_c(ji,jj)  = fofd_c(ji,jj)  + (freminc  * fthk)\par
#  endif\par
               endif\par
# endif\par
\par
               !!----------------------------------------------------------------------\par
               !! Sort out remineralisation tally of fast-sinking detritus\par
               !!----------------------------------------------------------------------\par
               !!\par
               !! update fast-sinking regeneration arrays\par
               fregenfast(ji,jj)   = fregenfast(ji,jj)   + (freminn  * fthk)\par
               fregenfastsi(ji,jj) = fregenfastsi(ji,jj) + (freminsi * fthk)\par
# if defined key_roam\par
               fregenfastc(ji,jj)  = fregenfastc(ji,jj)  + (freminc  * fthk)\par
# endif\par
\par
               !!----------------------------------------------------------------------\par
               !! Benthic remineralisation fluxes\par
               !!----------------------------------------------------------------------\par
               !!\par
               if (jk.eq.jmbathy) then\par
                  !!\par
                  !! organic components\par
                  if (jorgben.eq.1) then\par
                     f_benout_n(ji,jj)  = xsedn  * zn_sed_n(ji,jj)\par
                     f_benout_fe(ji,jj) = xsedfe * zn_sed_fe(ji,jj)\par
                     f_benout_c(ji,jj)  = xsedc  * zn_sed_c(ji,jj)\par
                  endif\par
                  !!\par
                  !! inorganic components\par
                  if (jinorgben.eq.1) then\par
                     f_benout_si(ji,jj) = xsedsi * zn_sed_si(ji,jj)\par
                     f_benout_ca(ji,jj) = xsedca * zn_sed_ca(ji,jj)\par
                     !!\par
                     !! account for CaCO3 that dissolves when it shouldn't\par
                     if ( fdep .le. fccd_dep ) then\par
                        f_benout_lyso_ca(ji,jj) = xsedca * zn_sed_ca(ji,jj)\par
                     endif\par
                  endif\par
               endif\par
               CALL flush(numout)\par
\par
# if defined key_foam_medusa\par
               !!----------------------------------------------------------------------\par
               !! Mixed layer averages for ocean colour assimilation\par
               !!----------------------------------------------------------------------\par
               !!\par
               if (fdep1.le.hmld(ji,jj)) then\par
                  !! this level is entirely in the mixed layer\par
                  fq0 = 1.0\par
               elseif (fdep.ge.hmld(ji,jj)) then\par
                  !! this level is entirely below the mixed layer\par
                  fq0 = 0.0\par
               else\par
                  !! this level straddles the mixed layer\par
                  fq0 = (hmld(ji,jj) - fdep) / fthk\par
               endif\par
               !!\par
               pgrow_avg(ji,jj) = pgrow_avg(ji,jj) + ( &\par
                  ( (fprn * zphn) + (fprd * zphd) ) * fthk * fq0)\par
               ploss_avg(ji,jj) = ploss_avg(ji,jj) + ( &\par
                  ( fgmipn + fgmepn + fdpn + fdpn2 + fgmepd + fdpd + fdpd2 ) * fthk * fq0 )\par
               phyt_avg(ji,jj)  = phyt_avg(ji,jj)  + ( &\par
                  (zphn +zphd) * fthk * fq0 )\par
               !!\par
# endif\par
               !!======================================================================\par
               !! LOCAL GRID CELL TRENDS\par
               !!======================================================================\par
               !!\par
               !!----------------------------------------------------------------------\par
               !! Determination of trends\par
               !!----------------------------------------------------------------------\par
               !!\par
               !!----------------------------------------------------------------------\par
               !! chlorophyll\par
               btra(jpchn) = b0 * ( &\par
                 + ((frn * fprn * zphn) - fgmipn - fgmepn - fdpn - fdpn2) * (fthetan / xxi) )\par
               btra(jpchd) = b0 * ( &\par
                 + ((frd * fprd * zphd) - fgmepd - fdpd - fdpd2) * (fthetad / xxi) )\par
               !!\par
               !!----------------------------------------------------------------------\par
               !! phytoplankton\par
               btra(jpphn) = b0 * ( &\par
                 + (fprn * zphn) - fgmipn - fgmepn - fdpn - fdpn2 )\par
               btra(jpphd) = b0 * ( &\par
                 + (fprd * zphd) - fgmepd - fdpd - fdpd2 )\par
               btra(jppds) = b0 * ( &\par
                 + (fprds * zpds) - fgmepds - fdpds - fsdiss - fdpds2 )\par
               !!\par
               !!----------------------------------------------------------------------\par
               !! zooplankton\par
               btra(jpzmi) = b0 * ( &\par
                 + fmigrow - fgmezmi - fdzmi - fdzmi2 )\par
               btra(jpzme) = b0 * ( &\par
                 + fmegrow - fdzme - fdzme2 )\par
               !!\par
               !!----------------------------------------------------------------------\par
               !! detritus\par
               btra(jpdet) = b0 * ( &\par
                 + fdpn + ((1.0 - xfdfrac1) * fdpd)              &  ! mort. losses\par
                 + fdzmi + ((1.0 - xfdfrac2) * fdzme)            &  ! mort. losses\par
                 + ((1.0 - xbetan) * (finmi + finme))            &  ! assim. inefficiency\par
                 - fgmid - fgmed - fdd                           &  ! grazing and remin.\par
                 + ffast2slown )                                    ! seafloor fast->slow\par
               !!\par
               !!----------------------------------------------------------------------\par
               !! dissolved inorganic nitrogen nutrient\par
               fn_cons = 0.0  &\par
                 - (fprn * zphn) - (fprd * zphd)                    ! primary production\par
               fn_prod = 0.0  &\par
                 + (xphi * (fgmipn + fgmid))                     &  ! messy feeding remin.\par
                 + (xphi * (fgmepn + fgmepd + fgmezmi + fgmed))  &  ! messy feeding remin.\par
                 + fmiexcr + fmeexcr + fdd + freminn             &  ! excretion and remin.\par
                 + fdpn2 + fdpd2 + fdzmi2 + fdzme2                  ! metab. losses\par
               !! \par
               !! riverine flux\par
               if ( jriver_n .gt. 0 ) then\par
                  f_riv_loc_n = f_riv_n(ji,jj) * friver_dep(jk,jmbathy) / fthk\par
                  fn_prod = fn_prod + f_riv_loc_n\par
               endif\par
               !!  \par
               !! benthic remineralisation\par
               if (jk.eq.jmbathy .and. jorgben.eq.1 .and. ibenthic.eq.1) then\par
                  fn_prod = fn_prod + (f_benout_n(ji,jj) / fthk)\par
               endif\par
               !!\par
               btra(jpdin) = b0 * ( &\par
                 fn_prod + fn_cons )\par
               !!\par
               fnit_cons(ji,jj) = fnit_cons(ji,jj) + ( fthk * (  &  ! consumption of dissolved nitrogen\par
                 fn_cons ) )\par
               fnit_prod(ji,jj) = fnit_prod(ji,jj) + ( fthk * (  &  ! production of dissolved nitrogen\par
                 fn_prod ) )\par
               !!\par
               !!----------------------------------------------------------------------\par
               !! dissolved silicic acid nutrient\par
               fs_cons = 0.0  &\par
                 - (fprds * zpds)                                   ! opal production\par
               fs_prod = 0.0  &\par
                 + fsdiss                                        &  ! opal dissolution\par
                 + ((1.0 - xfdfrac1) * fdpds)                    &  ! mort. loss\par
                 + ((1.0 - xfdfrac3) * fgmepds)                  &  ! egestion of grazed Si\par
                 + freminsi + fdpds2                                ! fast diss. and metab. losses\par
               !! \par
               !! riverine flux\par
               if ( jriver_si .gt. 0 ) then\par
                  f_riv_loc_si = f_riv_si(ji,jj) * friver_dep(jk,jmbathy) / fthk\par
                  fs_prod = fs_prod + f_riv_loc_si\par
               endif\par
               !!  \par
               !! benthic remineralisation\par
               if (jk.eq.jmbathy .and. jinorgben.eq.1 .and. ibenthic.eq.1) then\par
                  fs_prod = fs_prod + (f_benout_si(ji,jj) / fthk)\par
               endif\par
               !!\par
               btra(jpsil) = b0 * ( &\par
                 fs_prod + fs_cons )\par
               !!\par
               fsil_cons(ji,jj) = fsil_cons(ji,jj) + ( fthk * (  &  ! consumption of dissolved silicon\par
                 fs_cons ) )\par
               fsil_prod(ji,jj) = fsil_prod(ji,jj) + ( fthk * (  &  ! production of dissolved silicon\par
                 fs_prod ) )\par
               !!\par
               !!----------------------------------------------------------------------\par
               !! dissolved "iron" nutrient\par
               btra(jpfer) = b0 * ( &\par
               + (xrfn * btra(jpdin)) + ffetop + ffebot - ffescav )\par
\par
# if defined key_roam\par
               !!\par
               !!----------------------------------------------------------------------\par
               !! AXY (26/11/08): implicit detrital carbon change\par
               btra(jpdtc) = b0 * ( &\par
                 + (xthetapn * fdpn) + ((1.0 - xfdfrac1) * (xthetapd * fdpd))      &  ! mort. losses\par
                 + (xthetazmi * fdzmi) + ((1.0 - xfdfrac2) * (xthetazme * fdzme))  &  ! mort. losses\par
                 + ((1.0 - xbetac) * (ficmi + ficme))                              &  ! assim. inefficiency\par
                 - fgmidc - fgmedc - fddc                                          &  ! grazing and remin.\par
                 + ffast2slowc )                                                      ! seafloor fast->slow\par
               !!\par
               !!----------------------------------------------------------------------\par
               !! dissolved inorganic carbon\par
               fc_cons = 0.0  &\par
                 - (xthetapn * fprn * zphn) - (xthetapd * fprd * zphd)                ! primary production\par
               fc_prod = 0.0  &\par
                 + (xthetapn * xphi * fgmipn) + (xphi * fgmidc)                    &  ! messy feeding remin\par
                 + (xthetapn * xphi * fgmepn) + (xthetapd * xphi * fgmepd)         &  ! messy feeding remin\par
                 + (xthetazmi * xphi * fgmezmi) + (xphi * fgmedc)                  &  ! messy feeding remin\par
                 + fmiresp + fmeresp + fddc + freminc + (xthetapn * fdpn2)         &  ! resp., remin., losses\par
                 + (xthetapd * fdpd2) + (xthetazmi * fdzmi2)                       &  ! losses\par
                 + (xthetazme * fdzme2)                                               ! losses\par
               !! \par
               !! riverine flux\par
               if ( jriver_c .gt. 0 ) then\par
                  f_riv_loc_c = f_riv_c(ji,jj) * friver_dep(jk,jmbathy) / fthk\par
                  fc_prod = fc_prod + f_riv_loc_c\par
               endif\par
               !!  \par
               !! benthic remineralisation\par
               if (jk.eq.jmbathy .and. jorgben.eq.1 .and. ibenthic.eq.1) then\par
                  fc_prod = fc_prod + (f_benout_c(ji,jj) / fthk)\par
               endif\par
               if (jk.eq.jmbathy .and. jinorgben.eq.1 .and. ibenthic.eq.1) then\par
                  fc_prod = fc_prod + (f_benout_ca(ji,jj) / fthk)\par
               endif\par
               !!\par
               !! community respiration (does not include CaCO3 terms - obviously!)\par
               fcomm_resp(ji,jj) = fcomm_resp(ji,jj) + fc_prod\par
               !!\par
               !! CaCO3\par
               fc_prod = fc_prod - ftempca + freminca\par
               !! \par
               !! riverine flux\par
               if ( jk .eq. 1 .and. jriver_c .gt. 0 ) then\par
                  fc_prod = fc_prod + f_riv_c(ji,jj)\par
               endif\par
               !!\par
               btra(jpdic) = b0 * ( &\par
                 fc_prod + fc_cons )\par
               !!\par
               fcar_cons(ji,jj) = fcar_cons(ji,jj) + ( fthk * (  &  ! consumption of dissolved carbon\par
                 fc_cons ) )\par
               fcar_prod(ji,jj) = fcar_prod(ji,jj) + ( fthk * (  &  ! production of dissolved carbon\par
                 fc_prod ) )\par
               !!\par
               !!----------------------------------------------------------------------\par
               !! alkalinity\par
               fa_prod = 0.0  &\par
                 + (2.0 * freminca)                                                   ! CaCO3 dissolution\par
               fa_cons = 0.0  &\par
                 - (2.0 * ftempca)                                                    ! CaCO3 production\par
               !! \par
               !! riverine flux\par
               if ( jriver_alk .gt. 0 ) then\par
                  f_riv_loc_alk = f_riv_alk(ji,jj) * friver_dep(jk,jmbathy) / fthk\par
                  fa_prod = fa_prod + f_riv_loc_alk\par
               endif\par
               !!  \par
               !! benthic remineralisation\par
               if (jk.eq.jmbathy .and. jinorgben.eq.1 .and. ibenthic.eq.1) then\par
                  fa_prod = fa_prod + (2.0 * f_benout_ca(ji,jj) / fthk)\par
               endif\par
               !!\par
               btra(jpalk) = b0 * ( &\par
                 fa_prod + fa_cons )\par
               !!\par
               !!----------------------------------------------------------------------\par
               !! oxygen (has protection at low O2 concentrations; OCMIP-2 style)\par
               fo2_prod = 0.0 &\par
                 + (xthetanit * fprn * zphn)                                      & ! Pn primary production, N\par
                 + (xthetanit * fprd * zphd)                                      & ! Pd primary production, N\par
                 + (xthetarem * xthetapn * fprn * zphn)                           & ! Pn primary production, C\par
                 + (xthetarem * xthetapd * fprd * zphd)                             ! Pd primary production, C\par
               fo2_ncons = 0.0 &\par
                 - (xthetanit * xphi * fgmipn)                                    & ! Pn messy feeding remin., N\par
                 - (xthetanit * xphi * fgmid)                                     & ! D  messy feeding remin., N\par
                 - (xthetanit * xphi * fgmepn)                                    & ! Pn messy feeding remin., N\par
                 - (xthetanit * xphi * fgmepd)                                    & ! Pd messy feeding remin., N\par
                 - (xthetanit * xphi * fgmezmi)                                   & ! Zi messy feeding remin., N\par
                 - (xthetanit * xphi * fgmed)                                     & ! D  messy feeding remin., N\par
                 - (xthetanit * fmiexcr)                                          & ! microzoo excretion, N\par
                 - (xthetanit * fmeexcr)                                          & ! mesozoo  excretion, N\par
                 - (xthetanit * fdd)                                              & ! slow detritus remin., N \par
                 - (xthetanit * freminn)                                          & ! fast detritus remin., N\par
                 - (xthetanit * fdpn2)                                            & ! Pn  losses, N\par
                 - (xthetanit * fdpd2)                                            & ! Pd  losses, N\par
                 - (xthetanit * fdzmi2)                                           & ! Zmi losses, N\par
                 - (xthetanit * fdzme2)                                             ! Zme losses, N\par
               !!  \par
               !! benthic remineralisation\par
               if (jk.eq.jmbathy .and. jorgben.eq.1 .and. ibenthic.eq.1) then\par
                  fo2_ncons = fo2_ncons - (xthetanit * f_benout_n(ji,jj) / fthk)\par
               endif\par
               fo2_ccons = 0.0 &\par
                 - (xthetarem * xthetapn * xphi * fgmipn)                         & ! Pn messy feeding remin., C\par
                 - (xthetarem * xphi * fgmidc)                                    & ! D  messy feeding remin., C\par
                 - (xthetarem * xthetapn * xphi * fgmepn)                         & ! Pn messy feeding remin., C\par
                 - (xthetarem * xthetapd * xphi * fgmepd)                         & ! Pd messy feeding remin., C\par
                 - (xthetarem * xthetazmi * xphi * fgmezmi)                       & ! Zi messy feeding remin., C\par
                 - (xthetarem * xphi * fgmedc)                                    & ! D  messy feeding remin., C\par
                 - (xthetarem * fmiresp)                                          & ! microzoo respiration, C\par
                 - (xthetarem * fmeresp)                                          & ! mesozoo  respiration, C\par
                 - (xthetarem * fddc)                                             & ! slow detritus remin., C\par
                 - (xthetarem * freminc)                                          & ! fast detritus remin., C\par
                 - (xthetarem * xthetapn * fdpn2)                                 & ! Pn  losses, C\par
                 - (xthetarem * xthetapd * fdpd2)                                 & ! Pd  losses, C\par
                 - (xthetarem * xthetazmi * fdzmi2)                               & ! Zmi losses, C\par
                 - (xthetarem * xthetazme * fdzme2)                                 ! Zme losses, C\par
               !!  \par
               !! benthic remineralisation\par
               if (jk.eq.jmbathy .and. jorgben.eq.1 .and. ibenthic.eq.1) then\par
                  fo2_ccons = fo2_ccons - (xthetarem * f_benout_c(ji,jj) / fthk)\par
               endif\par
               fo2_cons = fo2_ncons + fo2_ccons\par
               !!\par
               !! is this a suboxic zone?\par
               if (zoxy.lt.xo2min) then  ! deficient O2; production fluxes only\par
                  btra(jpoxy) = b0 * ( &\par
                    fo2_prod )\par
                  foxy_prod(ji,jj) = foxy_prod(ji,jj) + ( fthk * fo2_prod )\par
                  foxy_anox(ji,jj) = foxy_anox(ji,jj) + ( fthk * fo2_cons )\par
               else                      ! sufficient O2; production + consumption fluxes\par
                  btra(jpoxy) = b0 * ( &\par
                    fo2_prod + fo2_cons )\par
                  foxy_prod(ji,jj) = foxy_prod(ji,jj) + ( fthk * fo2_prod )\par
                  foxy_cons(ji,jj) = foxy_cons(ji,jj) + ( fthk * fo2_cons )\par
               endif\par
               !!\par
               !! air-sea fluxes (if this is the surface box)\par
               if (jk.eq.1) then\par
                  !!\par
                  !! CO2 flux\par
                  btra(jpdic) = btra(jpdic) + (b0 * f_co2flux)\par
                  !!\par
                  !! O2 flux (mol/m3/s -> mmol/m3/d)\par
                  btra(jpoxy) = btra(jpoxy) + (b0 * f_o2flux)\par
               endif\par
# endif\par
\par
# if defined key_debug_medusa\par
               !! report state variable fluxes (not including fast-sinking detritus)\par
               if (idf.eq.1.AND.idfval.eq.1) then\par
                  IF (lwp) write (numout,*) '------------------------------'\par
                  IF (lwp) write (numout,*) 'btra(jpchn)(',jk,')  = ', btra(jpchn)\par
                  IF (lwp) write (numout,*) 'btra(jpchd)(',jk,')  = ', btra(jpchd)\par
                  IF (lwp) write (numout,*) 'btra(jpphn)(',jk,')  = ', btra(jpphn)\par
                  IF (lwp) write (numout,*) 'btra(jpphd)(',jk,')  = ', btra(jpphd)\par
                  IF (lwp) write (numout,*) 'btra(jppds)(',jk,')  = ', btra(jppds)\par
                  IF (lwp) write (numout,*) 'btra(jpzmi)(',jk,')  = ', btra(jpzmi)\par
                  IF (lwp) write (numout,*) 'btra(jpzme)(',jk,')  = ', btra(jpzme)\par
                  IF (lwp) write (numout,*) 'btra(jpdet)(',jk,')  = ', btra(jpdet)\par
                  IF (lwp) write (numout,*) 'btra(jpdin)(',jk,')  = ', btra(jpdin)\par
                  IF (lwp) write (numout,*) 'btra(jpsil)(',jk,')  = ', btra(jpsil)\par
                  IF (lwp) write (numout,*) 'btra(jpfer)(',jk,')  = ', btra(jpfer)\par
#  if defined key_roam\par
                  IF (lwp) write (numout,*) 'btra(jpdtc)(',jk,')  = ', btra(jpdtc)\par
                  IF (lwp) write (numout,*) 'btra(jpdic)(',jk,')  = ', btra(jpdic)\par
                  IF (lwp) write (numout,*) 'btra(jpalk)(',jk,')  = ', btra(jpalk)\par
                  IF (lwp) write (numout,*) 'btra(jpoxy)(',jk,')  = ', btra(jpoxy)\par
#  endif\par
               endif\par
# endif\par
\par
               !!----------------------------------------------------------------------\par
               !! Integrate calculated fluxes for mass balance\par
               !!----------------------------------------------------------------------\par
               !!\par
               !! === nitrogen ===\par
               fflx_n(ji,jj)  = fflx_n(ji,jj)  + &\par
                  fthk * ( btra(jpphn) + btra(jpphd) + btra(jpzmi) + btra(jpzme) + btra(jpdet) + btra(jpdin) )\par
               !! === silicon ===\par
               fflx_si(ji,jj) = fflx_si(ji,jj) + &\par
                  fthk * ( btra(jppds) + btra(jpsil) )\par
               !! === iron ===\par
               fflx_fe(ji,jj) = fflx_fe(ji,jj) + &\par
                  fthk * ( ( xrfn * ( btra(jpphn) + btra(jpphd) + btra(jpzmi) + btra(jpzme) + btra(jpdet)) ) + btra(jpfer) )\par
# if defined key_roam\par
               !! === carbon ===\par
               fflx_c(ji,jj)  = fflx_c(ji,jj)  + &\par
                  fthk * ( (xthetapn * btra(jpphn)) + (xthetapd * btra(jpphd)) + &\par
                  (xthetazmi * btra(jpzmi)) + (xthetazme * btra(jpzme)) + btra(jpdtc) + btra(jpdic) )\par
               !! === alkalinity ===\par
               fflx_a(ji,jj)  = fflx_a(ji,jj)  + &\par
                  fthk * ( btra(jpalk) )\par
               !! === oxygen ===\par
               fflx_o2(ji,jj) = fflx_o2(ji,jj) + &\par
                  fthk * ( btra(jpoxy) )\par
# endif\par
\par
               !!----------------------------------------------------------------------\par
               !! Apply calculated tracer fluxes\par
               !!----------------------------------------------------------------------\par
               !!\par
               !! units: [unit of tracer] per second (fluxes are calculated above per day)\par
               !!\par
               ibio_switch = 1\par
# if defined key_gulf_finland\par
               !! AXY (17/05/13): fudge in a Gulf of Finland correction; uses longitude-\par
               !!                 latitude range to establish if this is a Gulf of Finland \par
               !!                 grid cell; if so, then BGC fluxes are ignored (though \par
               !!                 still calculated); for reference, this is meant to be a \par
               !!                 temporary fix to see if all of my problems can be done \par
               !!                 away with if I switch off BGC fluxes in the Gulf of \par
               !!                 Finland, which currently appears the source of trouble\par
               if ( glamt(ji,jj).gt.24.7 .and. glamt(ji,jj).lt.27.8 .and. &\par
                  &   gphit(ji,jj).gt.59.2 .and. gphit(ji,jj).lt.60.2 ) then\par
                  ibio_switch = 0\par
               endif\par
# endif               \par
               if (ibio_switch.eq.1) then\par
                  tra(ji,jj,jk,jpchn) = tra(ji,jj,jk,jpchn) + (btra(jpchn) / 86400.)\par
                  tra(ji,jj,jk,jpchd) = tra(ji,jj,jk,jpchd) + (btra(jpchd) / 86400.)\par
                  tra(ji,jj,jk,jpphn) = tra(ji,jj,jk,jpphn) + (btra(jpphn) / 86400.)\par
                  tra(ji,jj,jk,jpphd) = tra(ji,jj,jk,jpphd) + (btra(jpphd) / 86400.)\par
                  tra(ji,jj,jk,jppds) = tra(ji,jj,jk,jppds) + (btra(jppds) / 86400.)\par
                  tra(ji,jj,jk,jpzmi) = tra(ji,jj,jk,jpzmi) + (btra(jpzmi) / 86400.)\par
                  tra(ji,jj,jk,jpzme) = tra(ji,jj,jk,jpzme) + (btra(jpzme) / 86400.)\par
                  tra(ji,jj,jk,jpdet) = tra(ji,jj,jk,jpdet) + (btra(jpdet) / 86400.)\par
                  tra(ji,jj,jk,jpdin) = tra(ji,jj,jk,jpdin) + (btra(jpdin) / 86400.)\par
                  tra(ji,jj,jk,jpsil) = tra(ji,jj,jk,jpsil) + (btra(jpsil) / 86400.)\par
                  tra(ji,jj,jk,jpfer) = tra(ji,jj,jk,jpfer) + (btra(jpfer) / 86400.)\par
# if defined key_roam\par
                  tra(ji,jj,jk,jpdtc) = tra(ji,jj,jk,jpdtc) + (btra(jpdtc) / 86400.)\par
                  tra(ji,jj,jk,jpdic) = tra(ji,jj,jk,jpdic) + (btra(jpdic) / 86400.)\par
                  tra(ji,jj,jk,jpalk) = tra(ji,jj,jk,jpalk) + (btra(jpalk) / 86400.)\par
                  tra(ji,jj,jk,jpoxy) = tra(ji,jj,jk,jpoxy) + (btra(jpoxy) / 86400.)\par
# endif\par
               endif               \par
\par
               !! AXY (18/11/16): CMIP6 diagnostics\par
               IF( med_diag%FBDDTALK%dgsave )  THEN\par
                  fbddtalk(ji,jj)  =  fbddtalk(ji,jj)  + (btra(jpalk) * fthk)\par
               ENDIF\par
               IF( med_diag%FBDDTDIC%dgsave )  THEN\par
                  fbddtdic(ji,jj)  =  fbddtdic(ji,jj)  + (btra(jpdic) * fthk)\par
               ENDIF\par
               IF( med_diag%FBDDTDIFE%dgsave ) THEN\par
                  fbddtdife(ji,jj) =  fbddtdife(ji,jj) + (btra(jpfer) * fthk)\par
               ENDIF\par
               IF( med_diag%FBDDTDIN%dgsave )  THEN\par
                  fbddtdin(ji,jj)  =  fbddtdin(ji,jj)  + (btra(jpdin) * fthk)\par
               ENDIF\par
               IF( med_diag%FBDDTDISI%dgsave ) THEN\par
                  fbddtdisi(ji,jj) =  fbddtdisi(ji,jj) + (btra(jpsil) * fthk)\par
               ENDIF\par
\tab        !!\par
               IF( med_diag%BDDTALK3%dgsave )  THEN\par
                  bddtalk3(ji,jj,jk)  =  btra(jpalk)\par
               ENDIF\par
               IF( med_diag%BDDTDIC3%dgsave )  THEN\par
                  bddtdic3(ji,jj,jk)  =  btra(jpdic)\par
               ENDIF\par
               IF( med_diag%BDDTDIFE3%dgsave ) THEN\par
                  bddtdife3(ji,jj,jk) =  btra(jpfer)\par
               ENDIF\par
               IF( med_diag%BDDTDIN3%dgsave )  THEN\par
                  bddtdin3(ji,jj,jk)  =  btra(jpdin)\par
               ENDIF\par
               IF( med_diag%BDDTDISI3%dgsave ) THEN\par
                  bddtdisi3(ji,jj,jk) =  btra(jpsil)\par
               ENDIF\par
\par
#   if defined key_debug_medusa\par
               IF (lwp) write (numout,*) '------'\par
               IF (lwp) write (numout,*) 'trc_bio_medusa: end all calculations'\par
               IF (lwp) write (numout,*) 'trc_bio_medusa: now outputs'\par
                     CALL flush(numout)\par
#   endif\par
\par
# if defined key_axy_nancheck\par
               !!----------------------------------------------------------------------\par
               !! Check calculated tracer fluxes\par
               !!----------------------------------------------------------------------\par
               !!\par
               DO jn = 1,jptra\par
                  fq0 = btra(jn)\par
                  !! AXY (30/01/14): "isnan" problem on HECTOR\par
                  !! if (fq0 /= fq0 ) then\par
                  if ( ieee_is_nan( fq0 ) ) then\par
                     !! there's a NaN here\par
                     if (lwp) write(numout,*) 'NAN detected in btra(', ji, ',', &\par
                     & jj, ',', jk, ',', jn, ') at time', kt\par
\tab\tab      CALL ctl_stop( 'trcbio_medusa, NAN in btra field' )\par
                  endif\par
               ENDDO\par
               DO jn = 1,jptra\par
                  fq0 = tra(ji,jj,jk,jn)\par
                  !! AXY (30/01/14): "isnan" problem on HECTOR\par
                  !! if (fq0 /= fq0 ) then\par
                  if ( ieee_is_nan( fq0 ) ) then\par
                     !! there's a NaN here\par
                     if (lwp) write(numout,*) 'NAN detected in tra(', ji, ',', &\par
                     & jj, ',', jk, ',', jn, ') at time', kt\par
   \tab\tab      CALL ctl_stop( 'trcbio_medusa, NAN in tra field' )\par
                  endif\par
               ENDDO\par
               CALL flush(numout)\par
# endif\par
\par
               !!----------------------------------------------------------------------\par
               !! Check model conservation\par
               !! these terms merely sum up the tendency terms of the relevant\par
               !! state variables, which should sum to zero; the iron cycle is\par
               !! complicated by fluxes that add (aeolian deposition and seafloor\par
               !! remineralisation) and remove (scavenging) dissolved iron from\par
               !! the model (i.e. the sum of iron fluxes is unlikely to be zero)\par
               !!----------------------------------------------------------------------\par
               !!\par
               !! fnit0 = btra(jpphn) + btra(jpphd) + btra(jpzmi) + btra(jpzme) + btra(jpdet) + btra(jpdin)  ! + ftempn\par
               !! fsil0 = btra(jppds) + btra(jpsil)                              ! + ftempsi\par
               !! ffer0 = (xrfn * fnit0) + btra(jpfer)\par
# if defined key_roam\par
               !! fcar0 = 0.\par
               !! falk0 = 0.\par
               !! foxy0 = 0.\par
# endif\par
               !!\par
               !! if (kt/240*240.eq.kt) then\par
               !!    if (ji.eq.2.and.jj.eq.2.and.jk.eq.1) then\par
               !!       IF (lwp) write (*,*) '*******!MEDUSA Conservation!*******',kt\par
# if defined key_roam\par
               !!       IF (lwp) write (*,*) fnit0,fsil0,ffer0,fcar0,falk0,foxy0\par
# else\par
               !!       IF (lwp) write (*,*) fnit0,fsil0,ffer0\par
# endif\par
               !!    endif\par
               !! endif     \par
\par
# if defined key_trc_diabio\par
               !!======================================================================\par
               !! LOCAL GRID CELL DIAGNOSTICS\par
               !!======================================================================\par
               !!\par
               !!----------------------------------------------------------------------\par
               !! Full diagnostics key_trc_diabio:\par
               !! LOBSTER and PISCES support full diagnistics option key_trc_diabio    \par
               !! which gives an option of FULL output of biological sourses and sinks.\par
               !! I cannot see any reason for doing this. If needed, it can be done\par
               !! as shown below.\par
               !!----------------------------------------------------------------------\par
               !!\par
               IF(lwp) WRITE(numout,*) ' MEDUSA does not support key_trc_diabio'\par
               !!               trbio(ji,jj,jk, 1) = fprn\par
# endif\par
\par
               IF( lk_iomput  .AND.  .NOT.  ln_diatrc  ) THEN\par
         !!----------------------------------------------------------------------\par
         !! Add in XML diagnostics stuff\par
         !!----------------------------------------------------------------------\par
         !!\par
         !! ** 2D diagnostics\par
#   if defined key_debug_medusa\par
                  IF (lwp) write (numout,*) 'trc_bio_medusa: diag in ij-jj-jk loop'\par
                  CALL flush(numout)\par
#   endif\par
                  IF ( med_diag%PRN%dgsave ) THEN\par
                      fprn2d(ji,jj) = fprn2d(ji,jj) + (fprn  * zphn * fthk) \par
                  ENDIF\par
                  IF ( med_diag%MPN%dgsave ) THEN\par
                      fdpn2d(ji,jj) = fdpn2d(ji,jj) + (fdpn         * fthk)\par
                  ENDIF\par
                  IF ( med_diag%PRD%dgsave ) THEN\par
                      fprd2d(ji,jj) = fprd2d(ji,jj) + (fprd  * zphd * fthk)\par
                  ENDIF\par
                  IF( med_diag%MPD%dgsave ) THEN\par
                      fdpd2d(ji,jj) = fdpd2d(ji,jj) + (fdpd         * fthk) \par
                  ENDIF\par
                  !  IF( med_diag%DSED%dgsave ) THEN\par
                  !      CALL iom_put( "DSED"  , ftot_n )\par
                  !  ENDIF\par
                  IF( med_diag%OPAL%dgsave ) THEN\par
                      fprds2d(ji,jj) = fprds2d(ji,jj) + (fprds * zpds * fthk) \par
                  ENDIF\par
                  IF( med_diag%OPALDISS%dgsave ) THEN\par
                      fsdiss2d(ji,jj) = fsdiss2d(ji,jj) + (fsdiss  * fthk)  \par
                  ENDIF\par
                  IF( med_diag%GMIPn%dgsave ) THEN\par
                      fgmipn2d(ji,jj) = fgmipn2d(ji,jj) + (fgmipn  * fthk) \par
                  ENDIF\par
                  IF( med_diag%GMID%dgsave ) THEN\par
                      fgmid2d(ji,jj) = fgmid2d(ji,jj) + (fgmid   * fthk) \par
                  ENDIF\par
                  IF( med_diag%MZMI%dgsave ) THEN\par
                      fdzmi2d(ji,jj) = fdzmi2d(ji,jj) + (fdzmi   * fthk) \par
                  ENDIF\par
                  IF( med_diag%GMEPN%dgsave ) THEN\par
                      fgmepn2d(ji,jj) = fgmepn2d(ji,jj) + (fgmepn  * fthk)\par
                  ENDIF\par
                  IF( med_diag%GMEPD%dgsave ) THEN\par
                      fgmepd2d(ji,jj) = fgmepd2d(ji,jj) + (fgmepd  * fthk) \par
                  ENDIF\par
                  IF( med_diag%GMEZMI%dgsave ) THEN\par
                      fgmezmi2d(ji,jj) = fgmezmi2d(ji,jj) + (fgmezmi * fthk) \par
                  ENDIF\par
                  IF( med_diag%GMED%dgsave ) THEN\par
                      fgmed2d(ji,jj) = fgmed2d(ji,jj) + (fgmed   * fthk) \par
                  ENDIF\par
                  IF( med_diag%MZME%dgsave ) THEN\par
                      fdzme2d(ji,jj) = fdzme2d(ji,jj) + (fdzme   * fthk) \par
                  ENDIF\par
                  !  IF( med_diag%DEXP%dgsave ) THEN\par
                  !      CALL iom_put( "DEXP"  , ftot_n )\par
                  !  ENDIF\par
                  IF( med_diag%DETN%dgsave ) THEN\par
                      fslown2d(ji,jj) = fslown2d(ji,jj) + (fslown  * fthk)  \par
                  ENDIF\par
                  IF( med_diag%MDET%dgsave ) THEN\par
                      fdd2d(ji,jj) = fdd2d(ji,jj) + (fdd     * fthk) \par
                  ENDIF\par
                  IF( med_diag%AEOLIAN%dgsave ) THEN\par
                      ffetop2d(ji,jj) = ffetop2d(ji,jj) + (ffetop  * fthk) \par
                  ENDIF\par
                  IF( med_diag%BENTHIC%dgsave ) THEN\par
                      ffebot2d(ji,jj) = ffebot2d(ji,jj) + (ffebot  * fthk) \par
                  ENDIF\par
                  IF( med_diag%SCAVENGE%dgsave ) THEN\par
                      ffescav2d(ji,jj) = ffescav2d(ji,jj) + (ffescav * fthk)  \par
                  ENDIF\par
                  IF( med_diag%PN_JLIM%dgsave ) THEN\par
                      ! fjln2d(ji,jj) = fjln2d(ji,jj) + (fjln  * zphn * fthk) \par
                      fjln2d(ji,jj) = fjln2d(ji,jj) + (fjlim_pn * zphn * fthk) \par
                  ENDIF\par
                  IF( med_diag%PN_NLIM%dgsave ) THEN\par
                      fnln2d(ji,jj) = fnln2d(ji,jj) + (fnln  * zphn * fthk) \par
                  ENDIF\par
                  IF( med_diag%PN_FELIM%dgsave ) THEN\par
                      ffln2d(ji,jj) = ffln2d(ji,jj) + (ffln  * zphn * fthk) \par
                  ENDIF\par
                  IF( med_diag%PD_JLIM%dgsave ) THEN\par
                      ! fjld2d(ji,jj) = fjld2d(ji,jj) + (fjld  * zphd * fthk) \par
                      fjld2d(ji,jj) = fjld2d(ji,jj) + (fjlim_pd * zphd * fthk) \par
                  ENDIF\par
                  IF( med_diag%PD_NLIM%dgsave ) THEN\par
                      fnld2d(ji,jj) = fnld2d(ji,jj) + (fnld  * zphd * fthk) \par
                  ENDIF\par
                  IF( med_diag%PD_FELIM%dgsave ) THEN\par
                      ffld2d(ji,jj) = ffld2d(ji,jj) + (ffld  * zphd * fthk) \par
                  ENDIF\par
                  IF( med_diag%PD_SILIM%dgsave ) THEN\par
                      fsld2d2(ji,jj) = fsld2d2(ji,jj) + (fsld2 * zphd * fthk) \par
                  ENDIF\par
                  IF( med_diag%PDSILIM2%dgsave ) THEN\par
                      fsld2d(ji,jj) = fsld2d(ji,jj) + (fsld  * zphd * fthk)\par
                  ENDIF\par
                  !! \par
                  IF( med_diag%TOTREG_N%dgsave ) THEN\par
                      fregen2d(ji,jj) = fregen2d(ji,jj) + fregen\par
                  ENDIF\par
                  IF( med_diag%TOTRG_SI%dgsave ) THEN\par
                      fregensi2d(ji,jj) = fregensi2d(ji,jj) + fregensi\par
                  ENDIF\par
                  !! \par
                  IF( med_diag%FASTN%dgsave ) THEN\par
                      ftempn2d(ji,jj) = ftempn2d(ji,jj) + (ftempn  * fthk)\par
                  ENDIF\par
                  IF( med_diag%FASTSI%dgsave ) THEN\par
                      ftempsi2d(ji,jj) = ftempsi2d(ji,jj) + (ftempsi * fthk)\par
                  ENDIF\par
                  IF( med_diag%FASTFE%dgsave ) THEN\par
                      ftempfe2d(ji,jj) =ftempfe2d(ji,jj)  + (ftempfe * fthk)  \par
                  ENDIF\par
                  IF( med_diag%FASTC%dgsave ) THEN\par
                      ftempc2d(ji,jj) = ftempc2d(ji,jj) + (ftempc  * fthk)\par
                  ENDIF\par
                  IF( med_diag%FASTCA%dgsave ) THEN\par
                      ftempca2d(ji,jj) = ftempca2d(ji,jj) + (ftempca * fthk)\par
                  ENDIF\par
                  !! \par
                  IF( med_diag%REMINN%dgsave ) THEN\par
                      freminn2d(ji,jj) = freminn2d(ji,jj) + (freminn  * fthk)\par
                  ENDIF\par
                  IF( med_diag%REMINSI%dgsave ) THEN\par
                      freminsi2d(ji,jj) = freminsi2d(ji,jj) + (freminsi * fthk)\par
                  ENDIF\par
                  IF( med_diag%REMINFE%dgsave ) THEN\par
                      freminfe2d(ji,jj)= freminfe2d(ji,jj) + (freminfe * fthk) \par
                  ENDIF\par
                  IF( med_diag%REMINC%dgsave ) THEN\par
                      freminc2d(ji,jj) = freminc2d(ji,jj) + (freminc  * fthk) \par
                  ENDIF\par
                  IF( med_diag%REMINCA%dgsave ) THEN\par
                      freminca2d(ji,jj) = freminca2d(ji,jj) + (freminca * fthk) \par
                  ENDIF\par
                  !!\par
# if defined key_roam\par
                  !!\par
                  !! AXY (09/11/16): CMIP6 diagnostics\par
                  IF( med_diag%FD_NIT3%dgsave ) THEN\par
                     fd_nit3(ji,jj,jk) = ffastn(ji,jj)\par
                  ENDIF\par
                  IF( med_diag%FD_SIL3%dgsave ) THEN\par
                     fd_sil3(ji,jj,jk) = ffastsi(ji,jj)\par
                  ENDIF\par
                  IF( med_diag%FD_CAR3%dgsave ) THEN\par
                     fd_car3(ji,jj,jk) = ffastc(ji,jj)\par
                  ENDIF\par
                  IF( med_diag%FD_CAL3%dgsave ) THEN\par
                     fd_cal3(ji,jj,jk) = ffastca(ji,jj)\par
                  ENDIF\par
                  !!\par
                  IF (jk.eq.i0100) THEN\par
                     IF( med_diag%RR_0100%dgsave ) THEN\par
                        ffastca2d(ji,jj) =   &\par
                        ffastca(ji,jj)/MAX(ffastc(ji,jj), rsmall)\par
                     ENDIF                     \par
                  ELSE IF (jk.eq.i0500) THEN \par
                     IF( med_diag%RR_0500%dgsave ) THEN\par
                        ffastca2d(ji,jj) =   &\par
                        ffastca(ji,jj)/MAX(ffastc(ji,jj), rsmall)\par
                     ENDIF                        \par
                  ELSE IF (jk.eq.i1000) THEN\par
                     IF( med_diag%RR_1000%dgsave ) THEN\par
                        ffastca2d(ji,jj) =   &\par
                        ffastca(ji,jj)/MAX(ffastc(ji,jj), rsmall)\par
                     ENDIF\par
                  ELSE IF (jk.eq.jmbathy) THEN\par
                     IF( med_diag%IBEN_N%dgsave ) THEN\par
                        iben_n2d(ji,jj) = f_sbenin_n(ji,jj)  + f_fbenin_n(ji,jj)\par
                     ENDIF\par
                     IF( med_diag%IBEN_FE%dgsave ) THEN\par
                        iben_fe2d(ji,jj) = f_sbenin_fe(ji,jj) + f_fbenin_fe(ji,jj)\par
                     ENDIF\par
                     IF( med_diag%IBEN_C%dgsave ) THEN\par
                        iben_c2d(ji,jj) = f_sbenin_c(ji,jj)  + f_fbenin_c(ji,jj)\par
                     ENDIF\par
                     IF( med_diag%IBEN_SI%dgsave ) THEN\par
                        iben_si2d(ji,jj) = f_fbenin_si(ji,jj)\par
                     ENDIF\par
                     IF( med_diag%IBEN_CA%dgsave ) THEN\par
                        iben_ca2d(ji,jj) = f_fbenin_ca(ji,jj)\par
                     ENDIF\par
                     IF( med_diag%OBEN_N%dgsave ) THEN\par
                        oben_n2d(ji,jj) = f_benout_n(ji,jj)\par
                     ENDIF\par
                     IF( med_diag%OBEN_FE%dgsave ) THEN\par
                        oben_fe2d(ji,jj) = f_benout_fe(ji,jj)\par
                     ENDIF\par
                     IF( med_diag%OBEN_C%dgsave ) THEN\par
                        oben_c2d(ji,jj) = f_benout_c(ji,jj)\par
                     ENDIF\par
                     IF( med_diag%OBEN_SI%dgsave ) THEN\par
                        oben_si2d(ji,jj) = f_benout_si(ji,jj)\par
                     ENDIF\par
                     IF( med_diag%OBEN_CA%dgsave ) THEN\par
                        oben_ca2d(ji,jj) = f_benout_ca(ji,jj)\par
                     ENDIF\par
                     IF( med_diag%SFR_OCAL%dgsave ) THEN\par
                        sfr_ocal2d(ji,jj) = f3_omcal(ji,jj,jk)\par
                     ENDIF\par
                     IF( med_diag%SFR_OARG%dgsave ) THEN\par
                        sfr_oarg2d(ji,jj) =  f3_omarg(ji,jj,jk)\par
                     ENDIF\par
                     IF( med_diag%LYSO_CA%dgsave ) THEN\par
                        lyso_ca2d(ji,jj) = f_benout_lyso_ca(ji,jj)\par
                     ENDIF\par
                  ENDIF\par
                  !! end bathy-1 diags\par
                  !!\par
                  IF( med_diag%RIV_N%dgsave ) THEN\par
                     rivn2d(ji,jj) = rivn2d(ji,jj) +  (f_riv_loc_n * fthk)\par
                  ENDIF\par
                  IF( med_diag%RIV_SI%dgsave ) THEN\par
                     rivsi2d(ji,jj) = rivsi2d(ji,jj) +  (f_riv_loc_si * fthk)\par
                  ENDIF\par
                  IF( med_diag%RIV_C%dgsave ) THEN\par
                     rivc2d(ji,jj) = rivc2d(ji,jj) +  (f_riv_loc_c * fthk)\par
                  ENDIF\par
                  IF( med_diag%RIV_ALK%dgsave ) THEN\par
                     rivalk2d(ji,jj) = rivalk2d(ji,jj) +  (f_riv_loc_alk * fthk)\par
                  ENDIF\par
                  IF( med_diag%DETC%dgsave ) THEN\par
                     fslowc2d(ji,jj) = fslowc2d(ji,jj) + (fslowc  * fthk)   \par
                  ENDIF\par
                  !! \par
                  !!              \par
                  !!\par
                  IF( med_diag%PN_LLOSS%dgsave ) THEN\par
                     fdpn22d(ji,jj) = fdpn22d(ji,jj) + (fdpn2  * fthk)\par
                  ENDIF\par
                  IF( med_diag%PD_LLOSS%dgsave ) THEN\par
                     fdpd22d(ji,jj) = fdpd22d(ji,jj) + (fdpd2  * fthk)\par
                  ENDIF\par
                  IF( med_diag%ZI_LLOSS%dgsave ) THEN\par
                     fdzmi22d(ji,jj) = fdzmi22d(ji,jj) + (fdzmi2 * fthk)\par
                  ENDIF\par
                  IF( med_diag%ZE_LLOSS%dgsave ) THEN\par
                     fdzme22d(ji,jj) = fdzme22d(ji,jj) + (fdzme2 * fthk)\par
                  ENDIF\par
                  IF( med_diag%ZI_MES_N%dgsave ) THEN\par
                     zimesn2d(ji,jj) = zimesn2d(ji,jj) +  &\par
                     (xphi * (fgmipn + fgmid) * fthk)\par
                  ENDIF\par
                  IF( med_diag%ZI_MES_D%dgsave ) THEN\par
                     zimesd2d(ji,jj) = zimesd2d(ji,jj) + & \par
                     ((1. - xbetan) * finmi * fthk)\par
                  ENDIF\par
                  IF( med_diag%ZI_MES_C%dgsave ) THEN\par
                     zimesc2d(ji,jj) = zimesc2d(ji,jj) + &\par
                     (xphi * ((xthetapn * fgmipn) + fgmidc) * fthk)\par
                  ENDIF\par
                  IF( med_diag%ZI_MESDC%dgsave ) THEN\par
                     zimesdc2d(ji,jj) = zimesdc2d(ji,jj) + &\par
                     ((1. - xbetac) * ficmi * fthk)\par
                  ENDIF\par
                  IF( med_diag%ZI_EXCR%dgsave ) THEN\par
                     ziexcr2d(ji,jj) = ziexcr2d(ji,jj) +  (fmiexcr * fthk)\par
                  ENDIF\par
                  IF( med_diag%ZI_RESP%dgsave ) THEN\par
                     ziresp2d(ji,jj) = ziresp2d(ji,jj) +  (fmiresp * fthk)\par
                  ENDIF\par
                  IF( med_diag%ZI_GROW%dgsave ) THEN\par
                     zigrow2d(ji,jj) = zigrow2d(ji,jj) + (fmigrow * fthk)\par
                  ENDIF\par
                  IF( med_diag%ZE_MES_N%dgsave ) THEN\par
                     zemesn2d(ji,jj) = zemesn2d(ji,jj) + &\par
                     (xphi * (fgmepn + fgmepd + fgmezmi + fgmed) * fthk)\par
                  ENDIF\par
                  IF( med_diag%ZE_MES_D%dgsave ) THEN\par
                     zemesd2d(ji,jj) = zemesd2d(ji,jj) + &\par
                     ((1. - xbetan) * finme * fthk)\par
                  ENDIF\par
                  IF( med_diag%ZE_MES_C%dgsave ) THEN\par
                     zemesc2d(ji,jj) = zemesc2d(ji,jj) +                         & \par
                     (xphi * ((xthetapn * fgmepn) + (xthetapd * fgmepd) +  &\par
                     (xthetazmi * fgmezmi) + fgmedc) * fthk)\par
                  ENDIF\par
                  IF( med_diag%ZE_MESDC%dgsave ) THEN\par
                     zemesdc2d(ji,jj) = zemesdc2d(ji,jj) +  &\par
                     ((1. - xbetac) * ficme * fthk)\par
                  ENDIF\par
                  IF( med_diag%ZE_EXCR%dgsave ) THEN\par
                     zeexcr2d(ji,jj) = zeexcr2d(ji,jj) + (fmeexcr * fthk)\par
                  ENDIF\par
                  IF( med_diag%ZE_RESP%dgsave ) THEN\par
                     zeresp2d(ji,jj) = zeresp2d(ji,jj) + (fmeresp * fthk)\par
                  ENDIF\par
                  IF( med_diag%ZE_GROW%dgsave ) THEN\par
                     zegrow2d(ji,jj) = zegrow2d(ji,jj) + (fmegrow * fthk)\par
                  ENDIF\par
                  IF( med_diag%MDETC%dgsave ) THEN\par
                     mdetc2d(ji,jj) = mdetc2d(ji,jj) + (fddc * fthk)\par
                  ENDIF\par
                  IF( med_diag%GMIDC%dgsave ) THEN\par
                     gmidc2d(ji,jj) = gmidc2d(ji,jj) + (fgmidc * fthk)\par
                  ENDIF\par
                  IF( med_diag%GMEDC%dgsave ) THEN\par
                     gmedc2d(ji,jj) = gmedc2d(ji,jj) + (fgmedc  * fthk)\par
                  ENDIF\par
                  !!\par
# endif                   \par
                  !!\par
                  !! ** 3D diagnostics\par
                  IF( med_diag%TPP3%dgsave ) THEN\par
                     tpp3d(ji,jj,jk) =  (fprn * zphn) + (fprd * zphd)\par
                     !CALL iom_put( "TPP3"  , tpp3d )\par
                  ENDIF\par
                  IF( med_diag%TPPD3%dgsave ) THEN\par
                     tppd3(ji,jj,jk) =  (fprd * zphd)\par
                  ENDIF\par
                  \par
                  IF( med_diag%REMIN3N%dgsave ) THEN\par
                     remin3dn(ji,jj,jk) = fregen + (freminn * fthk) !! remineralisation\par
                     !CALL iom_put( "REMIN3N"  , remin3dn )\par
                  ENDIF\par
                  !! IF( med_diag%PH3%dgsave ) THEN\par
                  !!     CALL iom_put( "PH3"  , f3_pH )\par
                  !! ENDIF\par
                  !! IF( med_diag%OM_CAL3%dgsave ) THEN\par
                  !!     CALL iom_put( "OM_CAL3"  , f3_omcal )\par
                  !! ENDIF\par
\tab\tab   !! \par
\tab\tab   !! AXY (09/11/16): CMIP6 diagnostics\par
\tab\tab   IF ( med_diag%DCALC3%dgsave   ) THEN\par
                     dcalc3(ji,jj,jk) = freminca\par
                  ENDIF\par
\tab\tab   IF ( med_diag%FEDISS3%dgsave  ) THEN\par
                     fediss3(ji,jj,jk) = ffetop\par
                  ENDIF\par
\tab\tab   IF ( med_diag%FESCAV3%dgsave  ) THEN\par
                     fescav3(ji,jj,jk) = ffescav\par
                  ENDIF\par
\tab\tab   IF ( med_diag%MIGRAZP3%dgsave ) THEN\par
                     migrazp3(ji,jj,jk) = fgmipn * xthetapn\par
                  ENDIF\par
\tab\tab   IF ( med_diag%MIGRAZD3%dgsave ) THEN\par
                     migrazd3(ji,jj,jk) = fgmidc\par
                  ENDIF\par
\tab\tab   IF ( med_diag%MEGRAZP3%dgsave ) THEN\par
                     megrazp3(ji,jj,jk) = (fgmepn * xthetapn) + (fgmepd * xthetapd)\par
                  ENDIF\par
\tab\tab   IF ( med_diag%MEGRAZD3%dgsave ) THEN\par
                     megrazd3(ji,jj,jk) = fgmedc\par
                  ENDIF\par
\tab\tab   IF ( med_diag%MEGRAZZ3%dgsave ) THEN\par
                     megrazz3(ji,jj,jk) = (fgmezmi * xthetazmi)\par
                  ENDIF\par
\tab\tab   IF ( med_diag%PBSI3%dgsave    ) THEN\par
                     pbsi3(ji,jj,jk)    = (fprds * zpds)\par
                  ENDIF\par
\tab\tab   IF ( med_diag%PCAL3%dgsave    ) THEN\par
                     pcal3(ji,jj,jk)    = ftempca\par
                  ENDIF\par
\tab\tab   IF ( med_diag%REMOC3%dgsave   ) THEN\par
                     remoc3(ji,jj,jk)   = freminc\par
                  ENDIF\par
\tab\tab   IF ( med_diag%PNLIMJ3%dgsave  ) THEN\par
                     ! pnlimj3(ji,jj,jk)  = fjln\par
                     pnlimj3(ji,jj,jk)  = fjlim_pn\par
                  ENDIF\par
\tab\tab   IF ( med_diag%PNLIMN3%dgsave  ) THEN\par
                     pnlimn3(ji,jj,jk)  = fnln\par
                  ENDIF\par
\tab\tab   IF ( med_diag%PNLIMFE3%dgsave ) THEN\par
                     pnlimfe3(ji,jj,jk) = ffln\par
                  ENDIF\par
\tab\tab   IF ( med_diag%PDLIMJ3%dgsave  ) THEN\par
                     ! pdlimj3(ji,jj,jk)  = fjld\par
                     pdlimj3(ji,jj,jk)  = fjlim_pd\par
                  ENDIF\par
\tab\tab   IF ( med_diag%PDLIMN3%dgsave  ) THEN\par
                     pdlimn3(ji,jj,jk)  = fnld\par
                  ENDIF\par
\tab\tab   IF ( med_diag%PDLIMFE3%dgsave ) THEN\par
                     pdlimfe3(ji,jj,jk) = ffld\par
                  ENDIF\par
\tab\tab   IF ( med_diag%PDLIMSI3%dgsave ) THEN\par
                     pdlimsi3(ji,jj,jk) = fsld2\par
                  ENDIF\par
                  !!\par
                  !! ** Without using iom_use\par
               ELSE IF( ln_diatrc ) THEN\par
#   if defined key_debug_medusa\par
                  IF (lwp) write (numout,*) 'trc_bio_medusa: diag in ij-jj-jk ln_diatrc'\par
                  CALL flush(numout)\par
#   endif\par
                  !!----------------------------------------------------------------------\par
                  !! Prepare 2D diagnostics\par
                  !!----------------------------------------------------------------------\par
                  !!\par
                  !! if ((kt / 240*240).eq.kt) then\par
                  !!    IF (lwp) write (*,*) '*******!MEDUSA DIAADD!*******',kt\par
                  !! endif     \par
                  trc2d(ji,jj,1)  =  ftot_n(ji,jj)                             !! nitrogen inventory\par
                  trc2d(ji,jj,2)  =  ftot_si(ji,jj)                            !! silicon  inventory\par
                  trc2d(ji,jj,3)  =  ftot_fe(ji,jj)                            !! iron     inventory\par
                  trc2d(ji,jj,4)  = trc2d(ji,jj,4)  + (fprn  * zphn * fthk)    !! non-diatom production\par
                  trc2d(ji,jj,5)  = trc2d(ji,jj,5)  + (fdpn         * fthk)    !! non-diatom non-grazing losses\par
                  trc2d(ji,jj,6)  = trc2d(ji,jj,6)  + (fprd  * zphd * fthk)    !! diatom production\par
                  trc2d(ji,jj,7)  = trc2d(ji,jj,7)  + (fdpd         * fthk)    !! diatom non-grazing losses\par
                  !! diagnostic field  8 is (ostensibly) supplied by trcsed.F            \par
                  trc2d(ji,jj,9)  = trc2d(ji,jj,9)  + (fprds * zpds * fthk)    !! diatom silicon production\par
                  trc2d(ji,jj,10) = trc2d(ji,jj,10) + (fsdiss  * fthk)         !! diatom silicon dissolution\par
                  trc2d(ji,jj,11) = trc2d(ji,jj,11) + (fgmipn  * fthk)         !! microzoo grazing on non-diatoms\par
                  trc2d(ji,jj,12) = trc2d(ji,jj,12) + (fgmid   * fthk)         !! microzoo grazing on detrital nitrogen\par
                  trc2d(ji,jj,13) = trc2d(ji,jj,13) + (fdzmi   * fthk)         !! microzoo non-grazing losses\par
                  trc2d(ji,jj,14) = trc2d(ji,jj,14) + (fgmepn  * fthk)         !! mesozoo  grazing on non-diatoms\par
                  trc2d(ji,jj,15) = trc2d(ji,jj,15) + (fgmepd  * fthk)         !! mesozoo  grazing on diatoms\par
                  trc2d(ji,jj,16) = trc2d(ji,jj,16) + (fgmezmi * fthk)         !! mesozoo  grazing on microzoo\par
                  trc2d(ji,jj,17) = trc2d(ji,jj,17) + (fgmed   * fthk)         !! mesozoo  grazing on detrital nitrogen\par
                  trc2d(ji,jj,18) = trc2d(ji,jj,18) + (fdzme   * fthk)         !! mesozoo  non-grazing losses\par
                  !! diagnostic field 19 is (ostensibly) supplied by trcexp.F\par
                  trc2d(ji,jj,20) = trc2d(ji,jj,20) + (fslown  * fthk)         !! slow sinking detritus N production\par
                  trc2d(ji,jj,21) = trc2d(ji,jj,21) + (fdd     * fthk)         !! detrital remineralisation\par
                  trc2d(ji,jj,22) = trc2d(ji,jj,22) + (ffetop  * fthk)         !! aeolian  iron addition\par
                  trc2d(ji,jj,23) = trc2d(ji,jj,23) + (ffebot  * fthk)         !! seafloor iron addition\par
                  trc2d(ji,jj,24) = trc2d(ji,jj,24) + (ffescav * fthk)         !! "free" iron scavenging\par
                  trc2d(ji,jj,25) = trc2d(ji,jj,25) + (fjlim_pn * zphn * fthk) !! non-diatom J  limitation term \par
                  trc2d(ji,jj,26) = trc2d(ji,jj,26) + (fnln  * zphn * fthk)    !! non-diatom N  limitation term \par
                  trc2d(ji,jj,27) = trc2d(ji,jj,27) + (ffln  * zphn * fthk)    !! non-diatom Fe limitation term \par
                  trc2d(ji,jj,28) = trc2d(ji,jj,28) + (fjlim_pd * zphd * fthk) !! diatom     J  limitation term \par
                  trc2d(ji,jj,29) = trc2d(ji,jj,29) + (fnld  * zphd * fthk)    !! diatom     N  limitation term \par
                  trc2d(ji,jj,30) = trc2d(ji,jj,30) + (ffld  * zphd * fthk)    !! diatom     Fe limitation term \par
                  trc2d(ji,jj,31) = trc2d(ji,jj,31) + (fsld2 * zphd * fthk)    !! diatom     Si limitation term \par
                  trc2d(ji,jj,32) = trc2d(ji,jj,32) + (fsld  * zphd * fthk)    !! diatom     Si uptake limitation term\par
                  if (jk.eq.i0100) trc2d(ji,jj,33) = fslownflux(ji,jj)         !! slow detritus flux at  100 m\par
                  if (jk.eq.i0200) trc2d(ji,jj,34) = fslownflux(ji,jj)         !! slow detritus flux at  200 m\par
                  if (jk.eq.i0500) trc2d(ji,jj,35) = fslownflux(ji,jj)         !! slow detritus flux at  500 m\par
                  if (jk.eq.i1000) trc2d(ji,jj,36) = fslownflux(ji,jj)         !! slow detritus flux at 1000 m\par
                  trc2d(ji,jj,37) = trc2d(ji,jj,37) + fregen                   !! non-fast N  full column regeneration\par
                  trc2d(ji,jj,38) = trc2d(ji,jj,38) + fregensi                 !! non-fast Si full column regeneration\par
                  if (jk.eq.i0100) trc2d(ji,jj,39) = trc2d(ji,jj,37)           !! non-fast N  regeneration to  100 m\par
                  if (jk.eq.i0200) trc2d(ji,jj,40) = trc2d(ji,jj,37)           !! non-fast N  regeneration to  200 m\par
                  if (jk.eq.i0500) trc2d(ji,jj,41) = trc2d(ji,jj,37)           !! non-fast N  regeneration to  500 m\par
                  if (jk.eq.i1000) trc2d(ji,jj,42) = trc2d(ji,jj,37)           !! non-fast N  regeneration to 1000 m\par
                  trc2d(ji,jj,43) = trc2d(ji,jj,43) + (ftempn  * fthk)         !! fast sinking detritus N production\par
                  trc2d(ji,jj,44) = trc2d(ji,jj,44) + (ftempsi * fthk)         !! fast sinking detritus Si production\par
                  trc2d(ji,jj,45) = trc2d(ji,jj,45) + (ftempfe * fthk)         !! fast sinking detritus Fe production\par
                  trc2d(ji,jj,46) = trc2d(ji,jj,46) + (ftempc  * fthk)         !! fast sinking detritus C production\par
                  trc2d(ji,jj,47) = trc2d(ji,jj,47) + (ftempca * fthk)         !! fast sinking detritus CaCO3 production\par
                  if (jk.eq.i0100) trc2d(ji,jj,48) = ffastn(ji,jj)             !! fast detritus N  flux at  100 m\par
                  if (jk.eq.i0200) trc2d(ji,jj,49) = ffastn(ji,jj)             !! fast detritus N  flux at  200 m\par
                  if (jk.eq.i0500) trc2d(ji,jj,50) = ffastn(ji,jj)             !! fast detritus N  flux at  500 m\par
                  if (jk.eq.i1000) trc2d(ji,jj,51) = ffastn(ji,jj)             !! fast detritus N  flux at 1000 m\par
                  if (jk.eq.i0100) trc2d(ji,jj,52) = fregenfast(ji,jj)         !! N  regeneration to  100 m\par
                  if (jk.eq.i0200) trc2d(ji,jj,53) = fregenfast(ji,jj)         !! N  regeneration to  200 m\par
                  if (jk.eq.i0500) trc2d(ji,jj,54) = fregenfast(ji,jj)         !! N  regeneration to  500 m\par
                  if (jk.eq.i1000) trc2d(ji,jj,55) = fregenfast(ji,jj)         !! N  regeneration to 1000 m\par
                  if (jk.eq.i0100) trc2d(ji,jj,56) = ffastsi(ji,jj)            !! fast detritus Si flux at  100 m\par
                  if (jk.eq.i0200) trc2d(ji,jj,57) = ffastsi(ji,jj)            !! fast detritus Si flux at  200 m\par
                  if (jk.eq.i0500) trc2d(ji,jj,58) = ffastsi(ji,jj)            !! fast detritus Si flux at  500 m\par
                  if (jk.eq.i1000) trc2d(ji,jj,59) = ffastsi(ji,jj)            !! fast detritus Si flux at 1000 m\par
                  if (jk.eq.i0100) trc2d(ji,jj,60) = fregenfastsi(ji,jj)       !! Si regeneration to  100 m\par
                  if (jk.eq.i0200) trc2d(ji,jj,61) = fregenfastsi(ji,jj)       !! Si regeneration to  200 m\par
                  if (jk.eq.i0500) trc2d(ji,jj,62) = fregenfastsi(ji,jj)       !! Si regeneration to  500 m\par
                  if (jk.eq.i1000) trc2d(ji,jj,63) = fregenfastsi(ji,jj)       !! Si regeneration to 1000 m\par
                  trc2d(ji,jj,64) = trc2d(ji,jj,64) + (freminn  * fthk)        !! sum of fast-sinking N  fluxes\par
                  trc2d(ji,jj,65) = trc2d(ji,jj,65) + (freminsi * fthk)        !! sum of fast-sinking Si fluxes\par
                  trc2d(ji,jj,66) = trc2d(ji,jj,66) + (freminfe * fthk)        !! sum of fast-sinking Fe fluxes\par
                  trc2d(ji,jj,67) = trc2d(ji,jj,67) + (freminc  * fthk)        !! sum of fast-sinking C  fluxes\par
                  trc2d(ji,jj,68) = trc2d(ji,jj,68) + (freminca * fthk)        !! sum of fast-sinking Ca fluxes\par
                  if (jk.eq.jmbathy) then\par
                     trc2d(ji,jj,69) = fsedn(ji,jj)                                   !! N  sedimentation flux                                  \par
                     trc2d(ji,jj,70) = fsedsi(ji,jj)                                  !! Si sedimentation flux\par
                     trc2d(ji,jj,71) = fsedfe(ji,jj)                                  !! Fe sedimentation flux\par
                     trc2d(ji,jj,72) = fsedc(ji,jj)                                   !! C  sedimentation flux\par
                     trc2d(ji,jj,73) = fsedca(ji,jj)                                  !! Ca sedimentation flux\par
                  endif\par
                  if (jk.eq.1)  trc2d(ji,jj,74) = qsr(ji,jj)\par
                  if (jk.eq.1)  trc2d(ji,jj,75) = xpar(ji,jj,jk)\par
                  !! if (jk.eq.1)  trc2d(ji,jj,75) = real(iters)\par
                  !! diagnostic fields 76 to 80 calculated below\par
                  trc2d(ji,jj,81) = trc2d(ji,jj,81) + fprn_ml(ji,jj)           !! mixed layer non-diatom production\par
                  trc2d(ji,jj,82) = trc2d(ji,jj,82) + fprd_ml(ji,jj)           !! mixed layer     diatom production\par
# if defined key_gulf_finland\par
                  if (jk.eq.1)  trc2d(ji,jj,83) = real(ibio_switch)            !! Gulf of Finland check\par
# else\par
                  trc2d(ji,jj,83) = ocal_ccd(ji,jj)                            !! calcite CCD depth\par
# endif\par
                  trc2d(ji,jj,84) = fccd(ji,jj)                                !! last model level above calcite CCD depth\par
                  if (jk.eq.1)     trc2d(ji,jj,85) = xFree(ji,jj)              !! surface "free" iron\par
                  if (jk.eq.i0200) trc2d(ji,jj,86) = xFree(ji,jj)              !! "free" iron at  100 m\par
                  if (jk.eq.i0200) trc2d(ji,jj,87) = xFree(ji,jj)              !! "free" iron at  200 m\par
                  if (jk.eq.i0500) trc2d(ji,jj,88) = xFree(ji,jj)              !! "free" iron at  500 m\par
                  if (jk.eq.i1000) trc2d(ji,jj,89) = xFree(ji,jj)              !! "free" iron at 1000 m\par
                  !! AXY (27/06/12): extract "euphotic depth"\par
                  if (jk.eq.1)     trc2d(ji,jj,90) = xze(ji,jj)\par
                  !! \par
# if defined key_roam\par
                  !! ROAM provisionally has access to a further 20 2D diagnostics\par
                  if (jk .eq. 1) then\par
                     trc2d(ji,jj,91)  = trc2d(ji,jj,91)  + f_wind              !! surface wind\par
                     trc2d(ji,jj,92)  = trc2d(ji,jj,92)  + f_pco2atm           !! atmospheric pCO2\par
                     trc2d(ji,jj,93)  = trc2d(ji,jj,93)  + f_ph                !! ocean pH\par
                     trc2d(ji,jj,94)  = trc2d(ji,jj,94)  + f_pco2w             !! ocean pCO2\par
                     trc2d(ji,jj,95)  = trc2d(ji,jj,95)  + f_h2co3             !! ocean H2CO3 conc.\par
                     trc2d(ji,jj,96)  = trc2d(ji,jj,96)  + f_hco3              !! ocean HCO3 conc.\par
                     trc2d(ji,jj,97)  = trc2d(ji,jj,97)  + f_co3               !! ocean CO3 conc.\par
                     trc2d(ji,jj,98)  = trc2d(ji,jj,98)  + f_co2flux           !! air-sea CO2 flux\par
                     trc2d(ji,jj,99)  = trc2d(ji,jj,99)  + f_omcal(ji,jj)      !! ocean omega calcite \par
                     trc2d(ji,jj,100) = trc2d(ji,jj,100) + f_omarg(ji,jj)      !! ocean omega aragonite\par
                     trc2d(ji,jj,101) = trc2d(ji,jj,101) + f_TDIC              !! ocean TDIC\par
                     trc2d(ji,jj,102) = trc2d(ji,jj,102) + f_TALK              !! ocean TALK\par
                     trc2d(ji,jj,103) = trc2d(ji,jj,103) + f_kw660             !! surface kw660\par
                     trc2d(ji,jj,104) = trc2d(ji,jj,104) + f_pp0               !! surface pressure\par
                     trc2d(ji,jj,105) = trc2d(ji,jj,105) + f_o2flux            !! air-sea O2 flux\par
                     trc2d(ji,jj,106) = trc2d(ji,jj,106) + f_o2sat             !! ocean O2 saturation\par
                     trc2d(ji,jj,107) = f2_ccd_cal(ji,jj)                      !! depth calcite CCD\par
                     trc2d(ji,jj,108) = f2_ccd_arg(ji,jj)                      !! depth aragonite CCD\par
                  endif\par
                  if (jk .eq. jmbathy) then\par
                     trc2d(ji,jj,109) = f3_omcal(ji,jj,jk)                     !! seafloor omega calcite\par
                     trc2d(ji,jj,110) = f3_omarg(ji,jj,jk)                     !! seafloor omega aragonite\par
                  endif\par
                  !! diagnostic fields 111 to 117 calculated below\par
                  if (jk.eq.i0100) trc2d(ji,jj,118) = ffastca(ji,jj)/MAX(ffastc(ji,jj), rsmall)  !! rain ratio at  100 m\par
                  if (jk.eq.i0500) trc2d(ji,jj,119) = ffastca(ji,jj)/MAX(ffastc(ji,jj), rsmall)  !! rain ratio at  500 m\par
                  if (jk.eq.i1000) trc2d(ji,jj,120) = ffastca(ji,jj)/MAX(ffastc(ji,jj), rsmall)  !! rain ratio at 1000 m\par
                  !! AXY (18/01/12): benthic flux diagnostics\par
                  if (jk.eq.jmbathy) then\par
                     trc2d(ji,jj,121) = f_sbenin_n(ji,jj)  + f_fbenin_n(ji,jj)\par
                     trc2d(ji,jj,122) = f_sbenin_fe(ji,jj) + f_fbenin_fe(ji,jj)\par
                     trc2d(ji,jj,123) = f_sbenin_c(ji,jj)  + f_fbenin_c(ji,jj)\par
                     trc2d(ji,jj,124) = f_fbenin_si(ji,jj)\par
                     trc2d(ji,jj,125) = f_fbenin_ca(ji,jj)\par
                     trc2d(ji,jj,126) = f_benout_n(ji,jj)\par
                     trc2d(ji,jj,127) = f_benout_fe(ji,jj)\par
                     trc2d(ji,jj,128) = f_benout_c(ji,jj)\par
                     trc2d(ji,jj,129) = f_benout_si(ji,jj)\par
                     trc2d(ji,jj,130) = f_benout_ca(ji,jj)\par
                  endif\par
                  !! diagnostics fields 131 to 135 calculated below\par
                  trc2d(ji,jj,136) = f_runoff(ji,jj)\par
                  !! AXY (19/07/12): amended to allow for riverine nutrient addition below surface\par
                  trc2d(ji,jj,137) = trc2d(ji,jj,137) + (f_riv_loc_n * fthk)\par
                  trc2d(ji,jj,138) = trc2d(ji,jj,138) + (f_riv_loc_si * fthk)\par
                  trc2d(ji,jj,139) = trc2d(ji,jj,139) + (f_riv_loc_c * fthk)\par
                  trc2d(ji,jj,140) = trc2d(ji,jj,140) + (f_riv_loc_alk * fthk)\par
                  trc2d(ji,jj,141) = trc2d(ji,jj,141) + (fslowc  * fthk)       !! slow sinking detritus C production\par
                  if (jk.eq.i0100) trc2d(ji,jj,142) = fslowcflux(ji,jj)        !! slow detritus flux at  100 m\par
                  if (jk.eq.i0200) trc2d(ji,jj,143) = fslowcflux(ji,jj)        !! slow detritus flux at  200 m\par
                  if (jk.eq.i0500) trc2d(ji,jj,144) = fslowcflux(ji,jj)        !! slow detritus flux at  500 m\par
                  if (jk.eq.i1000) trc2d(ji,jj,145) = fslowcflux(ji,jj)        !! slow detritus flux at 1000 m\par
                  trc2d(ji,jj,146)  = trc2d(ji,jj,146)  + ftot_c(ji,jj)        !! carbon     inventory\par
                  trc2d(ji,jj,147)  = trc2d(ji,jj,147)  + ftot_a(ji,jj)        !! alkalinity inventory\par
                  trc2d(ji,jj,148)  = trc2d(ji,jj,148)  + ftot_o2(ji,jj)       !! oxygen     inventory\par
                  if (jk.eq.jmbathy) then\par
                     trc2d(ji,jj,149) = f_benout_lyso_ca(ji,jj)\par
                  endif\par
                  trc2d(ji,jj,150) = fcomm_resp(ji,jj) * fthk                  !! community respiration\par
\tab\tab   !!\par
\tab\tab   !! AXY (14/02/14): a Valentines Day gift to BASIN - a shedload of new\par
                  !!                 diagnostics that they'll most likely never need!\par
                  !!                 (actually, as with all such gifts, I'm giving them\par
                  !!                 some things I'd like myself!)\par
                  !! \par
                  !! ----------------------------------------------------------------------\par
                  !! linear losses\par
                  !! non-diatom\par
                  trc2d(ji,jj,151) = trc2d(ji,jj,151) + (fdpn2  * fthk)\par
                  !! diatom\par
                  trc2d(ji,jj,152) = trc2d(ji,jj,152) + (fdpd2  * fthk)\par
                  !! microzooplankton\par
                  trc2d(ji,jj,153) = trc2d(ji,jj,153) + (fdzmi2 * fthk)\par
                  !! mesozooplankton\par
                  trc2d(ji,jj,154) = trc2d(ji,jj,154) + (fdzme2 * fthk)\par
                  !! ----------------------------------------------------------------------\par
                  !! microzooplankton grazing\par
                  !! microzooplankton messy -> N\par
                  trc2d(ji,jj,155) = trc2d(ji,jj,155) + (xphi * (fgmipn + fgmid) * fthk)\par
                  !! microzooplankton messy -> D\par
                  trc2d(ji,jj,156) = trc2d(ji,jj,156) + ((1. - xbetan) * finmi * fthk)\par
                  !! microzooplankton messy -> DIC\par
                  trc2d(ji,jj,157) = trc2d(ji,jj,157) + (xphi * ((xthetapn * fgmipn) + fgmidc) * fthk)\par
                  !! microzooplankton messy -> Dc\par
                  trc2d(ji,jj,158) = trc2d(ji,jj,158) + ((1. - xbetac) * ficmi * fthk)\par
                  !! microzooplankton excretion\par
                  trc2d(ji,jj,159) = trc2d(ji,jj,159) + (fmiexcr * fthk)\par
                  !! microzooplankton respiration\par
                  trc2d(ji,jj,160) = trc2d(ji,jj,160) + (fmiresp * fthk)\par
                  !! microzooplankton growth\par
                  trc2d(ji,jj,161) = trc2d(ji,jj,161) + (fmigrow * fthk)\par
                  !! ----------------------------------------------------------------------\par
                  !! mesozooplankton grazing\par
                  !! mesozooplankton messy -> N\par
                  trc2d(ji,jj,162) = trc2d(ji,jj,162) + (xphi * (fgmepn + fgmepd + fgmezmi + fgmed) * fthk)\par
                  !! mesozooplankton messy -> D\par
                  trc2d(ji,jj,163) = trc2d(ji,jj,163) + ((1. - xbetan) * finme * fthk)\par
                  !! mesozooplankton messy -> DIC\par
                  trc2d(ji,jj,164) = trc2d(ji,jj,164) + (xphi * ((xthetapn * fgmepn) + (xthetapd * fgmepd) + &\par
                  &                  (xthetazmi * fgmezmi) + fgmedc) * fthk)\par
                  !! mesozooplankton messy -> Dc\par
                  trc2d(ji,jj,165) = trc2d(ji,jj,165) + ((1. - xbetac) * ficme * fthk)\par
                  !! mesozooplankton excretion\par
                  trc2d(ji,jj,166) = trc2d(ji,jj,166) + (fmeexcr * fthk)\par
                  !! mesozooplankton respiration\par
                  trc2d(ji,jj,167) = trc2d(ji,jj,167) + (fmeresp * fthk)\par
                  !! mesozooplankton growth\par
                  trc2d(ji,jj,168) = trc2d(ji,jj,168) + (fmegrow * fthk)\par
                  !! ----------------------------------------------------------------------\par
                  !! miscellaneous\par
                  trc2d(ji,jj,169) = trc2d(ji,jj,169) + (fddc    * fthk) !! detrital C remineralisation\par
                  trc2d(ji,jj,170) = trc2d(ji,jj,170) + (fgmidc  * fthk) !! microzoo grazing on detrital carbon\par
                  trc2d(ji,jj,171) = trc2d(ji,jj,171) + (fgmedc  * fthk) !! mesozoo  grazing on detrital carbon\par
                  !!\par
                  !! ----------------------------------------------------------------------\par
\tab\tab   !!\par
\tab\tab   !! AXY (23/10/14): extract primary production related surface fields to\par
\tab\tab   !!                 deal with diel cycle issues; hijacking BASIN 150m\par
\tab\tab   !!                 diagnostics to do so (see commented out diagnostics\par
\tab\tab   !!                 below this section)\par
\tab\tab   !!\par
\tab\tab   !! extract fields at surface\par
\tab\tab  !! if (jk .eq. 1) then\par
                 !!    trc2d(ji,jj,172) = zchn              !! Pn chlorophyll\par
                 !!    trc2d(ji,jj,173) = zphn              !! Pn biomass\par
                 !!    trc2d(ji,jj,174) = fjln              !! Pn J-term\par
                 !!    trc2d(ji,jj,175) = (fprn * zphn)     !! Pn PP\par
                 !!    trc2d(ji,jj,176) = zchd              !! Pd chlorophyll\par
                 !!    trc2d(ji,jj,177) = zphd              !! Pd biomass\par
                 !!    trc2d(ji,jj,178) = fjld              !! Pd J-term\par
                 !!    trc2d(ji,jj,179) = xpar(ji,jj,jk)    !! Pd PP\par
                 !!    trc2d(ji,jj,180) = loc_T             !! local temperature\par
                 !! endif\par
\tab\tab  !! !!\par
\tab\tab  !! !! extract fields at 50m (actually 44-50m)\par
\tab\tab  !! if (jk .eq. 18) then\par
                 !!    trc2d(ji,jj,181) = zchn              !! Pn chlorophyll\par
                 !!    trc2d(ji,jj,182) = zphn              !! Pn biomass\par
                 !!    trc2d(ji,jj,183) = fjln              !! Pn J-term\par
                 !!    trc2d(ji,jj,184) = (fprn * zphn)     !! Pn PP\par
                 !!    trc2d(ji,jj,185) = zchd              !! Pd chlorophyll\par
                 !!    trc2d(ji,jj,186) = zphd              !! Pd biomass\par
                 !!    trc2d(ji,jj,187) = fjld              !! Pd J-term\par
                 !!    trc2d(ji,jj,188) = xpar(ji,jj,jk)    !! Pd PP\par
                 !!    trc2d(ji,jj,189) = loc_T             !! local temperature\par
                 !! endif\par
\tab\tab  !! !!\par
\tab\tab  !! !! extract fields at 100m\par
\tab\tab  !! if (jk .eq. i0100) then\par
                 !!    trc2d(ji,jj,190) = zchn              !! Pn chlorophyll\par
                 !!    trc2d(ji,jj,191) = zphn              !! Pn biomass\par
                 !!    trc2d(ji,jj,192) = fjln              !! Pn J-term\par
                 !!    trc2d(ji,jj,193) = (fprn * zphn)     !! Pn PP\par
                 !!    trc2d(ji,jj,194) = zchd              !! Pd chlorophyll\par
                 !!    trc2d(ji,jj,195) = zphd              !! Pd biomass\par
                 !!    trc2d(ji,jj,196) = fjld              !! Pd J-term\par
                 !!    trc2d(ji,jj,197) = xpar(ji,jj,jk)    !! Pd PP\par
                 !!    trc2d(ji,jj,198) = loc_T             !! local temperature\par
                 !! endif\par
                 !!\par
                  !! extract relevant BASIN fields at 150m\par
                  if (jk .eq. i0150) then\par
                     trc2d(ji,jj,172) = trc2d(ji,jj,4)    !! Pn PP\par
                     trc2d(ji,jj,173) = trc2d(ji,jj,151)  !! Pn linear loss\par
                     trc2d(ji,jj,174) = trc2d(ji,jj,5)    !! Pn non-linear loss\par
                     trc2d(ji,jj,175) = trc2d(ji,jj,11)   !! Pn grazing to Zmi\par
                     trc2d(ji,jj,176) = trc2d(ji,jj,14)   !! Pn grazing to Zme\par
                     trc2d(ji,jj,177) = trc2d(ji,jj,6)    !! Pd PP\par
                     trc2d(ji,jj,178) = trc2d(ji,jj,152)  !! Pd linear loss\par
                     trc2d(ji,jj,179) = trc2d(ji,jj,7)    !! Pd non-linear loss\par
                     trc2d(ji,jj,180) = trc2d(ji,jj,15)   !! Pd grazing to Zme\par
                     trc2d(ji,jj,181) = trc2d(ji,jj,12)   !! Zmi grazing on D\par
                     trc2d(ji,jj,182) = trc2d(ji,jj,170)  !! Zmi grazing on Dc\par
                     trc2d(ji,jj,183) = trc2d(ji,jj,155)  !! Zmi messy feeding loss to N\par
                     trc2d(ji,jj,184) = trc2d(ji,jj,156)  !! Zmi messy feeding loss to D\par
                     trc2d(ji,jj,185) = trc2d(ji,jj,157)  !! Zmi messy feeding loss to DIC\par
                     trc2d(ji,jj,186) = trc2d(ji,jj,158)  !! Zmi messy feeding loss to Dc\par
                     trc2d(ji,jj,187) = trc2d(ji,jj,159)  !! Zmi excretion\par
                     trc2d(ji,jj,188) = trc2d(ji,jj,160)  !! Zmi respiration\par
                     trc2d(ji,jj,189) = trc2d(ji,jj,161)  !! Zmi growth\par
                     trc2d(ji,jj,190) = trc2d(ji,jj,153)  !! Zmi linear loss\par
                     trc2d(ji,jj,191) = trc2d(ji,jj,13)   !! Zmi non-linear loss\par
                     trc2d(ji,jj,192) = trc2d(ji,jj,16)   !! Zmi grazing to Zme\par
                     trc2d(ji,jj,193) = trc2d(ji,jj,17)   !! Zme grazing on D\par
                     trc2d(ji,jj,194) = trc2d(ji,jj,171)  !! Zme grazing on Dc\par
                     trc2d(ji,jj,195) = trc2d(ji,jj,162)  !! Zme messy feeding loss to N\par
                     trc2d(ji,jj,196) = trc2d(ji,jj,163)  !! Zme messy feeding loss to D\par
                     trc2d(ji,jj,197) = trc2d(ji,jj,164)  !! Zme messy feeding loss to DIC\par
                     trc2d(ji,jj,198) = trc2d(ji,jj,165)  !! Zme messy feeding loss to Dc\par
                     trc2d(ji,jj,199) = trc2d(ji,jj,166)  !! Zme excretion\par
                     trc2d(ji,jj,200) = trc2d(ji,jj,167)  !! Zme respiration\par
                     trc2d(ji,jj,201) = trc2d(ji,jj,168)  !! Zme growth\par
                     trc2d(ji,jj,202) = trc2d(ji,jj,154)  !! Zme linear loss\par
                     trc2d(ji,jj,203) = trc2d(ji,jj,18)   !! Zme non-linear loss\par
                     trc2d(ji,jj,204) = trc2d(ji,jj,20)   !! Slow detritus production, N\par
                     trc2d(ji,jj,205) = trc2d(ji,jj,21)   !! Slow detritus remineralisation, N\par
                     trc2d(ji,jj,206) = trc2d(ji,jj,141)  !! Slow detritus production, C\par
                     trc2d(ji,jj,207) = trc2d(ji,jj,169)  !! Slow detritus remineralisation, C\par
                     trc2d(ji,jj,208) = trc2d(ji,jj,43)   !! Fast detritus production, N\par
                     trc2d(ji,jj,209) = trc2d(ji,jj,21)   !! Fast detritus remineralisation, N\par
                     trc2d(ji,jj,210) = trc2d(ji,jj,64)   !! Fast detritus production, C\par
                     trc2d(ji,jj,211) = trc2d(ji,jj,67)   !! Fast detritus remineralisation, C\par
                     trc2d(ji,jj,212) = trc2d(ji,jj,150)  !! Community respiration\par
                     trc2d(ji,jj,213) = fslownflux(ji,jj) !! Slow detritus N flux at 150 m\par
                     trc2d(ji,jj,214) = fslowcflux(ji,jj) !! Slow detritus C flux at 150 m\par
                     trc2d(ji,jj,215) = ffastn(ji,jj)     !! Fast detritus N flux at 150 m\par
                     trc2d(ji,jj,216) = ffastc(ji,jj)     !! Fast detritus C flux at 150 m\par
                  endif\par
                  !! \par
                  !! Jpalm (11-08-2014)\par
                  !! Add UKESM1 diagnoatics \par
                  !!^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\par
                  if ((jk .eq. 1) .and.( jdms.eq.1)) then\par
                     trc2d(ji,jj,221) = dms_surf          !! DMS surface concentration \par
                     !! AXY (13/03/15): add in other DMS estimates\par
                     trc2d(ji,jj,222) = dms_andr          !! DMS surface concentration \par
                     trc2d(ji,jj,223) = dms_simo          !! DMS surface concentration \par
                     trc2d(ji,jj,224) = dms_aran          !! DMS surface concentration \par
                     trc2d(ji,jj,225) = dms_hall          !! DMS surface concentration \par
                  endif\par
# endif\par
                  !! other possible future diagnostics include:\par
                  !!   - integrated tracer values (esp. biological)\par
                  !!   - mixed layer tracer values\par
                  !!   - sub-surface chlorophyll maxima (plus depth)\par
                  !!   - different mixed layer depth criteria (T, sigma, var. sigma)\par
\par
                  !!----------------------------------------------------------------------\par
                  !! Prepare 3D diagnostics\par
                  !!----------------------------------------------------------------------\par
                  !!\par
                  trc3d(ji,jj,jk,1)  = ((fprn + fprd) * zphn)     !! primary production  \par
                  trc3d(ji,jj,jk,2)  = fslownflux(ji,jj) + ffastn(ji,jj) !! detrital flux\par
                  trc3d(ji,jj,jk,3)  = fregen + (freminn * fthk)  !! remineralisation\par
# if defined key_roam\par
                  trc3d(ji,jj,jk,4)  = f3_pH(ji,jj,jk)            !! pH\par
                  trc3d(ji,jj,jk,5)  = f3_omcal(ji,jj,jk)         !! omega calcite\par
# else\par
                  trc3d(ji,jj,jk,4)  = ffastsi(ji,jj)             !! fast Si flux\par
# endif\par
             ENDIF   ! end of ln_diatrc option\par
             !! CLOSE wet point IF..THEN loop\par
            endif\par
         !! CLOSE horizontal loops\par
         ENDDO\par
         ENDDO\par
         !!\par
             IF( lk_iomput  .AND.  .NOT.  ln_diatrc  ) THEN\par
                 !! first - 2D diag implemented \par
                 !!         on every K level\par
                 !!-----------------------------------------\par
                 !!  --\par
                 !!second - 2d specific k level diags\par
                 !!\par
                 !!-----------------------------------------\par
                 IF (jk.eq.1) THEN\par
#   if defined key_debug_medusa\par
                     IF (lwp) write (numout,*) 'trc_bio_medusa: diag jk = 1'\par
                     CALL flush(numout)\par
#   endif            \par
                     !! JPALM -- 02-06-2017 --\par
                     !! add Chl surf coupling\par
                     !! no need to output, just pass to cpl var\par
                     IF (lk_oasis) THEN\par
                          zn_chl_srf(:,:) = (trn(:,:,1,jpchd) + trn(:,:,1,jpchn)) * 1.0E-6  !! surf Chl in Kg-chl/m3 as needed for cpl\par
                         chloro_out_cpl(:,:) = zn_chl_srf(:,:)        !! Coupling Chl\par
                     END IF\par
                     IF( med_diag%MED_QSR%dgsave ) THEN\par
                         CALL iom_put( "MED_QSR"  , qsr ) !\par
                     ENDIF\par
                     IF( med_diag%MED_XPAR%dgsave ) THEN\par
                         CALL iom_put( "MED_XPAR"  , xpar(:,:,jk) ) !\par
                     ENDIF       \par
                     IF( med_diag%OCAL_CCD%dgsave ) THEN\par
                         CALL iom_put( "OCAL_CCD"  , ocal_ccd ) !\par
                     ENDIF\par
                     IF( med_diag%FE_0000%dgsave ) THEN\par
                         CALL iom_put( "FE_0000"  , xFree ) !\par
                     ENDIF                     \par
                     IF( med_diag%MED_XZE%dgsave ) THEN\par
                         CALL iom_put( "MED_XZE"  , xze ) !\par
                     ENDIF \par
# if defined key_roam                     \par
                     IF( med_diag%WIND%dgsave ) THEN\par
                         CALL iom_put( "WIND"  , wndm )\par
                     ENDIF\par
                     IF( med_diag%ATM_PCO2%dgsave ) THEN\par
                         CALL iom_put( "ATM_PCO2"  , f_pco2a2d )\par
                         CALL wrk_dealloc( jpi, jpj,    f_pco2a2d  )\par
                     ENDIF\par
                     IF( med_diag%OCN_PH%dgsave ) THEN\par
                         zw2d(:,:) = f3_pH(:,:,jk)\par
                         CALL iom_put( "OCN_PH"  , zw2d )\par
                     ENDIF\par
                     IF( med_diag%OCN_PCO2%dgsave ) THEN\par
                        CALL iom_put( "OCN_PCO2"  , f_pco2w2d )\par
                        CALL wrk_dealloc( jpi, jpj,   f_pco2w2d   )\par
                     ENDIF\par
                     IF( med_diag%OCNH2CO3%dgsave ) THEN\par
                         zw2d(:,:) = f3_h2co3(:,:,jk)\par
                         CALL iom_put( "OCNH2CO3"  , zw2d )\par
                     ENDIF\par
                     IF( med_diag%OCN_HCO3%dgsave ) THEN\par
                         zw2d(:,:) = f3_hco3(:,:,jk)\par
                         CALL iom_put( "OCN_HCO3"  , zw2d )\par
                     ENDIF\par
                     IF( med_diag%OCN_CO3%dgsave ) THEN\par
                         zw2d(:,:) = f3_co3(:,:,jk)\par
                         CALL iom_put( "OCN_CO3"  , zw2d )\par
                     ENDIF\par
                     IF( med_diag%CO2FLUX%dgsave ) THEN\par
                        CALL iom_put( "CO2FLUX"  , f_co2flux2d )\par
                        CALL wrk_dealloc( jpi, jpj,   f_co2flux2d   )\par
                     ENDIF\par
                     !! \par
                     !! AXY (10/11/16): repeat CO2 flux diagnostic in UKMO/CMIP6 units; this\par
                     !!                 both outputs the CO2 flux in specified units and\par
                     !!                 sends the resulting field to the coupler\par
                     !! JPALM (17/11/16): put CO2 flux (fgco2) alloc/unalloc/pass to zn \par
                     !!                 out of diag list request \par
                     CALL lbc_lnk( fgco2(:,:),'T',1. )\par
                     IF( med_diag%FGCO2%dgsave ) THEN\par
                         CALL iom_put( "FGCO2"  , fgco2 )\par
                     ENDIF\par
                     !! JPALM (17/11/16): should mv this fgco2 part \par
                     !!                   out of lk_iomput loop\par
                     zb_co2_flx = zn_co2_flx\par
                     zn_co2_flx = fgco2\par
                     IF (lk_oasis) THEN\par
                        CO2Flux_out_cpl = zn_co2_flx\par
                     ENDIF\par
                     CALL wrk_dealloc( jpi, jpj,   fgco2   )\par
                     !! ---\par
                     IF( med_diag%OM_CAL%dgsave ) THEN\par
                         CALL iom_put( "OM_CAL"  , f_omcal )\par
                     ENDIF\par
                     IF( med_diag%OM_ARG%dgsave ) THEN\par
                         CALL iom_put( "OM_ARG"  , f_omarg )\par
                     ENDIF\par
                     IF( med_diag%TCO2%dgsave ) THEN\par
                         CALL iom_put( "TCO2"  , f_TDIC2d )\par
                         CALL wrk_dealloc( jpi, jpj,   f_TDIC2d   )\par
                     ENDIF\par
                     IF( med_diag%TALK%dgsave ) THEN\par
                         CALL iom_put( "TALK"  , f_TALK2d )\par
                         CALL wrk_dealloc( jpi, jpj,    f_TALK2d  )\par
                     ENDIF\par
                     IF( med_diag%KW660%dgsave ) THEN\par
                         CALL iom_put( "KW660"  , f_kw6602d )\par
                         CALL wrk_dealloc( jpi, jpj,   f_kw6602d   )\par
                     ENDIF\par
                     IF( med_diag%ATM_PP0%dgsave ) THEN\par
                         CALL iom_put( "ATM_PP0"  , f_pp02d )\par
                         CALL wrk_dealloc( jpi, jpj,    f_pp02d  )\par
                     ENDIF\par
                     IF( med_diag%O2FLUX%dgsave ) THEN\par
                         CALL iom_put( "O2FLUX"  , f_o2flux2d )\par
                         CALL wrk_dealloc( jpi, jpj,   f_o2flux2d   )\par
                     ENDIF\par
                     IF( med_diag%O2SAT%dgsave ) THEN\par
                         CALL iom_put( "O2SAT"  , f_o2sat2d )\par
                         CALL wrk_dealloc( jpi, jpj,  f_o2sat2d    )\par
                     ENDIF\par
                     IF( med_diag%CAL_CCD%dgsave ) THEN\par
                         CALL iom_put( "CAL_CCD"  , f2_ccd_cal )\par
                     ENDIF\par
                     IF( med_diag%ARG_CCD%dgsave ) THEN\par
                         CALL iom_put( "ARG_CCD"  , f2_ccd_arg )\par
                     ENDIF\par
                     IF (jdms .eq. 1) THEN\par
                       IF( med_diag%DMS_SURF%dgsave ) THEN\par
                         CALL lbc_lnk(dms_surf2d(:,:),'T',1. )\par
                         CALL iom_put( "DMS_SURF"  , dms_surf2d )\par
                         zb_dms_srf = zn_dms_srf\par
                         zn_dms_srf = dms_surf2d\par
                         IF (lk_oasis) THEN\par
                            DMS_out_cpl = zn_dms_srf\par
                         ENDIF\par
                         CALL wrk_dealloc( jpi, jpj,   dms_surf2d   ) \par
                       ENDIF\par
                       IF( med_diag%DMS_ANDR%dgsave ) THEN\par
                         CALL iom_put( "DMS_ANDR"  , dms_andr2d )\par
                         CALL wrk_dealloc( jpi, jpj,   dms_andr2d   )\par
                       ENDIF\par
                       IF( med_diag%DMS_SIMO%dgsave ) THEN\par
                         CALL iom_put( "DMS_SIMO"  , dms_simo2d )\par
                         CALL wrk_dealloc( jpi, jpj,    dms_simo2d  )\par
                       ENDIF\par
                       IF( med_diag%DMS_ARAN%dgsave ) THEN\par
                         CALL iom_put( "DMS_ARAN"  , dms_aran2d )\par
                         CALL wrk_dealloc( jpi, jpj,   dms_aran2d   )\par
                       ENDIF\par
                       IF( med_diag%DMS_HALL%dgsave ) THEN\par
                         CALL iom_put( "DMS_HALL"  , dms_hall2d )\par
                         CALL wrk_dealloc( jpi, jpj,   dms_hall2d   )\par
                       ENDIF\par
                       IF( med_diag%DMS_ANDM%dgsave ) THEN\par
                         CALL iom_put( "DMS_ANDM"  , dms_andm2d )\par
                         CALL wrk_dealloc( jpi, jpj,   dms_andm2d   )\par
                       ENDIF\par
                     ENDIF\par
                     !! AXY (24/11/16): extra MOCSY diagnostics\par
                     IF( med_diag%ATM_XCO2%dgsave ) THEN\par
                        CALL iom_put( "ATM_XCO2"  ,   f_xco2a_2d      )\par
                        CALL wrk_dealloc( jpi, jpj,   f_xco2a_2d      )\par
                     ENDIF\par
                     IF( med_diag%OCN_FCO2%dgsave ) THEN\par
                        CALL iom_put( "OCN_FCO2"  ,   f_fco2w_2d      )\par
                        CALL wrk_dealloc( jpi, jpj,   f_fco2w_2d      )\par
                     ENDIF\par
                     IF( med_diag%ATM_FCO2%dgsave ) THEN\par
                        CALL iom_put( "ATM_FCO2"  ,   f_fco2a_2d      )\par
                        CALL wrk_dealloc( jpi, jpj,   f_fco2a_2d      )\par
                     ENDIF\par
                     IF( med_diag%OCN_RHOSW%dgsave ) THEN\par
                        CALL iom_put( "OCN_RHOSW"  ,  f_ocnrhosw_2d   )\par
                        CALL wrk_dealloc( jpi, jpj,   f_ocnrhosw_2d   )\par
                     ENDIF\par
                     IF( med_diag%OCN_SCHCO2%dgsave ) THEN\par
                        CALL iom_put( "OCN_SCHCO2"  , f_ocnschco2_2d  )\par
                        CALL wrk_dealloc( jpi, jpj,   f_ocnschco2_2d  )\par
                     ENDIF\par
                     IF( med_diag%OCN_KWCO2%dgsave ) THEN\par
                        CALL iom_put( "OCN_KWCO2"  ,  f_ocnkwco2_2d   )\par
                        CALL wrk_dealloc( jpi, jpj,   f_ocnkwco2_2d   )\par
                     ENDIF\par
                     IF( med_diag%OCN_K0%dgsave ) THEN\par
                        CALL iom_put( "OCN_K0"  ,     f_ocnk0_2d      )\par
                        CALL wrk_dealloc( jpi, jpj,   f_ocnk0_2d      )\par
                     ENDIF\par
                     IF( med_diag%CO2STARAIR%dgsave ) THEN\par
                        CALL iom_put( "CO2STARAIR"  , f_co2starair_2d )\par
                        CALL wrk_dealloc( jpi, jpj,   f_co2starair_2d )\par
                     ENDIF\par
                     IF( med_diag%OCN_DPCO2%dgsave ) THEN\par
                        CALL iom_put( "OCN_DPCO2"  ,  f_ocndpco2_2d   )\par
                        CALL wrk_dealloc( jpi, jpj,   f_ocndpco2_2d   )\par
                     ENDIF\par
# endif                     \par
                 ELSE IF (jk.eq.i0100) THEN \par
#   if defined key_debug_medusa\par
                     IF (lwp) write (numout,*) 'trc_bio_medusa: diag jk = 100'\par
                     CALL flush(numout)\par
#   endif\par
                     IF( med_diag%SDT__100%dgsave ) THEN\par
                        zw2d(:,:) = fslownflux(:,:) * tmask(:,:,jk)\par
                        CALL iom_put( "SDT__100"  , zw2d )\par
                     ENDIF\par
                     IF( med_diag%REG__100%dgsave ) THEN\par
                        CALL iom_put( "REG__100"  , fregen2d )\par
                     ENDIF\par
                     IF( med_diag%FDT__100%dgsave ) THEN\par
                        CALL iom_put( "FDT__100"  , ffastn )\par
                     ENDIF           \par
                     IF( med_diag%RG__100F%dgsave ) THEN\par
                        CALL iom_put( "RG__100F"  , fregenfast )\par
                     ENDIF\par
                     IF( med_diag%FDS__100%dgsave ) THEN\par
                        CALL iom_put( "FDS__100"  , ffastsi )\par
                     ENDIF         \par
                     IF( med_diag%RGS_100F%dgsave ) THEN\par
                        CALL iom_put( "RGS_100F"  , fregenfastsi )\par
                     ENDIF\par
                     IF( med_diag%FE_0100%dgsave ) THEN\par
                        CALL iom_put( "FE_0100"  , xFree )\par
                     ENDIF\par
# if defined key_roam                     \par
                     IF( med_diag%RR_0100%dgsave ) THEN\par
                        CALL iom_put( "RR_0100"  , ffastca2d )\par
                     ENDIF                     \par
                     IF( med_diag%SDC__100%dgsave ) THEN\par
                        zw2d(:,:) = fslowcflux(:,:) * tmask(:,:,jk)\par
                        CALL iom_put( "SDC__100"  , zw2d )\par
                     ENDIF                  \par
                     IF( med_diag%epC100%dgsave    ) THEN\par
                        zw2d(:,:) = (fslowcflux + ffastc) * tmask(:,:,jk)\par
                        CALL iom_put( "epC100"    , zw2d )\par
                     ENDIF\tab\tab      \par
                     IF( med_diag%epCALC100%dgsave ) THEN\par
                        CALL iom_put( "epCALC100" , ffastca )\par
                     ENDIF\tab\tab      \par
                     IF( med_diag%epN100%dgsave    ) THEN\par
                        zw2d(:,:) = (fslownflux + ffastn) * tmask(:,:,jk)\par
                        CALL iom_put( "epN100"    , zw2d )\par
                     ENDIF\tab\tab      \par
                     IF( med_diag%epSI100%dgsave   ) THEN\par
                        CALL iom_put( "epSI100"   , ffastsi )\par
                     ENDIF\tab\tab      \par
                 ELSE IF (jk.eq.i0150) THEN\par
#   if defined key_debug_medusa\par
                     IF (lwp) write (numout,*) 'trc_bio_medusa: diag jk = 150'\par
                     CALL flush(numout)\par
#   endif\par
# endif                     \par
                 ELSE IF (jk.eq.i0200) THEN\par
#   if defined key_debug_medusa\par
                     IF (lwp) write (numout,*) 'trc_bio_medusa: diag jk = 200'\par
                     CALL flush(numout)\par
#   endif\par
                     IF( med_diag%SDT__200%dgsave ) THEN\par
                        zw2d(:,:) = fslownflux(:,:) * tmask(:,:,jk)\par
                        CALL iom_put( "SDT__200"  , zw2d )\par
                     ENDIF\par
                     IF( med_diag%REG__200%dgsave ) THEN\par
                        CALL iom_put( "REG__200"  , fregen2d )\par
                     ENDIF\par
                     IF( med_diag%FDT__200%dgsave ) THEN\par
                        CALL iom_put( "FDT__200"  , ffastn )\par
                     ENDIF\par
                     IF( med_diag%RG__200F%dgsave ) THEN\par
                        CALL iom_put( "RG__200F"  , fregenfast )\par
                     ENDIF\par
                     IF( med_diag%FDS__200%dgsave ) THEN\par
                        CALL iom_put( "FDS__200"  , ffastsi )\par
                     ENDIF\par
                     IF( med_diag%RGS_200F%dgsave ) THEN\par
                        CALL iom_put( "RGS_200F"  , fregenfastsi )\par
                     ENDIF\par
                     IF( med_diag%FE_0200%dgsave ) THEN\par
                        CALL iom_put( "FE_0200"   , xFree )\par
                     ENDIF\par
# if defined key_roam                     \par
                     IF( med_diag%SDC__200%dgsave ) THEN\par
                        zw2d(:,:) = fslowcflux(:,:) * tmask(:,:,jk)\par
                        CALL iom_put( "SDC__200"  , zw2d )\par
                     ENDIF\par
# endif                     \par
                 ELSE IF (jk.eq.i0500) THEN\par
#   if defined key_debug_medusa\par
                     IF (lwp) write (numout,*) 'trc_bio_medusa: diag jk = 500'\par
                     CALL flush(numout)\par
#   endif\par
                     IF( med_diag%SDT__500%dgsave ) THEN\par
                        zw2d(:,:) = fslownflux(:,:) * tmask(:,:,jk)\par
                        CALL iom_put( "SDT__500"  , zw2d )\par
                     ENDIF\par
                     IF( med_diag%REG__500%dgsave ) THEN\par
                        CALL iom_put( "REG__500"  , fregen2d )\par
                     ENDIF      \par
                     IF( med_diag%FDT__500%dgsave ) THEN\par
                        CALL iom_put( "FDT__500"  , ffastn )\par
                     ENDIF\par
                     IF( med_diag%RG__500F%dgsave ) THEN\par
                        CALL iom_put( "RG__500F"  , fregenfast )\par
                     ENDIF\par
                     IF( med_diag%FDS__500%dgsave ) THEN\par
                        CALL iom_put( "FDS__500"  , ffastsi )\par
                     ENDIF\par
                     IF( med_diag%RGS_500F%dgsave ) THEN\par
                        CALL iom_put( "RGS_500F"  , fregenfastsi )\par
                     ENDIF\par
                     IF( med_diag%FE_0500%dgsave ) THEN\par
                        CALL iom_put( "FE_0500"  , xFree )\par
                     ENDIF\par
# if defined key_roam                     \par
                     IF( med_diag%RR_0500%dgsave ) THEN\par
                        CALL iom_put( "RR_0500"  , ffastca2d )\par
                     ENDIF\par
                     IF( med_diag%SDC__500%dgsave ) THEN\par
                        zw2d(:,:) = fslowcflux(:,:) * tmask(:,:,jk)\par
                        CALL iom_put( "SDC__500"  , zw2d )\par
                     ENDIF  \par
# endif                      \par
                 ELSE IF (jk.eq.i1000) THEN\par
#   if defined key_debug_medusa\par
                     IF (lwp) write (numout,*) 'trc_bio_medusa: diag jk = 1000'\par
                     CALL flush(numout)\par
#   endif\par
                     IF( med_diag%SDT_1000%dgsave ) THEN\par
                        zw2d(:,:) = fslownflux(:,:) * tmask(:,:,jk)\par
                        CALL iom_put( "SDT_1000"  , zw2d )\par
                     ENDIF\par
                     IF( med_diag%REG_1000%dgsave ) THEN\par
                        CALL iom_put( "REG_1000"  , fregen2d )\par
                     ENDIF  \par
                     IF( med_diag%FDT_1000%dgsave ) THEN\par
                        CALL iom_put( "FDT_1000"  , ffastn )\par
                     ENDIF\par
                     IF( med_diag%RG_1000F%dgsave ) THEN\par
                        CALL iom_put( "RG_1000F"  , fregenfast )\par
                     ENDIF\par
                     IF( med_diag%FDS_1000%dgsave ) THEN\par
                        CALL iom_put( "FDS_1000"  , ffastsi )\par
                     ENDIF\par
                     IF( med_diag%RGS1000F%dgsave ) THEN\par
                        CALL iom_put( "RGS1000F"  , fregenfastsi )\par
                     ENDIF\par
                     IF( med_diag%FE_1000%dgsave ) THEN\par
                        CALL iom_put( "FE_1000"  , xFree )\par
                     ENDIF\par
# if defined key_roam                     \par
                     IF( med_diag%RR_1000%dgsave ) THEN\par
                        CALL iom_put( "RR_1000"  , ffastca2d )\par
                        CALL wrk_dealloc( jpi, jpj,  ffastca2d    )\par
                     ENDIF\par
                     IF( med_diag%SDC_1000%dgsave ) THEN\par
                        zw2d(:,:) = fslowcflux(:,:) * tmask(:,:,jk)\par
                        CALL iom_put( "SDC_1000"  , zw2d )\par
                     ENDIF \par
# endif                      \par
                 ENDIF\par
                 !! to do on every k loop :\par
                 IF( med_diag%DETFLUX3%dgsave ) THEN\par
                      detflux3d(:,:,jk) = (fslownflux(:,:) + ffastn(:,:)) * tmask(:,:,jk) !! detrital flux\par
                      !CALL iom_put( "DETFLUX3"  , ftot_n )\par
                 ENDIF\par
# if defined key_roam                     \par
                 IF( med_diag%EXPC3%dgsave ) THEN\par
                    expc3(:,:,jk) = (fslowcflux(:,:) + ffastc(:,:)) * tmask(:,:,jk)\par
                 ENDIF\tab\tab      \par
                 IF( med_diag%EXPN3%dgsave ) THEN\par
                    expn3(:,:,jk) = (fslownflux(:,:) + ffastn(:,:)) * tmask(:,:,jk)\par
                 ENDIF\tab\tab      \par
# endif\tab\tab      \par
              ENDIF\par
      !! CLOSE vertical loop\par
      ENDDO\par
\par
      !!----------------------------------------------------------------------\par
      !! Process benthic in/out fluxes\par
      !! These can be handled outside of the 3D calculations since the\par
      !! benthic pools (and fluxes) are 2D in nature; this code is\par
      !! (shamelessly) borrowed from corresponding code in the LOBSTER\par
      !! model\par
      !!----------------------------------------------------------------------\par
      !!\par
      !! IF(lwp) WRITE(numout,*) 'AXY: rdt = ', rdt\par
      if (jorgben.eq.1) then\par
         za_sed_n(:,:)  = zn_sed_n(:,:)  + & \par
         &                ( f_sbenin_n(:,:)  + f_fbenin_n(:,:)  - f_benout_n(:,:)  ) * (rdt / 86400.)\par
         zn_sed_n(:,:)  = za_sed_n(:,:)\par
         !!\par
         za_sed_fe(:,:) = zn_sed_fe(:,:) + &\par
         &                ( f_sbenin_fe(:,:) + f_fbenin_fe(:,:) - f_benout_fe(:,:) ) * (rdt / 86400.)\par
         zn_sed_fe(:,:) = za_sed_fe(:,:)\par
         !!\par
         za_sed_c(:,:)  = zn_sed_c(:,:)  + &\par
         &                ( f_sbenin_c(:,:)  + f_fbenin_c(:,:)  - f_benout_c(:,:)  ) * (rdt / 86400.)\par
         zn_sed_c(:,:)  = za_sed_c(:,:)\par
      endif\par
      if (jinorgben.eq.1) then\par
         za_sed_si(:,:) = zn_sed_si(:,:) + & \par
         &                ( f_fbenin_si(:,:) - f_benout_si(:,:) ) * (rdt / 86400.)\par
         zn_sed_si(:,:) = za_sed_si(:,:)\par
         !!\par
         za_sed_ca(:,:) = zn_sed_ca(:,:) + &\par
         &                ( f_fbenin_ca(:,:) - f_benout_ca(:,:) ) * (rdt / 86400.)\par
         zn_sed_ca(:,:) = za_sed_ca(:,:)\par
      endif\par
      IF( ln_diatrc ) THEN\par
         DO jj = 2,jpjm1\par
            DO ji = 2,jpim1\par
               trc2d(ji,jj,131) = za_sed_n(ji,jj)\par
               trc2d(ji,jj,132) = za_sed_fe(ji,jj)\par
               trc2d(ji,jj,133) = za_sed_c(ji,jj)\par
               trc2d(ji,jj,134) = za_sed_si(ji,jj)\par
               trc2d(ji,jj,135) = za_sed_ca(ji,jj)\par
            ENDDO\par
         ENDDO\par
         !! AXY (07/07/15): temporary hijacking\par
# if defined key_roam\par
  !!       trc2d(:,:,126) = zn_dms_chn(:,:)\par
  !!       trc2d(:,:,127) = zn_dms_chd(:,:)\par
  !!       trc2d(:,:,128) = zn_dms_mld(:,:)\par
  !!       trc2d(:,:,129) = zn_dms_qsr(:,:)\par
  !!       trc2d(:,:,130) = zn_dms_din(:,:)\par
# endif\par
      ENDIF \par
      !!\par
      if (ibenthic.eq.2) then\par
         !! The code below (in this if ... then ... endif loop) is\par
         !! effectively commented out because it does not work as \par
         !! anticipated; it can be deleted at a later date\par
         if (jorgben.eq.1) then\par
            za_sed_n(:,:)  = ( f_sbenin_n(:,:)  + f_fbenin_n(:,:)  - f_benout_n(:,:)  ) * rdt\par
            za_sed_fe(:,:) = ( f_sbenin_fe(:,:) + f_fbenin_fe(:,:) - f_benout_fe(:,:) ) * rdt\par
            za_sed_c(:,:)  = ( f_sbenin_c(:,:)  + f_fbenin_c(:,:)  - f_benout_c(:,:)  ) * rdt\par
         endif\par
         if (jinorgben.eq.1) then\par
            za_sed_si(:,:) = ( f_fbenin_si(:,:) - f_benout_si(:,:) ) * rdt\par
            za_sed_ca(:,:) = ( f_fbenin_ca(:,:) - f_benout_ca(:,:) ) * rdt\par
         endif\par
         !!\par
         !! Leap-frog scheme - only in explicit case, otherwise the time stepping\par
         !! is already being done in trczdf\par
         !! IF( l_trczdf_exp .AND. (ln_trcadv_cen2 .OR. ln_trcadv_tvd) ) THEN\par
         !!    zfact = 2. * rdttra(jk) * FLOAT( ndttrc )\par
         !!    IF( neuler == 0 .AND. kt == nittrc000 )   zfact = rdttra(jk) * FLOAT(ndttrc)\par
         !!    if (jorgben.eq.1) then\par
         !!       za_sed_n(:,:)  = zb_sed_n(:,:)  + ( zfact * za_sed_n(:,:)  )\par
         !!      za_sed_fe(:,:) = zb_sed_fe(:,:) + ( zfact * za_sed_fe(:,:) )\par
         !!       za_sed_c(:,:)  = zb_sed_c(:,:)  + ( zfact * za_sed_c(:,:)  )\par
         !!    endif\par
         !!    if (jinorgben.eq.1) then\par
         !!       za_sed_si(:,:) = zb_sed_si(:,:) + ( zfact * za_sed_si(:,:) )\par
         !!       za_sed_ca(:,:) = zb_sed_ca(:,:) + ( zfact * za_sed_ca(:,:) )\par
         !!    endif\par
         !! ENDIF\par
         !! \par
         !! Time filter and swap of arrays\par
         IF( ln_trcadv_cen2 .OR. ln_trcadv_tvd  ) THEN ! centred or tvd scheme\par
            IF( neuler == 0 .AND. kt == nittrc000 ) THEN\par
               if (jorgben.eq.1) then\par
                  zb_sed_n(:,:)  = zn_sed_n(:,:)\par
                  zn_sed_n(:,:)  = za_sed_n(:,:)\par
                  za_sed_n(:,:)  = 0.0\par
                  !!\par
                  zb_sed_fe(:,:) = zn_sed_fe(:,:)\par
                  zn_sed_fe(:,:) = za_sed_fe(:,:)\par
                  za_sed_fe(:,:) = 0.0\par
                  !!\par
                  zb_sed_c(:,:)  = zn_sed_c(:,:)\par
                  zn_sed_c(:,:)  = za_sed_c(:,:)\par
                  za_sed_c(:,:)  = 0.0\par
               endif\par
               if (jinorgben.eq.1) then\par
                  zb_sed_si(:,:) = zn_sed_si(:,:)\par
                  zn_sed_si(:,:) = za_sed_si(:,:)\par
                  za_sed_si(:,:) = 0.0\par
                  !!\par
                  zb_sed_ca(:,:) = zn_sed_ca(:,:)\par
                  zn_sed_ca(:,:) = za_sed_ca(:,:)\par
                  za_sed_ca(:,:) = 0.0\par
               endif\par
            ELSE\par
               if (jorgben.eq.1) then\par
                  zb_sed_n(:,:)  = (atfp  * ( zb_sed_n(:,:)  + za_sed_n(:,:)  )) + (atfp1 * zn_sed_n(:,:) )\par
                  zn_sed_n(:,:)  = za_sed_n(:,:)\par
                  za_sed_n(:,:)  = 0.0\par
                  !!\par
                  zb_sed_fe(:,:) = (atfp  * ( zb_sed_fe(:,:) + za_sed_fe(:,:) )) + (atfp1 * zn_sed_fe(:,:))\par
                  zn_sed_fe(:,:) = za_sed_fe(:,:)\par
                  za_sed_fe(:,:) = 0.0\par
                  !!\par
                  zb_sed_c(:,:)  = (atfp  * ( zb_sed_c(:,:)  + za_sed_c(:,:)  )) + (atfp1 * zn_sed_c(:,:) )\par
                  zn_sed_c(:,:)  = za_sed_c(:,:)\par
                  za_sed_c(:,:)  = 0.0\par
               endif\par
               if (jinorgben.eq.1) then\par
                  zb_sed_si(:,:) = (atfp  * ( zb_sed_si(:,:) + za_sed_si(:,:) )) + (atfp1 * zn_sed_si(:,:))\par
                  zn_sed_si(:,:) = za_sed_si(:,:)\par
                  za_sed_si(:,:) = 0.0\par
                  !!\par
                  zb_sed_ca(:,:) = (atfp  * ( zb_sed_ca(:,:) + za_sed_ca(:,:) )) + (atfp1 * zn_sed_ca(:,:))\par
                  zn_sed_ca(:,:) = za_sed_ca(:,:)\par
                  za_sed_ca(:,:) = 0.0\par
               endif\par
            ENDIF\par
         ELSE                   !  case of smolar scheme or muscl\par
            if (jorgben.eq.1) then\par
               zb_sed_n(:,:)  = za_sed_n(:,:)\par
               zn_sed_n(:,:)  = za_sed_n(:,:)\par
               za_sed_n(:,:)  = 0.0\par
               !!\par
               zb_sed_fe(:,:) = za_sed_fe(:,:)\par
               zn_sed_fe(:,:) = za_sed_fe(:,:)\par
               za_sed_fe(:,:) = 0.0\par
               !!\par
               zb_sed_c(:,:)  = za_sed_c(:,:)\par
               zn_sed_c(:,:)  = za_sed_c(:,:)\par
               za_sed_c(:,:)  = 0.0\par
            endif\par
            if (jinorgben.eq.1) then\par
               zb_sed_si(:,:) = za_sed_si(:,:)\par
               zn_sed_si(:,:) = za_sed_si(:,:)\par
               za_sed_si(:,:) = 0.0\par
               !!\par
               zb_sed_ca(:,:) = za_sed_ca(:,:)\par
               zn_sed_ca(:,:) = za_sed_ca(:,:)\par
               za_sed_ca(:,:) = 0.0\par
            endif\par
         ENDIF\par
      endif\par
      \par
# if defined key_foam_medusa\par
      !!----------------------------------------------------------------------\par
      !! Dianostics required for ocean colour assimilation:\par
      !! Mixed layer average phytoplankton growth, loss and concentration\par
      !! Maximum mixed layer depth\par
      !!----------------------------------------------------------------------\par
      !!\par
      DO jj = 2,jpjm1\par
         DO ji = 2,jpim1\par
            pgrow_avg(ji,jj) = pgrow_avg(ji,jj) / hmld(ji,jj)\par
            ploss_avg(ji,jj) = ploss_avg(ji,jj) / hmld(ji,jj)\par
            phyt_avg(ji,jj)  = phyt_avg(ji,jj)  / hmld(ji,jj)\par
            IF ( hmld(ji,jj) .GT. mld_max(ji,jj) ) THEN\par
               mld_max(ji,jj) = hmld(ji,jj)\par
            ENDIF\par
         END DO\par
      END DO\par
# endif\par
\par
      IF( ln_diatrc ) THEN\par
         !!----------------------------------------------------------------------\par
         !! Output several accumulated diagnostics\par
         !!   - biomass-average phytoplankton limitation terms\par
         !!   - integrated tendency terms\par
         !!----------------------------------------------------------------------\par
         !! \par
         DO jj = 2,jpjm1\par
            DO ji = 2,jpim1\par
               !! non-diatom phytoplankton limitations\par
               trc2d(ji,jj,25)  = trc2d(ji,jj,25) / MAX(ftot_pn(ji,jj), rsmall)\par
               trc2d(ji,jj,26)  = trc2d(ji,jj,26) / MAX(ftot_pn(ji,jj), rsmall)\par
               trc2d(ji,jj,27)  = trc2d(ji,jj,27) / MAX(ftot_pn(ji,jj), rsmall)\par
               !! diatom phytoplankton limitations\par
               trc2d(ji,jj,28)  = trc2d(ji,jj,28) / MAX(ftot_pd(ji,jj), rsmall)\par
               trc2d(ji,jj,29)  = trc2d(ji,jj,29) / MAX(ftot_pd(ji,jj), rsmall)\par
               trc2d(ji,jj,30)  = trc2d(ji,jj,30) / MAX(ftot_pd(ji,jj), rsmall)\par
               trc2d(ji,jj,31)  = trc2d(ji,jj,31) / MAX(ftot_pd(ji,jj), rsmall)\par
               trc2d(ji,jj,32)  = trc2d(ji,jj,32) / MAX(ftot_pd(ji,jj), rsmall)\par
               !! tendency terms\par
               trc2d(ji,jj,76)  = fflx_n(ji,jj)\par
               trc2d(ji,jj,77)  = fflx_si(ji,jj)\par
               trc2d(ji,jj,78)  = fflx_fe(ji,jj)\par
               !! integrated biomass\par
               trc2d(ji,jj,79)  = ftot_pn(ji,jj)       !! integrated non-diatom phytoplankton\par
               trc2d(ji,jj,80)  = ftot_pd(ji,jj)       !! integrated diatom phytoplankton\par
               trc2d(ji,jj,217) = ftot_zmi(ji,jj)      !! Integrated microzooplankton\par
               trc2d(ji,jj,218) = ftot_zme(ji,jj)      !! Integrated mesozooplankton\par
               trc2d(ji,jj,219) = ftot_det(ji,jj)      !! Integrated slow detritus, nitrogen\par
               trc2d(ji,jj,220) = ftot_dtc(ji,jj)      !! Integrated slow detritus, carbon\par
# if defined key_roam\par
               !! the balance of nitrogen production/consumption\par
               trc2d(ji,jj,111) = fnit_prod(ji,jj)  !! integrated nitrogen production\par
               trc2d(ji,jj,112) = fnit_cons(ji,jj)  !! integrated nitrogen consumption\par
               !! the balance of carbon production/consumption\par
               trc2d(ji,jj,113) = fcar_prod(ji,jj)  !! integrated carbon production\par
               trc2d(ji,jj,114) = fcar_cons(ji,jj)  !! integrated carbon consumption\par
               !! the balance of oxygen production/consumption\par
               trc2d(ji,jj,115) = foxy_prod(ji,jj)  !! integrated oxygen production\par
               trc2d(ji,jj,116) = foxy_cons(ji,jj)  !! integrated oxygen consumption\par
               trc2d(ji,jj,117) = foxy_anox(ji,jj)  !! integrated unrealised oxygen consumption\par
# endif\par
            ENDDO\par
         ENDDO\par
         \par
# if defined key_roam\par
#  if defined key_axy_nancheck\par
         !!----------------------------------------------------------------------\par
         !! Check for NaNs in diagnostic outputs\par
         !!----------------------------------------------------------------------\par
         !! \par
         !! 2D diagnostics\par
         DO jn = 1,150\par
            fq0 = SUM(trc2d(:,:,jn))\par
            !! AXY (30/01/14): "isnan" problem on HECTOR\par
            !! if (fq0 /= fq0 ) then\par
            if ( ieee_is_nan( fq0 ) ) then\par
               !! there's a NaN here\par
               if (lwp) write(numout,*) 'NAN detected in 2D diagnostic field', jn, 'at time', kt, 'at position:'\par
               DO jj = 1,jpj\par
                  DO ji = 1,jpi\par
                     if ( ieee_is_nan( trc2d(ji,jj,jn) ) ) then\par
                        if (lwp) write (numout,'(a,3i6)') 'NAN-CHECK', &\par
                        &        ji, jj, jn\par
                     endif\par
                  ENDDO\par
               ENDDO\par
\tab        CALL ctl_stop( 'trcbio_medusa, NAN in 2D diagnostic field' )\par
            endif\par
         ENDDO\par
         !!\par
         !! 3D diagnostics\par
         DO jn = 1,5\par
            fq0 = SUM(trc3d(:,:,:,jn))\par
            !! AXY (30/01/14): "isnan" problem on HECTOR\par
            !! if (fq0 /= fq0 ) then\par
            if ( ieee_is_nan( fq0 ) ) then\par
               !! there's a NaN here\par
               if (lwp) write(numout,*) 'NAN detected in 3D diagnostic field', jn, 'at time', kt, 'at position:'\par
               DO jk = 1,jpk\par
                  DO jj = 1,jpj\par
                     DO ji = 1,jpi\par
                        if ( ieee_is_nan( trc3d(ji,jj,jk,jn) ) ) then\par
                           if (lwp) write (numout,'(a,4i6)') 'NAN-CHECK', &\par
                           &        ji, jj, jk, jn\par
                        endif\par
                     ENDDO\par
                  ENDDO\par
               ENDDO\par
\tab        CALL ctl_stop( 'trcbio_medusa, NAN in 3D diagnostic field' )\par
            endif\par
         ENDDO\par
\tab  CALL flush(numout)\par
#  endif\par
# endif\par
\par
         !!----------------------------------------------------------------------\par
         !! Don't know what this does; belongs to someone else ...\par
         !!----------------------------------------------------------------------\par
         !! \par
         !! Lateral boundary conditions on trc2d\par
         DO jn=1,jp_medusa_2d\par
             CALL lbc_lnk(trc2d(:,:,jn),'T',1. )\par
         ENDDO \par
\par
         !! Lateral boundary conditions on trc3d\par
         DO jn=1,jp_medusa_3d\par
             CALL lbc_lnk(trc3d(:,:,1,jn),'T',1. )\par
         ENDDO \par
\par
\par
# if defined key_axy_nodiag\par
         !!----------------------------------------------------------------------\par
         !! Blank diagnostics as a NaN-trap\par
         !!----------------------------------------------------------------------\par
         !! \par
         !! blank 2D diagnostic array\par
         trc2d(:,:,:) = 0.e0\par
         !!\par
         !! blank 3D diagnostic array\par
         trc3d(:,:,:,:) = 0.e0\par
# endif\par
\par
\par
         !!----------------------------------------------------------------------\par
         !! Add in XML diagnostics stuff\par
         !!----------------------------------------------------------------------\par
         !!\par
         !! ** 2D diagnostics\par
         DO jn=1,jp_medusa_2d\par
            CALL iom_put(TRIM(ctrc2d(jn)), trc2d(:,:,jn))\par
         END DO\par
!! AXY (17/02/14): don't think I need this if I modify the above for all diagnostics\par
!! #  if defined key_roam\par
!!          DO jn=91,jp_medusa_2d\par
!!             CALL iom_put(TRIM(ctrc2d(jn)), trc2d(:,:,jn))\par
!!          END DO      \par
!! #  endif\par
         !!\par
         !! ** 3D diagnostics\par
         DO jn=1,jp_medusa_3d\par
            CALL iom_put(TRIM(ctrc3d(jn)), trc3d(:,:,:,jn))\par
         END DO\par
!! AXY (17/02/14): don't think I need this if I modify the above for all diagnostics\par
!! #  if defined key_roam\par
!!          CALL iom_put(TRIM(ctrc3d(5)), trc3d(:,:,:,5))\par
!! #  endif\par
\par
\par
      ELSE IF( lk_iomput .AND. .NOT. ln_diatrc ) THEN\par
         !!!----------------------------------------------------------------------\par
         !! Add very last diag calculations \par
         !!!----------------------------------------------------------------------\par
         DO jj = 2,jpjm1\par
            DO ji = 2,jpim1\par
               !!         \par
               IF( med_diag%PN_JLIM%dgsave ) THEN\par
                  fjln2d(ji,jj) = fjln2d(ji,jj)   / MAX(ftot_pn(ji,jj), rsmall)\par
               ENDIF\par
               IF( med_diag%PN_NLIM%dgsave ) THEN\par
                  fnln2d(ji,jj) = fnln2d(ji,jj)   / MAX(ftot_pn(ji,jj), rsmall)\par
               ENDIF\par
               IF( med_diag%PN_FELIM%dgsave ) THEN\par
                  ffln2d(ji,jj) = ffln2d(ji,jj)   / MAX(ftot_pn(ji,jj), rsmall)\par
               ENDIF\par
               IF( med_diag%PD_JLIM%dgsave ) THEN\par
                  fjld2d(ji,jj) = fjld2d(ji,jj)   / MAX(ftot_pd(ji,jj), rsmall)\par
               ENDIF\par
               IF( med_diag%PD_NLIM%dgsave ) THEN\par
                  fnld2d(ji,jj) = fnld2d(ji,jj)   / MAX(ftot_pd(ji,jj), rsmall)\par
               ENDIF\par
               IF( med_diag%PD_FELIM%dgsave ) THEN\par
                  ffld2d(ji,jj) = ffld2d(ji,jj)   / MAX(ftot_pd(ji,jj), rsmall)\par
               ENDIF\par
               IF( med_diag%PD_SILIM%dgsave ) THEN\par
                  fsld2d2(ji,jj) = fsld2d2(ji,jj) / MAX(ftot_pd(ji,jj), rsmall)\par
               ENDIF\par
               IF( med_diag%PDSILIM2%dgsave ) THEN\par
                  fsld2d(ji,jj) = fsld2d(ji,jj)   / MAX(ftot_pd(ji,jj), rsmall)\par
               ENDIF\par
            ENDDO\par
         ENDDO\par
         !!----------------------------------------------------------------------\par
         !! Add in XML diagnostics stuff\par
         !!----------------------------------------------------------------------\par
         !!\par
         !! ** 2D diagnostics\par
#   if defined key_debug_medusa\par
         IF (lwp) write (numout,*) 'trc_bio_medusa: export all diag.'\par
         CALL flush(numout)\par
#   endif\par
         IF ( med_diag%INVTN%dgsave ) THEN\par
            CALL iom_put( "INVTN"  , ftot_n )\par
         ENDIF\par
         IF ( med_diag%INVTSI%dgsave ) THEN\par
            CALL iom_put( "INVTSI"  , ftot_si )\par
         ENDIF\par
         IF ( med_diag%INVTFE%dgsave ) THEN\par
            CALL iom_put( "INVTFE"  , ftot_fe )\par
         ENDIF                           \par
         IF ( med_diag%ML_PRN%dgsave ) THEN\par
            CALL iom_put( "ML_PRN"  , fprn_ml )\par
         ENDIF\par
         IF ( med_diag%ML_PRD%dgsave ) THEN\par
            CALL iom_put( "ML_PRD"  , fprd_ml )\par
         ENDIF\par
         IF ( med_diag%OCAL_LVL%dgsave ) THEN\par
            CALL iom_put( "OCAL_LVL"  , fccd )\par
         ENDIF\par
         IF ( med_diag%PN_JLIM%dgsave ) THEN\par
            CALL iom_put( "PN_JLIM"  , fjln2d )\par
            CALL wrk_dealloc( jpi, jpj,   fjln2d   )\par
         ENDIF\par
         IF ( med_diag%PN_NLIM%dgsave ) THEN\par
            CALL iom_put( "PN_NLIM"  , fnln2d )\par
            CALL wrk_dealloc( jpi, jpj,   fnln2d   )\par
         ENDIF\par
         IF ( med_diag%PN_FELIM%dgsave ) THEN\par
            CALL iom_put( "PN_FELIM"  , ffln2d )\par
            CALL wrk_dealloc( jpi, jpj,   ffln2d   )\par
         ENDIF\par
         IF ( med_diag%PD_JLIM%dgsave ) THEN\par
            CALL iom_put( "PD_JLIM"  , fjld2d )\par
            CALL wrk_dealloc( jpi, jpj,  fjld2d    )\par
         ENDIF\par
         IF ( med_diag%PD_NLIM%dgsave ) THEN\par
            CALL iom_put( "PD_NLIM"  , fnld2d )\par
            CALL wrk_dealloc( jpi, jpj,   fnld2d  )\par
         ENDIF\par
         IF ( med_diag%PD_FELIM%dgsave ) THEN\par
            CALL iom_put( "PD_FELIM"  , ffld2d )\par
            CALL wrk_dealloc( jpi, jpj,  ffld2d    )\par
         ENDIF\par
         IF ( med_diag%PD_SILIM%dgsave ) THEN\par
            CALL iom_put( "PD_SILIM"  , fsld2d2 )\par
            CALL wrk_dealloc( jpi, jpj,   fsld2d2   )\par
         ENDIF\par
         IF ( med_diag%PDSILIM2%dgsave ) THEN\par
            CALL iom_put( "PDSILIM2"  , fsld2d )\par
            CALL wrk_dealloc( jpi, jpj,   fsld2d   )\par
         ENDIF\par
         IF ( med_diag%INTFLX_N%dgsave ) THEN\par
            CALL iom_put( "INTFLX_N"  , fflx_n )\par
         ENDIF\par
         IF ( med_diag%INTFLX_SI%dgsave ) THEN\par
            CALL iom_put( "INTFLX_SI"  , fflx_si )\par
         ENDIF\par
         IF ( med_diag%INTFLX_FE%dgsave ) THEN\par
            CALL iom_put( "INTFLX_FE"  , fflx_fe )\par
         ENDIF        \par
         IF ( med_diag%INT_PN%dgsave ) THEN\par
            CALL iom_put( "INT_PN"  , ftot_pn )\par
         ENDIF\par
         IF ( med_diag%INT_PD%dgsave ) THEN\par
            CALL iom_put( "INT_PD"  , ftot_pd )\par
         ENDIF         \par
         IF ( med_diag%INT_ZMI%dgsave ) THEN\par
            CALL iom_put( "INT_ZMI"  , ftot_zmi )\par
         ENDIF\par
         IF ( med_diag%INT_ZME%dgsave ) THEN\par
            CALL iom_put( "INT_ZME"  , ftot_zme )\par
         ENDIF\par
         IF ( med_diag%INT_DET%dgsave ) THEN\par
            CALL iom_put( "INT_DET"  , ftot_det )\par
         ENDIF\par
         IF ( med_diag%INT_DTC%dgsave ) THEN\par
            CALL iom_put( "INT_DTC"  , ftot_dtc )\par
         ENDIF\par
         IF ( med_diag%BEN_N%dgsave ) THEN\par
            CALL iom_put( "BEN_N"  , za_sed_n )\par
         ENDIF\par
         IF ( med_diag%BEN_FE%dgsave ) THEN\par
            CALL iom_put( "BEN_FE"  , za_sed_fe )\par
         ENDIF\par
         IF ( med_diag%BEN_C%dgsave ) THEN\par
            CALL iom_put( "BEN_C"  , za_sed_c )\par
         ENDIF\par
         IF ( med_diag%BEN_SI%dgsave ) THEN\par
            CALL iom_put( "BEN_SI"  , za_sed_si )\par
         ENDIF\par
         IF ( med_diag%BEN_CA%dgsave ) THEN\par
            CALL iom_put( "BEN_CA"  , za_sed_ca )\par
         ENDIF\par
         IF ( med_diag%RUNOFF%dgsave ) THEN\par
            CALL iom_put( "RUNOFF"  , f_runoff )\par
         ENDIF \par
# if defined key_roam        \par
         IF ( med_diag%N_PROD%dgsave ) THEN\par
            CALL iom_put( "N_PROD"  , fnit_prod )\par
         ENDIF\par
         IF ( med_diag%N_CONS%dgsave ) THEN\par
            CALL iom_put( "N_CONS"  , fnit_cons )\par
         ENDIF\par
         IF ( med_diag%C_PROD%dgsave ) THEN\par
            CALL iom_put( "C_PROD"  , fcar_prod )\par
         ENDIF\par
         IF ( med_diag%C_CONS%dgsave ) THEN\par
            CALL iom_put( "C_CONS"  , fcar_cons )\par
         ENDIF\par
         IF ( med_diag%O2_PROD%dgsave ) THEN\par
            CALL iom_put( "O2_PROD"  , foxy_prod )\par
         ENDIF\par
         IF ( med_diag%O2_CONS%dgsave ) THEN\par
            CALL iom_put( "O2_CONS"  , foxy_cons )\par
         ENDIF\par
         IF ( med_diag%O2_ANOX%dgsave ) THEN\par
            CALL iom_put( "O2_ANOX"  , foxy_anox )\par
         ENDIF\par
         IF ( med_diag%INVTC%dgsave ) THEN\par
            CALL iom_put( "INVTC"  , ftot_c )\par
         ENDIF\par
         IF ( med_diag%INVTALK%dgsave ) THEN\par
            CALL iom_put( "INVTALK"  , ftot_a )\par
         ENDIF\par
         IF ( med_diag%INVTO2%dgsave ) THEN\par
            CALL iom_put( "INVTO2"  , ftot_o2 )\par
         ENDIF\par
         IF ( med_diag%COM_RESP%dgsave ) THEN\par
            CALL iom_put( "COM_RESP"  , fcomm_resp )\par
         ENDIF         \par
# endif      \par
         !!\par
         !! diagnostic filled in the i-j-k main loop\par
         !!--------------------------------------------\par
         IF ( med_diag%PRN%dgsave ) THEN\par
            CALL iom_put( "PRN"  , fprn2d )\par
            CALL wrk_dealloc( jpi, jpj,   fprn2d   )\par
         ENDIF\par
         IF ( med_diag%MPN%dgsave ) THEN\par
            CALL iom_put( "MPN"  ,fdpn2d  )\par
            CALL wrk_dealloc( jpi, jpj,    fdpn2d  )\par
         ENDIF\par
         IF ( med_diag%PRD%dgsave ) THEN\par
            CALL iom_put( "PRD"  ,fprd2d  )\par
            CALL wrk_dealloc( jpi, jpj,   fprd2d  )\par
         ENDIF\par
         IF( med_diag%MPD%dgsave ) THEN\par
            CALL iom_put( "MPD"  , fdpd2d )\par
            CALL wrk_dealloc( jpi, jpj,    fdpd2d )\par
         ENDIF\par
         !  IF( med_diag%DSED%dgsave ) THEN\par
         !      CALL iom_put( "DSED"  , ftot_n )\par
         !  ENDIF\par
         IF( med_diag%OPAL%dgsave ) THEN\par
            CALL iom_put( "OPAL"  , fprds2d )\par
            CALL wrk_dealloc( jpi, jpj,   fprds2d  )\par
         ENDIF\par
         IF( med_diag%OPALDISS%dgsave ) THEN\par
            CALL iom_put( "OPALDISS"  , fsdiss2d )\par
            CALL wrk_dealloc( jpi, jpj,   fsdiss2d  )\par
         ENDIF\par
         IF( med_diag%GMIPn%dgsave ) THEN\par
            CALL iom_put( "GMIPn"  , fgmipn2d )\par
            CALL wrk_dealloc( jpi, jpj,   fgmipn2d  )\par
         ENDIF\par
         IF( med_diag%GMID%dgsave ) THEN\par
            CALL iom_put( "GMID"  , fgmid2d )\par
            CALL wrk_dealloc( jpi, jpj,  fgmid2d  )\par
         ENDIF\par
         IF( med_diag%MZMI%dgsave ) THEN\par
            CALL iom_put( "MZMI"  , fdzmi2d )\par
            CALL wrk_dealloc( jpi, jpj,   fdzmi2d   )\par
         ENDIF\par
         IF( med_diag%GMEPN%dgsave ) THEN\par
            CALL iom_put( "GMEPN"  , fgmepn2d )\par
            CALL wrk_dealloc( jpi, jpj,   fgmepn2d  )\par
         ENDIF\par
         IF( med_diag%GMEPD%dgsave ) THEN\par
            CALL iom_put( "GMEPD"  , fgmepd2d )\par
            CALL wrk_dealloc( jpi, jpj,   fgmepd2d   )\par
         ENDIF\par
         IF( med_diag%GMEZMI%dgsave ) THEN\par
            CALL iom_put( "GMEZMI"  , fgmezmi2d )\par
            CALL wrk_dealloc( jpi, jpj,   fgmezmi2d   )\par
         ENDIF\par
         IF( med_diag%GMED%dgsave ) THEN\par
            CALL iom_put( "GMED"  , fgmed2d )\par
            CALL wrk_dealloc( jpi, jpj,    fgmed2d  )\par
         ENDIF\par
         IF( med_diag%MZME%dgsave ) THEN\par
            CALL iom_put( "MZME"  , fdzme2d )\par
            CALL wrk_dealloc( jpi, jpj,  fdzme2d    )\par
         ENDIF\par
         !  IF( med_diag%DEXP%dgsave ) THEN\par
         !      CALL iom_put( "DEXP"  , ftot_n )\par
         !  ENDIF\par
         IF( med_diag%DETN%dgsave ) THEN\par
            CALL iom_put( "DETN"  , fslown2d )\par
            CALL wrk_dealloc( jpi, jpj,  fslown2d    )\par
         ENDIF\par
         IF( med_diag%MDET%dgsave ) THEN\par
            CALL iom_put( "MDET"  , fdd2d )\par
            CALL wrk_dealloc( jpi, jpj,   fdd2d   )\par
         ENDIF\par
         IF( med_diag%AEOLIAN%dgsave ) THEN\par
            CALL iom_put( "AEOLIAN"  , ffetop2d )\par
            CALL wrk_dealloc( jpi, jpj,   ffetop2d   )\par
         ENDIF\par
         IF( med_diag%BENTHIC%dgsave ) THEN\par
            CALL iom_put( "BENTHIC"  , ffebot2d )\par
            CALL wrk_dealloc( jpi, jpj,   ffebot2d   )\par
         ENDIF\par
         IF( med_diag%SCAVENGE%dgsave ) THEN\par
            CALL iom_put( "SCAVENGE"  , ffescav2d )\par
            CALL wrk_dealloc( jpi, jpj,   ffescav2d  )\par
         ENDIF\par
         !! \par
         IF( med_diag%TOTREG_N%dgsave ) THEN\par
            CALL iom_put( "TOTREG_N"  , fregen2d )\par
            CALL wrk_dealloc( jpi, jpj,   fregen2d   )\par
         ENDIF\par
         IF( med_diag%TOTRG_SI%dgsave ) THEN\par
            CALL iom_put( "TOTRG_SI"  , fregensi2d )\par
            CALL wrk_dealloc( jpi, jpj,    fregensi2d  )\par
         ENDIF\par
         !! \par
         IF( med_diag%FASTN%dgsave ) THEN\par
            CALL iom_put( "FASTN"  , ftempn2d )\par
            CALL wrk_dealloc( jpi, jpj,   ftempn2d   )\par
         ENDIF\par
         IF( med_diag%FASTSI%dgsave ) THEN\par
            CALL iom_put( "FASTSI"  , ftempsi2d )\par
            CALL wrk_dealloc( jpi, jpj,   ftempsi2d   )\par
         ENDIF\par
         IF( med_diag%FASTFE%dgsave ) THEN\par
            CALL iom_put( "FASTFE"  , ftempfe2d )\par
            CALL wrk_dealloc( jpi, jpj,    ftempfe2d  )\par
         ENDIF\par
         IF( med_diag%FASTC%dgsave ) THEN\par
            CALL iom_put( "FASTC"  , ftempc2d )\par
            CALL wrk_dealloc( jpi, jpj,  ftempc2d    )\par
         ENDIF\par
         IF( med_diag%FASTCA%dgsave ) THEN\par
            CALL iom_put( "FASTCA"  , ftempca2d )\par
            CALL wrk_dealloc( jpi, jpj,  ftempca2d   )\par
         ENDIF\par
         !! \par
         IF( med_diag%REMINN%dgsave ) THEN\par
            CALL iom_put( "REMINN"  , freminn2d )\par
            CALL wrk_dealloc( jpi, jpj,   freminn2d   )\par
         ENDIF\par
         IF( med_diag%REMINSI%dgsave ) THEN\par
            CALL iom_put( "REMINSI"  , freminsi2d )\par
            CALL wrk_dealloc( jpi, jpj,   freminsi2d   )\par
         ENDIF\par
         IF( med_diag%REMINFE%dgsave ) THEN\par
            CALL iom_put( "REMINFE"  , freminfe2d )\par
            CALL wrk_dealloc( jpi, jpj,  freminfe2d    )\par
         ENDIF\par
         IF( med_diag%REMINC%dgsave ) THEN\par
            CALL iom_put( "REMINC"  , freminc2d )\par
            CALL wrk_dealloc( jpi, jpj,    freminc2d  )\par
         ENDIF\par
         IF( med_diag%REMINCA%dgsave ) THEN\par
            CALL iom_put( "REMINCA"  , freminca2d )\par
            CALL wrk_dealloc( jpi, jpj,   freminca2d  )\par
         ENDIF\par
         IF( med_diag%SEAFLRN%dgsave ) THEN\par
            CALL iom_put( "SEAFLRN"  , fsedn )\par
         ENDIF\par
         IF( med_diag%SEAFLRSI%dgsave ) THEN\par
            CALL iom_put( "SEAFLRSI"  , fsedsi )\par
         ENDIF\par
         IF( med_diag%SEAFLRFE%dgsave ) THEN\par
            CALL iom_put( "SEAFLRFE"  , fsedfe )\par
         ENDIF\par
         IF( med_diag%SEAFLRC%dgsave ) THEN\par
            CALL iom_put( "SEAFLRC"  , fsedc )\par
         ENDIF\par
         IF( med_diag%SEAFLRCA%dgsave ) THEN\par
            CALL iom_put( "SEAFLRCA"  , fsedca )\par
         ENDIF\par
         !!\par
# if defined key_roam            \par
         !!\par
         IF( med_diag%RIV_N%dgsave ) THEN\par
            CALL iom_put( "RIV_N"  , rivn2d )\par
            CALL wrk_dealloc( jpi, jpj,    rivn2d  )\par
         ENDIF\par
         IF( med_diag%RIV_SI%dgsave ) THEN\par
            CALL iom_put( "RIV_SI"  , rivsi2d )\par
            CALL wrk_dealloc( jpi, jpj,   rivsi2d   )\par
         ENDIF\par
         IF( med_diag%RIV_C%dgsave ) THEN\par
            CALL iom_put( "RIV_C"  , rivc2d )\par
            CALL wrk_dealloc( jpi, jpj,    rivc2d  )\par
         ENDIF\par
         IF( med_diag%RIV_ALK%dgsave ) THEN\par
            CALL iom_put( "RIV_ALK"  , rivalk2d )\par
            CALL wrk_dealloc( jpi, jpj,  rivalk2d    )\par
         ENDIF\par
         IF( med_diag%DETC%dgsave ) THEN\par
            CALL iom_put( "DETC"  , fslowc2d )\par
            CALL wrk_dealloc( jpi, jpj,   fslowc2d   )\par
         ENDIF\par
         !!\par
         IF( med_diag%PN_LLOSS%dgsave ) THEN\par
            CALL iom_put( "PN_LLOSS"  , fdpn22d )\par
            CALL wrk_dealloc( jpi, jpj,   fdpn22d   )\par
         ENDIF\par
         IF( med_diag%PD_LLOSS%dgsave ) THEN\par
            CALL iom_put( "PD_LLOSS"  , fdpd22d )\par
            CALL wrk_dealloc( jpi, jpj,   fdpd22d   )\par
         ENDIF\par
         IF( med_diag%ZI_LLOSS%dgsave ) THEN\par
            CALL iom_put( "ZI_LLOSS"  , fdzmi22d )\par
             CALL wrk_dealloc( jpi, jpj,    fdzmi22d  )\par
          ENDIF\par
          IF( med_diag%ZE_LLOSS%dgsave ) THEN\par
             CALL iom_put( "ZE_LLOSS"  , fdzme22d )\par
             CALL wrk_dealloc( jpi, jpj,   fdzme22d   )\par
          ENDIF\par
          IF( med_diag%ZI_MES_N%dgsave ) THEN\par
             CALL iom_put( "ZI_MES_N"  , zimesn2d )\par
             CALL wrk_dealloc( jpi, jpj,    zimesn2d  )\par
          ENDIF\par
          IF( med_diag%ZI_MES_D%dgsave ) THEN\par
             CALL iom_put( "ZI_MES_D"  , zimesd2d )\par
             CALL wrk_dealloc( jpi, jpj,    zimesd2d  )\par
          ENDIF\par
          IF( med_diag%ZI_MES_C%dgsave ) THEN\par
             CALL iom_put( "ZI_MES_C"  , zimesc2d )\par
             CALL wrk_dealloc( jpi, jpj,    zimesc2d  )\par
          ENDIF\par
          IF( med_diag%ZI_MESDC%dgsave ) THEN\par
             CALL iom_put( "ZI_MESDC"  ,zimesdc2d  )\par
             CALL wrk_dealloc( jpi, jpj,    zimesdc2d  )\par
          ENDIF\par
          IF( med_diag%ZI_EXCR%dgsave ) THEN\par
             CALL iom_put( "ZI_EXCR"  , ziexcr2d )\par
             CALL wrk_dealloc( jpi, jpj,    ziexcr2d )\par
          ENDIF\par
          IF( med_diag%ZI_RESP%dgsave ) THEN\par
             CALL iom_put( "ZI_RESP"  , ziresp2d )\par
             CALL wrk_dealloc( jpi, jpj,   ziresp2d   )\par
          ENDIF\par
          IF( med_diag%ZI_GROW%dgsave ) THEN\par
             CALL iom_put( "ZI_GROW"  , zigrow2d )\par
             CALL wrk_dealloc( jpi, jpj,   zigrow2d   )\par
          ENDIF\par
          IF( med_diag%ZE_MES_N%dgsave ) THEN\par
             CALL iom_put( "ZE_MES_N"  , zemesn2d )\par
             CALL wrk_dealloc( jpi, jpj,    zemesn2d  )\par
          ENDIF\par
          IF( med_diag%ZE_MES_D%dgsave ) THEN\par
             CALL iom_put( "ZE_MES_D"  , zemesd2d )\par
             CALL wrk_dealloc( jpi, jpj,    zemesd2d  )\par
          ENDIF\par
          IF( med_diag%ZE_MES_C%dgsave ) THEN\par
             CALL iom_put( "ZE_MES_C"  , zemesc2d )\par
             CALL wrk_dealloc( jpi, jpj,   zemesc2d   )\par
          ENDIF\par
          IF( med_diag%ZE_MESDC%dgsave ) THEN\par
             CALL iom_put( "ZE_MESDC"  , zemesdc2d )\par
             CALL wrk_dealloc( jpi, jpj,   zemesdc2d   )\par
          ENDIF\par
          IF( med_diag%ZE_EXCR%dgsave ) THEN\par
             CALL iom_put( "ZE_EXCR"  , zeexcr2d )\par
             CALL wrk_dealloc( jpi, jpj,   zeexcr2d   )\par
          ENDIF\par
          IF( med_diag%ZE_RESP%dgsave ) THEN\par
             CALL iom_put( "ZE_RESP"  , zeresp2d )\par
             CALL wrk_dealloc( jpi, jpj,    zeresp2d  )\par
          ENDIF\par
          IF( med_diag%ZE_GROW%dgsave ) THEN\par
             CALL iom_put( "ZE_GROW"  , zegrow2d )\par
             CALL wrk_dealloc( jpi, jpj,   zegrow2d   )\par
          ENDIF\par
          IF( med_diag%MDETC%dgsave ) THEN\par
             CALL iom_put( "MDETC"  , mdetc2d )\par
             CALL wrk_dealloc( jpi, jpj,   mdetc2d   )\par
          ENDIF\par
          IF( med_diag%GMIDC%dgsave ) THEN\par
             CALL iom_put( "GMIDC"  , gmidc2d )\par
             CALL wrk_dealloc( jpi, jpj,    gmidc2d  )\par
          ENDIF\par
          IF( med_diag%GMEDC%dgsave ) THEN\par
             CALL iom_put( "GMEDC"  , gmedc2d )\par
             CALL wrk_dealloc( jpi, jpj,    gmedc2d  )\par
          ENDIF\par
          IF( med_diag%IBEN_N%dgsave ) THEN\par
             CALL iom_put( "IBEN_N"  , iben_n2d )\par
             CALL wrk_dealloc( jpi, jpj,    iben_n2d  )\par
          ENDIF\par
          IF( med_diag%IBEN_FE%dgsave ) THEN\par
             CALL iom_put( "IBEN_FE"  , iben_fe2d )\par
             CALL wrk_dealloc( jpi, jpj,   iben_fe2d   )\par
          ENDIF\par
          IF( med_diag%IBEN_C%dgsave ) THEN\par
             CALL iom_put( "IBEN_C"  , iben_c2d )\par
             CALL wrk_dealloc( jpi, jpj,   iben_c2d   )\par
          ENDIF\par
          IF( med_diag%IBEN_SI%dgsave ) THEN\par
             CALL iom_put( "IBEN_SI"  , iben_si2d )\par
             CALL wrk_dealloc( jpi, jpj,   iben_si2d   )\par
          ENDIF\par
          IF( med_diag%IBEN_CA%dgsave ) THEN\par
             CALL iom_put( "IBEN_CA"  , iben_ca2d )\par
             CALL wrk_dealloc( jpi, jpj,   iben_ca2d   )\par
          ENDIF\par
          IF( med_diag%OBEN_N%dgsave ) THEN\par
             CALL iom_put( "OBEN_N"  , oben_n2d )\par
             CALL wrk_dealloc( jpi, jpj,    oben_n2d  )\par
          ENDIF\par
          IF( med_diag%OBEN_FE%dgsave ) THEN\par
             CALL iom_put( "OBEN_FE"  , oben_fe2d )\par
             CALL wrk_dealloc( jpi, jpj,    oben_fe2d  )\par
          ENDIF\par
          IF( med_diag%OBEN_C%dgsave ) THEN\par
             CALL iom_put( "OBEN_C"  , oben_c2d )\par
             CALL wrk_dealloc( jpi, jpj,    oben_c2d  )\par
          ENDIF\par
          IF( med_diag%OBEN_SI%dgsave ) THEN\par
             CALL iom_put( "OBEN_SI"  , oben_si2d )\par
             CALL wrk_dealloc( jpi, jpj,    oben_si2d  )\par
          ENDIF\par
          IF( med_diag%OBEN_CA%dgsave ) THEN\par
             CALL iom_put( "OBEN_CA"  , oben_ca2d )\par
             CALL wrk_dealloc( jpi, jpj, oben_ca2d     )\par
          ENDIF\par
          IF( med_diag%SFR_OCAL%dgsave ) THEN\par
             CALL iom_put( "SFR_OCAL"  , sfr_ocal2d )\par
             CALL wrk_dealloc( jpi, jpj,    sfr_ocal2d  )\par
          ENDIF\par
          IF( med_diag%SFR_OARG%dgsave ) THEN\par
             CALL iom_put( "SFR_OARG"  , sfr_oarg2d )\par
             CALL wrk_dealloc( jpi, jpj,    sfr_oarg2d  )\par
          ENDIF\par
          IF( med_diag%LYSO_CA%dgsave ) THEN\par
             CALL iom_put( "LYSO_CA"  , lyso_ca2d )\par
             CALL wrk_dealloc( jpi, jpj,    lyso_ca2d  )\par
          ENDIF\par
# endif                   \par
          !!\par
          !! ** 3D diagnostics\par
          IF( med_diag%TPP3%dgsave ) THEN\par
             CALL iom_put( "TPP3"  , tpp3d )\par
             CALL wrk_dealloc( jpi, jpj, jpk,   tpp3d  )\par
          ENDIF\par
          IF( med_diag%DETFLUX3%dgsave ) THEN\par
             CALL iom_put( "DETFLUX3"  , detflux3d )\par
             CALL wrk_dealloc( jpi, jpj, jpk,    detflux3d )\par
          ENDIF\par
          IF( med_diag%REMIN3N%dgsave ) THEN\par
             CALL iom_put( "REMIN3N"  , remin3dn )\par
             CALL wrk_dealloc( jpi, jpj, jpk,   remin3dn  )\par
          ENDIF\par
# if defined key_roam          \par
          IF( med_diag%PH3%dgsave ) THEN\par
             CALL iom_put( "PH3"  , f3_pH )\par
          ENDIF\par
          IF( med_diag%OM_CAL3%dgsave ) THEN\par
             CALL iom_put( "OM_CAL3"  , f3_omcal )\par
          ENDIF\par
          !!\par
          !! AXY (09/11/16): 2D CMIP6 diagnostics\par
          IF( med_diag%INTDISSIC%dgsave ) THEN\par
             CALL iom_put( "INTDISSIC"  , intdissic )\par
             CALL wrk_dealloc( jpi, jpj, intdissic   )\par
          ENDIF          \par
          IF( med_diag%INTDISSIN%dgsave ) THEN\par
             CALL iom_put( "INTDISSIN"  , intdissin )\par
             CALL wrk_dealloc( jpi, jpj, intdissin   )\par
          ENDIF          \par
          IF( med_diag%INTDISSISI%dgsave ) THEN\par
             CALL iom_put( "INTDISSISI"  , intdissisi )\par
             CALL wrk_dealloc( jpi, jpj, intdissisi  )\par
          ENDIF          \par
          IF( med_diag%INTTALK%dgsave ) THEN\par
             CALL iom_put( "INTTALK"  , inttalk )\par
             CALL wrk_dealloc( jpi, jpj, inttalk     )\par
          ENDIF          \par
          IF( med_diag%O2min%dgsave ) THEN\par
             CALL iom_put( "O2min"  , o2min )\par
             CALL wrk_dealloc( jpi, jpj, o2min       )\par
          ENDIF          \par
          IF( med_diag%ZO2min%dgsave ) THEN\par
             CALL iom_put( "ZO2min"  , zo2min )\par
             CALL wrk_dealloc( jpi, jpj, zo2min      )\par
          ENDIF          \par
          IF( med_diag%FBDDTALK%dgsave ) THEN\par
             CALL iom_put( "FBDDTALK"  , fbddtalk   )\par
             CALL wrk_dealloc( jpi, jpj, fbddtalk   )\par
          ENDIF          \par
          IF( med_diag%FBDDTDIC%dgsave ) THEN\par
             CALL iom_put( "FBDDTDIC"  , fbddtdic   )\par
             CALL wrk_dealloc( jpi, jpj, fbddtdic   )\par
          ENDIF          \par
          IF( med_diag%FBDDTDIFE%dgsave ) THEN\par
             CALL iom_put( "FBDDTDIFE" , fbddtdife  )\par
             CALL wrk_dealloc( jpi, jpj, fbddtdife  )\par
          ENDIF          \par
          IF( med_diag%FBDDTDIN%dgsave ) THEN\par
             CALL iom_put( "FBDDTDIN"  , fbddtdin   )\par
             CALL wrk_dealloc( jpi, jpj, fbddtdin   )\par
          ENDIF          \par
          IF( med_diag%FBDDTDISI%dgsave ) THEN\par
             CALL iom_put( "FBDDTDISI" , fbddtdisi  )\par
             CALL wrk_dealloc( jpi, jpj, fbddtdisi  )\par
          ENDIF    \par
          !!\par
          !! AXY (09/11/16): 3D CMIP6 diagnostics\par
          IF( med_diag%TPPD3%dgsave ) THEN\par
             CALL iom_put( "TPPD3"     , tppd3 )\par
             CALL wrk_dealloc( jpi, jpj, jpk, tppd3      )\par
          ENDIF          \par
          IF( med_diag%BDDTALK3%dgsave ) THEN\par
             CALL iom_put( "BDDTALK3"  , bddtalk3 )\par
             CALL wrk_dealloc( jpi, jpj, jpk, bddtalk3   )\par
          ENDIF          \par
          IF( med_diag%BDDTDIC3%dgsave ) THEN\par
             CALL iom_put( "BDDTDIC3"  , bddtdic3 )\par
             CALL wrk_dealloc( jpi, jpj, jpk, bddtdic3   )\par
          ENDIF          \par
          IF( med_diag%BDDTDIFE3%dgsave ) THEN\par
             CALL iom_put( "BDDTDIFE3" , bddtdife3 )\par
             CALL wrk_dealloc( jpi, jpj, jpk, bddtdife3  )\par
          ENDIF          \par
          IF( med_diag%BDDTDIN3%dgsave ) THEN\par
             CALL iom_put( "BDDTDIN3"  , bddtdin3 )\par
             CALL wrk_dealloc( jpi, jpj, jpk, bddtdin3   )\par
          ENDIF          \par
          IF( med_diag%BDDTDISI3%dgsave ) THEN\par
             CALL iom_put( "BDDTDISI3" , bddtdisi3 )\par
             CALL wrk_dealloc( jpi, jpj, jpk, bddtdisi3  )\par
          ENDIF    \par
          IF( med_diag%FD_NIT3%dgsave ) THEN\par
             CALL iom_put( "FD_NIT3"  , fd_nit3 )\par
             CALL wrk_dealloc( jpi, jpj, jpk,   fd_nit3  )\par
          ENDIF\par
          IF( med_diag%FD_SIL3%dgsave ) THEN\par
             CALL iom_put( "FD_SIL3"  , fd_sil3 )\par
             CALL wrk_dealloc( jpi, jpj, jpk,   fd_sil3  )\par
          ENDIF\par
          IF( med_diag%FD_CAL3%dgsave ) THEN\par
             CALL iom_put( "FD_CAL3"  , fd_cal3 )\par
             CALL wrk_dealloc( jpi, jpj, jpk,   fd_cal3  )\par
          ENDIF\par
          IF( med_diag%FD_CAR3%dgsave ) THEN\par
             CALL iom_put( "FD_CAR3"  , fd_car3 )\par
             CALL wrk_dealloc( jpi, jpj, jpk,   fd_car3  )\par
          ENDIF\par
          IF( med_diag%CO33%dgsave ) THEN\par
             CALL iom_put( "CO33"  , f3_co3 )\par
          ENDIF          \tab         \par
          IF( med_diag%CO3SATARAG3%dgsave ) THEN\par
             CALL iom_put( "CO3SATARAG3"  , f3_omarg )\par
          ENDIF          \tab         \par
          IF( med_diag%CO3SATCALC3%dgsave ) THEN\par
             CALL iom_put( "CO3SATCALC3"  , f3_omcal )\par
          ENDIF          \tab         \par
          IF( med_diag%EXPC3%dgsave ) THEN\par
             CALL iom_put( "EXPC3"  , expc3 )\par
             CALL wrk_dealloc( jpi, jpj, jpk, expc3  )\par
          ENDIF          \tab         \par
          IF( med_diag%EXPN3%dgsave ) THEN\par
             CALL iom_put( "EXPN3"  , expn3 )\par
             CALL wrk_dealloc( jpi, jpj, jpk, expn3  )\par
          ENDIF          \tab         \par
          IF( med_diag%DCALC3%dgsave ) THEN\par
             CALL iom_put( "DCALC3"  , dcalc3 )\par
             CALL wrk_dealloc( jpi, jpj, jpk, dcalc3  )\par
          ENDIF          \tab         \par
          IF( med_diag%FEDISS3%dgsave ) THEN\par
             CALL iom_put( "FEDISS3"  , fediss3 )\par
             CALL wrk_dealloc( jpi, jpj, jpk, fediss3  )\par
          ENDIF          \tab         \par
          IF( med_diag%FESCAV3%dgsave ) THEN\par
             CALL iom_put( "FESCAV3"  , fescav3 )\par
             CALL wrk_dealloc( jpi, jpj, jpk, fescav3  )\par
          ENDIF          \tab         \par
          IF( med_diag%MIGRAZP3%dgsave ) THEN\par
             CALL iom_put( "MIGRAZP3"  , migrazp3 )\par
             CALL wrk_dealloc( jpi, jpj, jpk, migrazp3  )\par
          ENDIF          \tab         \par
          IF( med_diag%MIGRAZD3%dgsave ) THEN\par
             CALL iom_put( "MIGRAZD3"  , migrazd3 )\par
             CALL wrk_dealloc( jpi, jpj, jpk, migrazd3  )\par
          ENDIF          \tab         \par
          IF( med_diag%MEGRAZP3%dgsave ) THEN\par
             CALL iom_put( "MEGRAZP3"  , megrazp3 )\par
             CALL wrk_dealloc( jpi, jpj, jpk, megrazp3  )\par
          ENDIF          \tab         \par
          IF( med_diag%MEGRAZD3%dgsave ) THEN\par
             CALL iom_put( "MEGRAZD3"  , megrazd3 )\par
             CALL wrk_dealloc( jpi, jpj, jpk, megrazd3  )\par
          ENDIF          \tab         \par
          IF( med_diag%MEGRAZZ3%dgsave ) THEN\par
             CALL iom_put( "MEGRAZZ3"  , megrazz3 )\par
             CALL wrk_dealloc( jpi, jpj, jpk, megrazz3  )\par
          ENDIF          \tab         \par
          IF( med_diag%O2SAT3%dgsave ) THEN\par
             CALL iom_put( "O2SAT3"  , o2sat3 )\par
             CALL wrk_dealloc( jpi, jpj, jpk, o2sat3 )\par
          ENDIF          \tab         \par
          IF( med_diag%PBSI3%dgsave ) THEN\par
             CALL iom_put( "PBSI3"  , pbsi3 )\par
             CALL wrk_dealloc( jpi, jpj, jpk, pbsi3  )\par
          ENDIF          \tab         \par
          IF( med_diag%PCAL3%dgsave ) THEN\par
             CALL iom_put( "PCAL3"  , pcal3 )\par
             CALL wrk_dealloc( jpi, jpj, jpk, pcal3  )\par
          ENDIF          \tab         \par
          IF( med_diag%REMOC3%dgsave ) THEN\par
             CALL iom_put( "REMOC3"  , remoc3 )\par
             CALL wrk_dealloc( jpi, jpj, jpk, remoc3 )\par
          ENDIF          \tab         \par
          IF( med_diag%PNLIMJ3%dgsave ) THEN\par
             CALL iom_put( "PNLIMJ3" , pnlimj3 )\par
             CALL wrk_dealloc( jpi, jpj, jpk, pnlimj3  )\par
          ENDIF          \tab         \par
          IF( med_diag%PNLIMN3%dgsave ) THEN\par
             CALL iom_put( "PNLIMN3" , pnlimn3 )\par
             CALL wrk_dealloc( jpi, jpj, jpk, pnlimn3  )\par
          ENDIF          \tab         \par
          IF( med_diag%PNLIMFE3%dgsave ) THEN\par
             CALL iom_put( "PNLIMFE3" , pnlimfe3 )\par
             CALL wrk_dealloc( jpi, jpj, jpk, pnlimfe3 )\par
          ENDIF          \tab         \par
          IF( med_diag%PDLIMJ3%dgsave ) THEN\par
             CALL iom_put( "PDLIMJ3" , pdlimj3 )\par
             CALL wrk_dealloc( jpi, jpj, jpk, pdlimj3  )\par
          ENDIF          \tab         \par
          IF( med_diag%PDLIMN3%dgsave ) THEN\par
             CALL iom_put( "PDLIMN3" , pdlimn3 )\par
             CALL wrk_dealloc( jpi, jpj, jpk, pdlimn3  )\par
          ENDIF          \tab         \par
          IF( med_diag%PDLIMFE3%dgsave ) THEN\par
             CALL iom_put( "PDLIMFE3" , pdlimfe3 )\par
             CALL wrk_dealloc( jpi, jpj, jpk, pdlimfe3 )\par
          ENDIF          \tab         \par
          IF( med_diag%PDLIMSI3%dgsave ) THEN\par
             CALL iom_put( "PDLIMSI3" , pdlimsi3 )\par
             CALL wrk_dealloc( jpi, jpj, jpk, pdlimsi3 )\par
          ENDIF          \tab         \par
          \par
# endif         \par
\par
          CALL wrk_dealloc( jpi, jpj,   zw2d   )\par
\par
       ENDIF                    ! end of ln_diatrc option\par
\par
# if defined key_trc_diabio\par
       !! Lateral boundary conditions on trcbio\par
       DO jn=1,jp_medusa_trd\par
          CALL lbc_lnk(trbio(:,:,1,jn),'T',1. )\par
       ENDDO \par
# endif\par
\par
# if defined key_debug_medusa\par
       IF(lwp) WRITE(numout,*) ' MEDUSA exiting trc_bio_medusa at kt =', kt\par
       CALL flush(numout)\par
# endif\par
\par
   END SUBROUTINE trc_bio_medusa\par
\par
#else\par
   !!======================================================================\par
   !!  Dummy module :                                   No MEDUSA bio-model\par
   !!======================================================================\par
CONTAINS\par
   SUBROUTINE trc_bio_medusa( kt )                   ! Empty routine\par
      INTEGER, INTENT( in ) ::   kt\par
      WRITE(*,*) 'trc_bio_medusa: You should not have seen this print! error?', kt\par
   END SUBROUTINE trc_bio_medusa\par
#endif \par
\par
   !!======================================================================\par
END MODULE  trcbio_medusa\par
\par
}
 